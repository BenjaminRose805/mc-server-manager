# Tasks Document -- Electron Migration (Remove Rust/Tauri)

- [x] 1. Create secure storage module
  - Files: `packages/electron/src/secure-storage.ts` (new)
  - Implement credential encryption/decryption using Electron's `safeStorage` API
  - Functions: `saveSecret(key, value)`, `getSecret(key)`, `deleteSecret(key)`, `isEncryptionAvailable()`
  - Store encrypted values as base64 strings in `{userData}/secure-storage.json`
  - Must only be called after Electron's `app.whenReady()` resolves
  - Purpose: Foundation for all credential storage — replaces Rust `keyring` crate
  - _Leverage: `packages/electron/src/main.ts` for `app.getPath('userData')` pattern, Electron `safeStorage` API docs_
  - _Requirements: REQ-1, REQ-3_
  - _Prompt: Implement the task for spec electron-migration, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Electron Developer with expertise in Electron's safeStorage API and secure credential management | Task: Create `packages/electron/src/secure-storage.ts` implementing OS-level credential encryption. Read `packages/electron/src/main.ts` for existing patterns and `app.getPath('userData')` usage. Implement: (1) `isEncryptionAvailable(): boolean` — wraps `safeStorage.isEncryptionAvailable()`. (2) `saveSecret(key: string, value: string): void` — encrypts with `safeStorage.encryptString()`, stores as base64 in a JSON file at `{userData}/secure-storage.json`. Read existing file, merge key, write back. (3) `getSecret(key: string): string | null` — reads JSON file, decodes base64, decrypts with `safeStorage.decryptString()`. Returns null if key missing. (4) `deleteSecret(key: string): void` — removes key from JSON file and writes back. Use `node:fs` (readFileSync/writeFileSync) and `node:path`. Handle missing file gracefully (create on first write). Handle decryption errors gracefully (return null, log warning). Reference `.spec-workflow/specs/electron-migration/design.md` for the storage schema: keys are `mc_access_token_{uuid}` and `ms_refresh_token_{uuid}`. | Restrictions: Do NOT use `electron-store` or any external dependency — only Electron built-ins and Node.js core. Do NOT call safeStorage before app is ready (document this in JSDoc). Do NOT store unencrypted values. Do NOT modify any other files in this task. | Success: Module exports all 4 functions, compiles without TypeScript errors, handles missing file and decryption errors gracefully, stores encrypted base64 in JSON format. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._

- [x] 2. Create Microsoft OAuth auth module
  - Files: `packages/electron/src/auth.ts` (new)
  - Port `packages/desktop/src-tauri/src/auth.rs` (360 lines) to TypeScript
  - Implement full chain: MS device code flow → Xbox Live auth → XSTS → Minecraft Services → profile fetch
  - Functions: `msAuthStart()`, `msAuthPoll()`, `msAuthRefresh(uuid)`, `getMcAccessToken(uuid)`, `removeAccount(uuid)`
  - Store tokens via `secure-storage.ts` with keys `mc_access_token_{uuid}` and `ms_refresh_token_{uuid}`
  - Module-level state: `pendingAuth` for device code polling
  - Purpose: Replaces Rust auth module — enables Microsoft login from Electron
  - _Leverage: `packages/desktop/src-tauri/src/auth.rs` (source of truth for auth chain), `packages/electron/src/secure-storage.ts` (task 1), shared types `MSAuthDeviceCode`, `MSAuthStatus` from `shared/src/index.ts`_
  - _Requirements: REQ-1_
  - _Prompt: Implement the task for spec electron-migration, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: TypeScript Developer with expertise in OAuth2 flows and Microsoft identity platform | Task: Create `packages/electron/src/auth.ts` — a direct TypeScript port of the Rust auth module. Read `packages/desktop/src-tauri/src/auth.rs` FIRST to understand the complete auth chain. Read `shared/src/index.ts` for `MSAuthDeviceCode`, `MSAuthStatus`, `LauncherAccount` types. Implement: (1) Constants: `MS_CLIENT_ID = "c36a9fb6-4f2a-41ff-90bd-ae7cc92031eb"` (same as Rust), `MS_TENANT = "consumers"`, `MS_SCOPE = "XboxLive.signin offline_access"`. (2) `msAuthStart()` — POST to `https://login.microsoftonline.com/consumers/oauth2/v2.0/devicecode` with client_id and scope, store response in module-level `pendingAuth`, return `MSAuthDeviceCode` shape `{ userCode, verificationUri, expiresIn, interval }`. (3) `msAuthPoll()` — POST to token endpoint polling for authorization_pending, on success chain through: Xbox Live auth (POST `https://user.auth.xboxlive.com/user/authenticate`), XSTS auth (POST `https://xsts.auth.xboxlive.com/xsts/authorize`), Minecraft login (POST `https://api.minecraftservices.com/authentication/login_with_xbox`), profile fetch (GET `https://api.minecraftservices.com/minecraft/profile`). Store MC access token and MS refresh token in secure storage. Return `MSAuthStatus` with `{ status: 'complete', account: { id, uuid, username, accountType: 'msa' } }`. (4) `msAuthRefresh(accountUuid)` — get MS refresh token from secure storage, POST to token endpoint with grant_type=refresh_token, re-run Xbox→XSTS→MC chain, update stored tokens. (5) `getMcAccessToken(accountUuid)` — get from secure storage, check expiry, auto-refresh if expired. (6) `removeAccount(accountUuid)` — delete both tokens from secure storage. Use native `fetch` for all HTTP calls. Follow the EXACT same endpoint URLs and request bodies as auth.rs. | Restrictions: Do NOT use any external HTTP library (no axios, no node-fetch — use Node.js native fetch). Do NOT store tokens anywhere except via secure-storage module. Do NOT implement UI — this is pure business logic. Do NOT modify shared types. Keep the same MS_CLIENT_ID as Rust. | Success: All 5 functions compile without errors, auth chain matches Rust implementation endpoint-for-endpoint, tokens stored via secure-storage, MSAuthDeviceCode and MSAuthStatus shapes match shared types. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._

- [x] 3. Extend backend Java service with multi-detection and Adoptium download
  - Files: `packages/backend/src/services/java.ts` (modify), `packages/backend/src/routes/launcher.ts` (modify)
  - Add `detectAllJavaInstallations()` — scans ALL locations (not just first-found), deduplicates by resolved path, returns `JavaInstallation[]`
  - Add `downloadJava(version, dataDir)` — downloads from Adoptium API, extracts tar.gz/zip, returns `JavaInstallation`
  - Add routes: `GET /api/launcher/java` and `POST /api/launcher/java/download`
  - Purpose: Replaces Rust `java.rs` — Java management moves to backend where it belongs
  - _Leverage: `packages/backend/src/services/java.ts` (existing detection), `packages/desktop/src-tauri/src/java.rs` (Rust implementation to port), `packages/backend/src/routes/launcher.ts` (existing launcher routes)_
  - _Requirements: REQ-2_
  - _Prompt: Implement the task for spec electron-migration, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in system detection and archive extraction | Task: Extend `packages/backend/src/services/java.ts` and add routes. Read the existing java.ts FIRST, then read `packages/desktop/src-tauri/src/java.rs` for the Rust implementation being ported. (1) Add `detectAllJavaInstallations(): Promise<JavaInstallation[]>` — scan JAVA_HOME, PATH, AND all common directories (not just first-found like current `detectJava`). For each directory in platform-specific locations (Linux: scan all dirs in `/usr/lib/jvm/`; macOS: scan all in `/Library/Java/JavaVirtualMachines/`; Windows: scan all in `C:\Program Files\Java\`, `C:\Program Files\Eclipse Adoptium\`), find `bin/java` binary, probe with `java -version`, parse version+vendor. Also scan `{dataDir}/launcher/runtime/` for previously downloaded JDKs. Deduplicate by `fs.realpathSync()`. Return array of `{ path, version, majorVersion, vendor }`. (2) Add `downloadJava(version: number, dataDir: string): Promise<JavaInstallation>` — construct Adoptium URL: `https://api.adoptium.net/v3/binary/latest/${version}/ga/${os}/${arch}/jdk/hotspot/normal/eclipse` where os=linux/mac/windows, arch=x64/aarch64. Download to temp file, extract to `{dataDir}/launcher/runtime/java-${version}/`. Use `tar` module for .tar.gz (Linux/macOS), `adm-zip` for .zip (Windows). Find the java binary in extracted dir, probe it, return `JavaInstallation`. (3) Add routes in `packages/backend/src/routes/launcher.ts`: `GET /api/launcher/java` returns all installations, `POST /api/launcher/java/download` with body `{ version: number }` triggers download. Check if `adm-zip` is already a dependency; if not, note it needs adding. Use `.js` extensions in imports. | Restrictions: Do NOT break existing `detectJava()` function — add new functions alongside it. Do NOT remove existing route handlers. Follow existing route patterns (async handler, try/catch/next). Do NOT download Java at startup — only on explicit request. | Success: `detectAllJavaInstallations()` finds all installed JDKs (matching Rust's scan behavior), `downloadJava()` downloads and extracts correctly, new routes work, existing functionality unchanged. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._

- [x] 4. Create game launcher module
  - Files: `packages/electron/src/launcher.ts` (new)
  - Port `packages/desktop/src-tauri/src/launcher.rs` (279 lines) to TypeScript
  - Functions: `launchGame(instanceId, accountId)`, `getRunningGames()`, `killGame(instanceId)`
  - Fetch instance from backend, get MC token, call prepare endpoint, resolve Java, build JVM+game args, spawn process
  - Track running games in module-level array, monitor exit events
  - Purpose: Replaces Rust launcher module — enables game launching from Electron
  - _Leverage: `packages/desktop/src-tauri/src/launcher.rs` (source of truth), `packages/electron/src/auth.ts` (task 2), `packages/backend/src/services/process.ts` for child_process patterns, shared type `GameProcess`_
  - _Requirements: REQ-3_
  - _Prompt: Implement the task for spec electron-migration, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: TypeScript Developer with expertise in child process management and Minecraft launch mechanics | Task: Create `packages/electron/src/launcher.ts` — a TypeScript port of the Rust launcher. Read `packages/desktop/src-tauri/src/launcher.rs` FIRST for the complete launch sequence. Read `packages/backend/src/services/process.ts` for existing child_process patterns. Read `shared/src/index.ts` for `GameProcess`, `LauncherInstance`, `PrepareResponse` types. Implement: (1) Module-level state: `const runningGames: GameProcess[] = []`. (2) `launchGame(instanceId: string, accountId: string): Promise<GameProcess>` — full sequence: check not already running for this instance, call `getMcAccessToken(accountId)` from auth module, fetch instance via `GET http://localhost:${port}/api/launcher/instances/${instanceId}`, call `POST http://localhost:${port}/api/launcher/prepare/${instanceId}` to get `{ classpath, mainClass, assetIndex, assetsDir, gameDir, nativesDir }`, resolve Java path (from instance.javaPath or auto-detect via `GET http://localhost:${port}/api/launcher/java`), build JVM args: `-Xms${instance.ramMin}G`, `-Xmx${instance.ramMax}G`, `-Djava.library.path=${nativesDir}`, `-cp ${classpath}`, then mainClass, then game args: `--username ${username}`, `--uuid ${uuid}`, `--accessToken ${token}`, `--gameDir ${gameDir}`, `--assetsDir ${assetsDir}`, `--assetIndex ${assetIndex}`, `--version ${instance.mcVersion}`. If instance.resolution: `--width ${w} --height ${h}`. Spawn with `child_process.spawn(javaPath, args, { cwd: gameDir, detached: false })`. Track in `runningGames`. Monitor `child.on('exit')` to remove from array. (3) `getRunningGames(): GameProcess[]` — return copy of runningGames. (4) `killGame(instanceId: string): Promise<void>` — find by instanceId, kill process, remove from array. Use `BACKEND_PORT` from environment or default 3001. | Restrictions: Do NOT re-implement file downloads (backend's prepare endpoint handles that). Do NOT block the main Electron process — spawn is non-blocking. Do NOT import from backend package directly — use HTTP fetch to backend. Do NOT modify any existing files. | Success: Launch constructs identical JVM/game args as Rust implementation, process spawns and is tracked, exit monitoring cleans up state, duplicate launch prevention works. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._

- [x] 5. Register IPC handlers and extend preload script
  - Files: `packages/electron/src/ipc.ts` (new), `packages/electron/src/preload.ts` (modify), `packages/electron/src/main.ts` (modify)
  - Create `ipc.ts` with `registerIpcHandlers()` — maps IPC channels to auth/launcher functions
  - Extend `preload.ts` to expose full `electronAPI` with auth, Java, and launcher methods
  - Call `registerIpcHandlers()` from `main.ts` after app is ready
  - Purpose: Wire Electron main process modules to renderer via secure IPC bridge
  - _Leverage: `packages/electron/src/preload.ts` (existing preload), `packages/electron/src/main.ts` (existing main), `packages/electron/src/auth.ts` (task 2), `packages/electron/src/launcher.ts` (task 4)_
  - _Requirements: REQ-4_
  - _Prompt: Implement the task for spec electron-migration, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Electron Developer with expertise in IPC patterns and contextBridge security | Task: Create IPC registration and extend preload. Read current `packages/electron/src/preload.ts` and `packages/electron/src/main.ts` FIRST. (1) Create `packages/electron/src/ipc.ts`: import `ipcMain` from electron, import auth functions from `./auth.js`, import launcher functions from `./launcher.js`. Export `registerIpcHandlers()` that calls `ipcMain.handle()` for each channel: `ms-auth-start` → `auth.msAuthStart()`, `ms-auth-poll` → `auth.msAuthPoll()`, `ms-auth-refresh` → `auth.msAuthRefresh(args.uuid)`, `get-mc-access-token` → `auth.getMcAccessToken(args.uuid)`, `remove-account` → `auth.removeAccount(args.uuid)`, `launch-game` → `launcher.launchGame(args.instanceId, args.accountId)`, `get-running-games` → `launcher.getRunningGames()`, `kill-game` → `launcher.killGame(args.instanceId)`. Wrap each handler in try/catch that re-throws as serializable error. (2) Modify `packages/electron/src/preload.ts`: import `ipcRenderer` from electron, expose full `electronAPI` via `contextBridge.exposeInMainWorld`: `platform`, `msAuthStart`, `msAuthPoll`, `msAuthRefresh`, `getMcAccessToken`, `removeAccount`, `launchGame`, `getRunningGames`, `killGame`. Each method calls `ipcRenderer.invoke(channel, args)`. (3) Modify `packages/electron/src/main.ts`: import `registerIpcHandlers` from `./ipc.js`, call it after `app.whenReady()` but before `createWindow()`. | Restrictions: Do NOT expose raw `ipcRenderer.send` or `ipcRenderer.on` — only `invoke` for request/response. Do NOT add a generic invoke passthrough — each method is explicit. Keep `contextIsolation: true` and `nodeIntegration: false`. Do NOT modify the existing window creation or tray logic. | Success: IPC handlers respond correctly to all channels, preload exposes typed electronAPI, main.ts registers handlers at startup, existing functionality (window, tray, backend) unchanged. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._

- [x] 6. Add TypeScript type declarations for electronAPI
  - Files: `packages/frontend/src/types/electron.d.ts` (new)
  - Declare `window.electronAPI` interface with all IPC methods and their signatures
  - Import shared types for return types
  - Purpose: Type-safe access to Electron IPC from frontend — enables IDE autocompletion
  - _Leverage: `packages/electron/src/preload.ts` (task 5) for exact API shape, `shared/src/index.ts` for shared types_
  - _Requirements: REQ-4_
  - _Prompt: Implement the task for spec electron-migration, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: TypeScript Developer with expertise in ambient type declarations and Electron preload typing | Task: Create `packages/frontend/src/types/electron.d.ts` declaring the `window.electronAPI` interface. Read `packages/electron/src/preload.ts` (modified in task 5) for the exact API shape. Read `shared/src/index.ts` for `MSAuthDeviceCode`, `MSAuthStatus`, `LauncherAccount`, `GameProcess`, `JavaInstallation` types. Declare: `interface ElectronAPI { platform: string; msAuthStart(): Promise<MSAuthDeviceCode>; msAuthPoll(): Promise<MSAuthStatus>; msAuthRefresh(uuid: string): Promise<LauncherAccount>; getMcAccessToken(uuid: string): Promise<string>; removeAccount(uuid: string): Promise<void>; launchGame(instanceId: string, accountId: string): Promise<GameProcess>; getRunningGames(): Promise<GameProcess[]>; killGame(instanceId: string): Promise<void>; }`. Then declare `interface Window { electronAPI?: ElectronAPI }` in the global scope. Use `import type` for shared types. | Restrictions: Do NOT make electronAPI non-optional — it must be `electronAPI?` since it's absent in browser mode. Do NOT add any runtime code — this is purely a type declaration file. | Success: `window.electronAPI?.msAuthStart()` has proper return type in IDE, no TypeScript errors in frontend, browser mode correctly sees `electronAPI` as possibly undefined. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._

- [x] 7. Migrate frontend from Tauri to Electron detection
  - Files: `packages/frontend/src/utils/desktop.ts` (new), `packages/frontend/src/utils/tauri.ts` (delete), `packages/frontend/src/utils/wait-for-backend.ts` (modify), `packages/frontend/src/api/client.ts` (modify), `packages/frontend/src/api/ws.ts` (modify), `packages/frontend/src/api/auth.ts` (modify), `packages/frontend/src/main.tsx` (modify)
  - Create `desktop.ts` with `isDesktop()` (checks `window.electronAPI`), `getBackendBaseUrl()`, `getBackendBaseUrlSync()`
  - Update all imports from `tauri.ts` → `desktop.ts`
  - Replace `isTauri()` → `isDesktop()` everywhere
  - Delete `tauri.ts`
  - Purpose: Frontend detects Electron instead of Tauri for environment-specific behavior
  - _Leverage: `packages/frontend/src/utils/tauri.ts` (being replaced), `packages/frontend/src/api/client.ts`, `packages/frontend/src/api/ws.ts`, `packages/frontend/src/api/auth.ts`, `packages/frontend/src/main.tsx`_
  - _Requirements: REQ-4_
  - _Prompt: Implement the task for spec electron-migration, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Frontend TypeScript Developer with expertise in environment detection and module refactoring | Task: Replace Tauri detection with Electron detection across the frontend. (1) Read ALL current files that import from `tauri.ts`: `packages/frontend/src/utils/tauri.ts`, `packages/frontend/src/api/client.ts`, `packages/frontend/src/api/ws.ts`, `packages/frontend/src/api/auth.ts`, `packages/frontend/src/main.tsx`, `packages/frontend/src/components/launcher/AccountManager.tsx`, `packages/frontend/src/components/launcher/LaunchButton.tsx`, `packages/frontend/src/pages/InstanceDetail.tsx`. (2) Create `packages/frontend/src/utils/desktop.ts`: export `isDesktop(): boolean` returning `typeof window !== 'undefined' && 'electronAPI' in window`. Export `getBackendBaseUrl(): string` and `getBackendBaseUrlSync(): string` — if `isDesktop()` return `http://localhost:3001`, else return empty string (relative URLs). (3) Update `packages/frontend/src/api/client.ts`: change import from `@/utils/tauri` to `@/utils/desktop`. (4) Update `packages/frontend/src/api/ws.ts`: change `isTauri()` to `isDesktop()`, import from `@/utils/desktop`. (5) Update `packages/frontend/src/api/auth.ts`: change import to `@/utils/desktop`. (6) Update `packages/frontend/src/main.tsx`: change `isTauri()` to `isDesktop()`, import from `@/utils/desktop`. (7) Update `packages/frontend/src/utils/wait-for-backend.ts`: change any `isTauri` references to `isDesktop`. (8) Delete `packages/frontend/src/utils/tauri.ts`. Do NOT update AccountManager.tsx or LaunchButton.tsx yet — that's task 8. | Restrictions: Do NOT change the behavior of the URL resolution — same logic, different detection. Do NOT modify component files that use tauriInvoke (those are task 8). Do NOT remove `@tauri-apps/api` from package.json yet (task 9). Ensure `getBackendBaseUrlSync()` has the same signature as before. | Success: All API/utility files use `isDesktop()` instead of `isTauri()`, `desktop.ts` exists with correct detection, `tauri.ts` is deleted, no TypeScript errors, browser mode and Electron mode both resolve URLs correctly. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._

- [x] 8. Migrate frontend components from tauriInvoke to electronAPI
  - Files: `packages/frontend/src/components/launcher/AccountManager.tsx` (modify), `packages/frontend/src/components/launcher/LaunchButton.tsx` (modify), `packages/frontend/src/pages/InstanceDetail.tsx` (modify if needed)
  - Replace all `tauriInvoke('command', args)` calls with `window.electronAPI?.method(args)`
  - Replace `isTauri()` checks with `isDesktop()`
  - Purpose: Frontend launcher components use Electron IPC instead of Tauri invoke
  - _Leverage: `packages/frontend/src/components/launcher/AccountManager.tsx`, `packages/frontend/src/components/launcher/LaunchButton.tsx`, `packages/frontend/src/types/electron.d.ts` (task 6)_
  - _Requirements: REQ-4, REQ-6_
  - _Prompt: Implement the task for spec electron-migration, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in Electron IPC integration | Task: Migrate launcher components from Tauri invoke to Electron IPC. Read each file FIRST to understand current usage. (1) `packages/frontend/src/components/launcher/AccountManager.tsx`: Remove imports of `isTauri, tauriInvoke` from `@/utils/tauri`. Import `isDesktop` from `@/utils/desktop`. Replace `isTauri()` → `isDesktop()`. Replace `tauriInvoke<MSAuthDeviceCode>('ms_auth_start')` → `window.electronAPI!.msAuthStart()`. Replace `tauriInvoke<MSAuthStatus>('ms_auth_poll')` → `window.electronAPI!.msAuthPoll()`. Replace `tauriInvoke('remove_account', { accountUuid: account.uuid })` → `window.electronAPI!.removeAccount(account.uuid)`. (2) `packages/frontend/src/components/launcher/LaunchButton.tsx`: Remove Tauri imports. Import `isDesktop` from `@/utils/desktop`. Replace `isTauri()` → `isDesktop()`. Replace `tauriInvoke('launch_game', { instanceId, accountId })` → `window.electronAPI!.launchGame(instanceId, accountId!)`. (3) Check `packages/frontend/src/pages/InstanceDetail.tsx` for any remaining Tauri references and update similarly. (4) Search the entire `packages/frontend/src/` directory for any remaining `tauriInvoke` or `isTauri` references and update them. | Restrictions: Use `window.electronAPI!` (non-null assertion) inside `isDesktop()` guards — the type is optional but we've confirmed it exists. Do NOT change component behavior or UI — only the IPC transport. Do NOT modify the API client (that was task 7). Preserve all error handling patterns. | Success: Zero remaining references to `tauriInvoke`, `isTauri`, `__TAURI_INTERNALS__`, or `@tauri-apps/api` in `packages/frontend/src/`. All components compile without TypeScript errors. Auth flow and game launch work identically via Electron IPC. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._

- [x] 9. Remove Tauri package and clean up workspace
  - Files: `packages/desktop/` (delete entire directory), `package.json` (root, modify), `.github/workflows/build-desktop.yml` (delete if exists), `plans/EPIC-1-tauri-desktop.md` (delete), `packages/frontend/package.json` (modify if needed)
  - Delete `packages/desktop/` entirely (Rust source, Cargo files, Tauri config, icons, scripts)
  - Remove `packages/desktop` from root `package.json` workspaces array
  - Remove `dev:desktop` and `build:desktop` scripts from root `package.json`
  - Remove any `@tauri-apps/*` dependencies from frontend package.json
  - Delete Tauri CI workflow if present
  - Purpose: Clean removal of all Rust/Tauri artifacts from the repository
  - _Leverage: `package.json` (root), `.github/workflows/`, `plans/`_
  - _Requirements: REQ-5_
  - _Prompt: Implement the task for spec electron-migration, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: DevOps/Build Engineer with expertise in monorepo workspace management | Task: Remove all Tauri/Rust code from the repository. (1) Read root `package.json` to see current workspaces and scripts. (2) Delete `packages/desktop/` directory entirely (use `rm -rf`). (3) Update root `package.json`: remove `packages/desktop` (or `@mc-server-manager/desktop`) from the workspaces array, remove `dev:desktop` and `build:desktop` scripts. (4) Check `packages/frontend/package.json` for any `@tauri-apps/api`, `@tauri-apps/plugin-shell`, `@tauri-apps/plugin-process`, or `@tauri-apps/cli` dependencies — remove them. (5) Check `.github/workflows/` for `build-desktop.yml` — delete if it exists. (6) Check `plans/` for `EPIC-1-tauri-desktop.md` — delete it. (7) Search entire repo for any remaining references to `tauri`, `src-tauri`, `Cargo.toml` in config files and clean them up. (8) Run `npm install` to update the lockfile after workspace removal. | Restrictions: Do NOT delete `packages/electron/` — that's the keeper. Do NOT modify any source code in backend/frontend/shared (those were updated in prior tasks). Do NOT delete spec files in `.spec-workflow/specs/tauri-desktop-migration/` — those are historical records. Be careful not to delete any non-Tauri workflows in `.github/workflows/`. | Success: `packages/desktop/` is gone, no Rust/Cargo files remain in repo, root package.json has no desktop workspace or scripts, no `@tauri-apps/*` deps anywhere, `npm install` succeeds, `npm run build` succeeds (shared + backend + frontend). Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._

- [x] 10. Verify parity and update existing specs
  - Files: Various spec files (modify references), `AGENTS.md` (modify if needed)
  - Verify all 10 parity checks from design doc (auth, Java, launch, tray, lifecycle)
  - Update `AGENTS.md` if it references Tauri/Rust
  - Update any pending spec task prompts that reference Tauri invoke patterns
  - Run `npm run build` to confirm clean compilation
  - Purpose: Ensure nothing is broken and documentation reflects the new reality
  - _Leverage: `.spec-workflow/specs/electron-migration/design.md` (parity table), `AGENTS.md`, all pending spec files_
  - _Requirements: REQ-6_
  - _Prompt: Implement the task for spec electron-migration, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Senior Developer with expertise in migration verification and documentation | Task: Final verification and documentation cleanup. (1) Run `npm run build` from project root — must succeed with zero errors. (2) Run `npm run build -w @mc-server-manager/electron` — must compile all new TypeScript files. (3) Search `AGENTS.md` for references to Tauri, Rust, `packages/desktop`, Cargo — update or remove them. Update the tech stack table if it mentions Tauri/Rust. Add Electron to the tech stack if not already there. (4) Search pending spec files (`friends-text-chat`, `mod-sync`, `shared-minecraft-servers`, `voice-communication`) for any Tauri/Rust references — update task prompts to reference Electron IPC instead. (5) Grep the entire `packages/` directory for any remaining string literals mentioning "tauri" (case-insensitive) — clean up any stragglers. (6) Verify the `.spec-workflow/specs/tauri-desktop-migration/tasks.md` is left intact (historical record, all [x] completed). (7) Document in a brief comment at the top of `packages/electron/src/auth.ts` that it was ported from the Rust implementation. | Restrictions: Do NOT modify completed spec task prompts in `tauri-desktop-migration` — they're historical. Do NOT delete the tauri-desktop-migration spec directory. Do NOT make functional code changes — this is verification and docs only. If build fails, investigate and fix (likely a missed import update). | Success: `npm run build` passes, zero references to Tauri/Rust in active code or pending specs, AGENTS.md accurately reflects Electron-only architecture, all historical spec records preserved. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._

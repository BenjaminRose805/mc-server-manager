{
  "id": "snapshot_1770855350346_h230ht1uz",
  "approvalId": "approval_1770855350337_deixr6j6w",
  "approvalTitle": "EPIC-5: Multi-User Foundation â€” Tasks Document",
  "version": 1,
  "timestamp": "2026-02-12T00:15:50.346Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document -- Multi-User Foundation\n\n- [ ] 1. Add shared auth types to shared package\n  - Files: `shared/src/index.ts` (modify)\n  - Add types: `UserRole`, `User`, `Session`, `Invitation`, `ServerPermission`, `JWTPayload`, `SetupRequest`, `RegisterRequest`, `LoginRequest`, `AuthResponse`, `RefreshResponse`, `AuthenticatedRequest`\n  - Purpose: Foundation types for the entire multi-user system\n  - _Leverage: `shared/src/index.ts` for existing type patterns, `.spec-workflow/specs/multi-user-foundation/design.md` Data Models section_\n  - _Requirements: REQ-1, REQ-2, REQ-3, REQ-5, REQ-6_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: TypeScript Developer with expertise in shared type definitions for monorepo packages | Task: Read `shared/src/index.ts` to understand existing type patterns and exports. Add all auth-related types from `.spec-workflow/specs/multi-user-foundation/design.md` Data Models section: (1) `UserRole` type alias: `'owner' | 'admin' | 'member'`. (2) `User` interface with fields: id, username, displayName, avatarUrl, role, isActive, createdAt, updatedAt, lastLoginAt. (3) `Session` interface: id, userId, deviceInfo, ipAddress, expiresAt, createdAt, lastUsedAt. (4) `Invitation` interface: id, code, createdBy, maxUses, uses, role, expiresAt, createdAt. (5) `ServerPermission` interface: id, serverId, userId, canView, canStart, canConsole, canEdit, createdAt. (6) `JWTPayload` interface: sub, username, role, iat, exp. (7) Request/response types: `SetupRequest`, `RegisterRequest`, `LoginRequest`, `AuthResponse`, `RefreshResponse`. (8) `AuthenticatedRequest` interface: `{ user: { id: string, username: string, role: UserRole } }`. Ensure all types are exported. | Restrictions: Do NOT remove or rename any existing types or exports. Do NOT add implementation code. Follow existing naming and style conventions in the file. | Success: All types compile, all are exported, existing types unchanged, `npm run build -w shared` succeeds._\n\n- [ ] 2. Create database migration for multi-user tables\n  - Files: `packages/backend/migrations/006_multi_user.sql` (new)\n  - Create tables: `users`, `sessions`, `invitations`, `server_permissions`, `login_attempts`\n  - Add all indexes as defined in design\n  - Purpose: Database schema for the entire auth system\n  - _Leverage: `packages/backend/migrations/` for existing migration patterns (001-005), `.spec-workflow/specs/multi-user-foundation/design.md` Data Models section, `plans/EPIC-5-multi-user.md` Database Schema section_\n  - _Requirements: REQ-1, REQ-2, REQ-3, REQ-4, REQ-5, REQ-6_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Database Engineer with expertise in SQLite schema design and migrations | Task: Read existing migrations in `packages/backend/migrations/` to confirm the next number is 006. Create `006_multi_user.sql` with these tables: (1) `users` table: id TEXT PK (nanoid), username TEXT NOT NULL UNIQUE COLLATE NOCASE, display_name TEXT NOT NULL, avatar_url TEXT, password_hash TEXT NOT NULL, role TEXT NOT NULL DEFAULT 'member', is_active INTEGER NOT NULL DEFAULT 1, created_at TEXT, updated_at TEXT, last_login_at TEXT. Add indexes on username and role. (2) `sessions` table: id TEXT PK, user_id TEXT NOT NULL FK to users(id) ON DELETE CASCADE, refresh_token_hash TEXT NOT NULL UNIQUE, device_info TEXT, ip_address TEXT, expires_at TEXT NOT NULL, created_at TEXT, last_used_at TEXT. Add indexes on user_id, token_hash, expires_at. (3) `invitations` table: id TEXT PK, code TEXT NOT NULL UNIQUE, created_by TEXT NOT NULL FK to users(id) ON DELETE CASCADE, max_uses INTEGER DEFAULT 1, uses INTEGER DEFAULT 0, role TEXT DEFAULT 'member', expires_at TEXT, created_at TEXT. Add indexes on code and created_by. (4) `server_permissions` table: id TEXT PK, server_id TEXT NOT NULL FK to servers(id) ON DELETE CASCADE, user_id TEXT NOT NULL FK to users(id) ON DELETE CASCADE, can_view INTEGER DEFAULT 1, can_start INTEGER DEFAULT 0, can_console INTEGER DEFAULT 0, can_edit INTEGER DEFAULT 0, created_at TEXT, UNIQUE(server_id, user_id). Add indexes on server_id, user_id. (5) `login_attempts` table: id INTEGER PK AUTOINCREMENT, username TEXT NOT NULL, ip_address TEXT NOT NULL, success INTEGER NOT NULL, attempted_at TEXT. Add indexes on username, ip_address, attempted_at. Use `DEFAULT (datetime('now'))` for timestamp defaults. Reference `plans/EPIC-5-multi-user.md` Database Schema. | Restrictions: Do NOT modify existing migration files. Do NOT add data inserts (settings defaults are handled by the application). Ensure all FK references point to existing tables (`servers` table exists from migration 001). | Success: SQL is syntactically valid, all tables created with correct column types and constraints, indexes created, foreign keys reference existing tables._\n\n- [ ] 3. Add UnauthorizedError and ForbiddenError to error utilities\n  - Files: `packages/backend/src/utils/errors.ts` (modify)\n  - Add `UnauthorizedError` (HTTP 401) and `ForbiddenError` (HTTP 403) extending AppError\n  - Purpose: Auth-specific error classes for middleware and routes\n  - _Leverage: `packages/backend/src/utils/errors.ts` for existing error class patterns_\n  - _Requirements: REQ-3, REQ-5, REQ-6_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer | Task: Read `packages/backend/src/utils/errors.ts` to understand the existing error class hierarchy (AppError, NotFoundError, ConflictError, etc.). Add two new error classes: (1) `UnauthorizedError` extending AppError with default statusCode 401 and default message 'Authentication required'. (2) `ForbiddenError` extending AppError with default statusCode 403 and default message 'Insufficient permissions'. Follow the exact same pattern as existing error classes. Export both. | Restrictions: Do NOT modify existing error classes. Follow the exact same constructor pattern. | Success: Both classes compile, extend AppError correctly, are exported, existing errors unchanged._\n\n- [ ] 4. Implement password hashing service\n  - Files: `packages/backend/src/services/auth.ts` (new)\n  - Implement `hashPassword(password)` and `verifyPassword(hash, password)` using argon2id\n  - Configure argon2 options: memoryCost 65536, timeCost 3, parallelism 4\n  - Purpose: Secure password hashing for user registration and login\n  - _Leverage: `plans/EPIC-5-multi-user.md` Password Hashing section_\n  - _Requirements: REQ-1, REQ-3_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Security Engineer with expertise in password hashing and cryptography | Task: Create `packages/backend/src/services/auth.ts`. Install `argon2` package (`npm install argon2 -w backend`). Implement: (1) `hashPassword(password: string): Promise<string>` using argon2id with options: memoryCost 65536 (64MB), timeCost 3, parallelism 4. (2) `verifyPassword(hash: string, password: string): Promise<boolean>` wrapping argon2.verify with try/catch returning false on error. Export both functions. Reference `plans/EPIC-5-multi-user.md` Password Hashing section. | Restrictions: Use argon2id specifically (NOT argon2i or argon2d). Do NOT store or log passwords. Do NOT catch errors silently in hashPassword (only in verifyPassword). Use `.js` extension in imports. | Success: Functions compile, argon2 package installed, hash/verify roundtrip works, argon2id mode used._\n\n- [ ] 5. Implement JWT service\n  - Files: `packages/backend/src/services/jwt.ts` (new)\n  - Implement `generateAccessToken(user)`, `verifyAccessToken(token)`, `getOrCreateJWTSecret()`\n  - JWT secret auto-generated (64 bytes random) and stored in settings table on first use\n  - Purpose: Stateless access token generation and verification\n  - _Leverage: `plans/EPIC-5-multi-user.md` JWT Token Generation section, settings model_\n  - _Requirements: REQ-1, REQ-3, REQ-9_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Security Engineer with expertise in JWT and token-based authentication | Task: Install `jsonwebtoken` and `@types/jsonwebtoken` (`npm install jsonwebtoken -w backend && npm install -D @types/jsonwebtoken -w backend`). Create `packages/backend/src/services/jwt.ts`. Implement: (1) `getOrCreateJWTSecret(): string` -- check settings table for key 'jwt_secret'. If found, return it. If not, generate 64 bytes of random data via `crypto.randomBytes(64).toString('hex')`, store in settings table, return it. Cache the secret in a module-level variable so DB is only queried once. (2) `generateAccessToken(user: { id: string, username: string, role: UserRole }): string` -- create JWT with payload `{ sub: user.id, username: user.username, role: user.role }`, sign with HS256, expiry 15 minutes. (3) `verifyAccessToken(token: string): JWTPayload | null` -- verify and return payload, or null if invalid/expired. Import types from `@mc-server-manager/shared`. Find how the settings table is accessed (check existing models or the database module) and use the same pattern. Reference `plans/EPIC-5-multi-user.md` JWT Token Generation. | Restrictions: Use HS256 algorithm only. Secret must be minimum 64 bytes. Do NOT hardcode secrets. Do NOT log tokens. Use `.js` extension in imports. | Success: JWT generation and verification roundtrip works, secret is persisted in settings table, expired tokens return null._\n\n- [ ] 6. Implement session/refresh token service\n  - Files: `packages/backend/src/services/session.ts` (new)\n  - Implement refresh token generation, hashing (SHA-256), session CRUD, expiry cleanup\n  - Functions: `generateRefreshToken()`, `hashRefreshToken()`, `createSession()`, `validateRefreshToken()`, `revokeSession()`, `revokeAllUserSessions()`, `cleanupExpiredSessions()`\n  - Purpose: Refresh token lifecycle management\n  - _Leverage: `plans/EPIC-5-multi-user.md` Refresh Token Management section_\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Developer with expertise in session management and token security | Task: Create `packages/backend/src/services/session.ts`. Implement: (1) `generateRefreshToken(): string` -- 32 bytes random, base64url encoded. (2) `hashRefreshToken(token: string): string` -- SHA-256 hash as hex. (3) `createSession(userId, refreshToken, deviceInfo, ipAddress): Session` -- insert into sessions table with hashed token, 30-day expiry, return session record. Use nanoid for session ID. (4) `validateRefreshToken(token: string): Session | null` -- hash token, lookup in sessions where not expired, update last_used_at, return session or null. (5) `revokeSession(sessionId: string): void` -- delete from sessions. (6) `revokeAllUserSessions(userId: string): number` -- delete all sessions for user, return count. (7) `cleanupExpiredSessions(): number` -- delete expired sessions, return count. Use the database access pattern found in existing models. Reference `plans/EPIC-5-multi-user.md` Refresh Token Management. | Restrictions: NEVER store plaintext refresh tokens. Always hash before DB operations. Use crypto from Node built-in, not external packages. Use `.js` extension in imports. | Success: All functions compile, refresh tokens are always hashed before storage, session CRUD works, cleanup removes expired records._\n\n- [ ] 7. Implement brute force protection service\n  - Files: `packages/backend/src/services/brute-force.ts` (new)\n  - Track failed login attempts per username and IP, enforce lockout after 5 failures in 15 minutes\n  - Functions: `recordLoginAttempt()`, `isLockedOut()`, `clearLoginAttempts()`, `cleanupOldAttempts()`\n  - Purpose: Prevent password guessing attacks\n  - _Leverage: `plans/EPIC-5-multi-user.md` Brute Force Protection section_\n  - _Requirements: REQ-4_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Security Engineer | Task: Create `packages/backend/src/services/brute-force.ts`. Implement: (1) `recordLoginAttempt(username: string, ipAddress: string, success: boolean): void` -- insert into login_attempts table. (2) `isLockedOut(username: string, ipAddress: string): boolean` -- count failed attempts (success=0) for the given username OR IP within the last 15 minutes. Return true if count is 5 or more. (3) `clearLoginAttempts(username: string): void` -- delete all attempts for username (called on successful login). (4) `cleanupOldAttempts(): number` -- delete records older than 7 days, return count. Use database access pattern from existing models. Reference `plans/EPIC-5-multi-user.md` Brute Force Protection. | Restrictions: Check both username AND IP (OR logic -- lockout triggered by either). Use datetime comparison in SQLite. Do NOT expose attempt details to the client. Use `.js` extension in imports. | Success: Lockout triggers after 5 failures, successful login clears attempts, cleanup removes old records._\n\n- [ ] 8. Create user database model\n  - Files: `packages/backend/src/models/user.ts` (new)\n  - CRUD operations for users table: create, getById, getByUsername, list, updateRole, deactivate, updateProfile, updateLastLogin, countUsers\n  - Purpose: Data access layer for user management\n  - _Leverage: Existing model files in `packages/backend/src/models/` for patterns_\n  - _Requirements: REQ-1, REQ-2, REQ-5_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in SQLite data access layers | Task: Read existing model files in `packages/backend/src/models/` (e.g., server model) to understand the pattern (prepared statements, database access). Create `packages/backend/src/models/user.ts` with functions: (1) `createUser(data: { id, username, displayName, passwordHash, role }): User` -- INSERT into users. (2) `getUserById(id: string): User | null`. (3) `getUserByUsername(username: string): User | null` (case-insensitive via COLLATE NOCASE). (4) `listUsers(filters?: { role?, active? }): User[]`. (5) `updateUserRole(id: string, role: UserRole): void`. (6) `deactivateUser(id: string): void` -- set is_active=0. (7) `updateUserProfile(id: string, data: { displayName?, avatarUrl?, passwordHash? }): void`. (8) `updateLastLogin(id: string): void`. (9) `countUsers(): number`. Map snake_case DB columns to camelCase TypeScript interfaces. | Restrictions: Use prepared statements. Do NOT use an ORM. Follow exact pattern of existing models. Do NOT return password_hash in list queries. Use `.js` extension in imports. | Success: All CRUD operations work, column mapping correct, password_hash excluded from list results._\n\n- [ ] 9. Create invitation and server-permission database models\n  - Files: `packages/backend/src/models/invitation.ts` (new), `packages/backend/src/models/server-permission.ts` (new)\n  - Invitation model: create, getByCode, list, delete, incrementUses\n  - ServerPermission model: getForServer, getForUser, upsert, delete, getPermission\n  - Purpose: Data access for invitations and per-server permissions\n  - _Leverage: Existing model patterns, `plans/EPIC-5-multi-user.md` API Design sections_\n  - _Requirements: REQ-2, REQ-6_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in SQLite models | Task: Create two model files following existing patterns from `packages/backend/src/models/`. (A) `invitation.ts`: (1) `createInvitation(data: { id, code, createdBy, maxUses, role, expiresAt }): Invitation`. (2) `getInvitationByCode(code: string): Invitation | null` -- also check not expired and uses less than maxUses (or maxUses=0 for unlimited). (3) `listInvitations(createdBy?: string): Invitation[]`. (4) `deleteInvitation(id: string): void`. (5) `incrementInvitationUses(id: string): void` -- UPDATE uses = uses + 1. (B) `server-permission.ts`: (1) `getPermissionsForServer(serverId: string): (ServerPermission & { username: string, displayName: string })[]` -- JOIN with users table. (2) `getPermission(serverId: string, userId: string): ServerPermission | null`. (3) `upsertPermission(data: { id, serverId, userId, canView, canStart, canConsole, canEdit }): ServerPermission` -- INSERT OR REPLACE. (4) `deletePermission(serverId: string, userId: string): void`. Map snake_case to camelCase. | Restrictions: Invitation code validation (expired, exhausted) should be in the model query WHERE clause for atomicity. Use prepared statements. Use `.js` extension in imports. | Success: All model functions compile and work, invitation validation is atomic, permission upsert handles both insert and update._\n\n- [ ] 10. Implement auth middleware\n  - Files: `packages/backend/src/middleware/auth.ts` (new)\n  - Middleware functions: `requireAuth`, `requireRole(...roles)`, `requireOwner`, `requireAdminOrOwner`, `requireServerPermission(permission)`\n  - Extend Express Request type with `user` field\n  - Purpose: Composable auth middleware for route protection\n  - _Leverage: `plans/EPIC-5-multi-user.md` Auth Middleware section, existing middleware patterns_\n  - _Requirements: REQ-3, REQ-5, REQ-6_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in Express middleware and TypeScript | Task: Create `packages/backend/src/middleware/auth.ts`. (1) Extend Express Request type globally with optional `user: { id: string, username: string, role: UserRole }`. (2) `requireAuth(req, res, next)` -- extract Bearer token from Authorization header, call `verifyAccessToken()`, if valid attach user to req.user and call next(), if invalid throw UnauthorizedError. (3) `requireRole(...roles: UserRole[])` -- returns middleware that checks `req.user.role` is in the roles array, throws ForbiddenError if not. (4) `requireOwner` -- shorthand for requireRole('owner'). (5) `requireAdminOrOwner` -- shorthand for requireRole('owner', 'admin'). (6) `requireServerPermission(permission: 'can_view' | 'can_start' | 'can_console' | 'can_edit')` -- returns middleware that checks: if user is owner/admin, allow. Otherwise lookup server_permissions for req.params.serverId and req.user.id, check the specific permission flag. Throw ForbiddenError if denied. Import JWT service and server-permission model. Reference `plans/EPIC-5-multi-user.md` Auth Middleware. | Restrictions: Do NOT use `as any` for type casting. Use proper Express middleware signatures. Error classes come from `utils/errors.ts`. Use `.js` extension in imports. | Success: All middleware functions compile, requireAuth extracts JWT correctly, role checks work, server permission checks bypass for owner/admin._\n\n- [ ] 11. Implement auth routes (setup, register, login, refresh, logout)\n  - Files: `packages/backend/src/routes/auth.ts` (new)\n  - Endpoints: POST `/api/auth/setup`, `/api/auth/register`, `/api/auth/login`, `/api/auth/refresh`, `/api/auth/logout`, `/api/auth/logout-all`\n  - Zod validation for all request bodies\n  - Purpose: Core authentication endpoints\n  - _Leverage: Existing route files for patterns, `plans/EPIC-5-multi-user.md` Authentication Endpoints section_\n  - _Requirements: REQ-1, REQ-2, REQ-3, REQ-4_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in Express routing and Zod validation | Task: Read existing route files in `packages/backend/src/routes/` for patterns (Zod schemas, error handling, router setup). Create `packages/backend/src/routes/auth.ts` with these endpoints: (1) `POST /setup` -- check no users exist (countUsers()===0, else 409 Conflict), validate body (username 3-20 alphanum+underscore, password min 8 chars, displayName 1-50 chars), hash password, create user with role=owner, create session, return AuthResponse. (2) `POST /register` -- validate body (inviteCode, username, password, displayName), lookup invite by code (validate not expired/exhausted), check username not taken (409), hash password, create user with role from invitation, increment invitation uses, create session, return AuthResponse. (3) `POST /login` -- check brute force lockout (429 if locked), validate body, lookup user by username (401 generic if not found), verify password (401 generic if wrong), record login attempt, clear attempts on success, create session, return AuthResponse with user (excluding passwordHash). (4) `POST /refresh` -- validate body (refreshToken), validate refresh token via session service, check user still exists and active, generate new access token, return RefreshResponse. (5) `POST /logout` -- validate body (refreshToken), hash and find session, delete session. Always return success (idempotent). (6) `POST /logout-all` -- requireAuth middleware, revoke all sessions for req.user.id, return revokedCount. Use Zod for ALL request validation. Return generic error messages on login failure (no user enumeration). | Restrictions: NEVER reveal whether username exists in login error (use generic \"Invalid credentials\"). Use Zod schemas before processing. Include device info (user-agent) and IP address when creating sessions. Do NOT log passwords or tokens. Use `.js` extension in imports. | Success: All 6 endpoints compile, Zod validates inputs, setup creates owner, register uses invite, login checks brute force, refresh works, logout is idempotent._\n\n- [ ] 12. Implement user management routes\n  - Files: `packages/backend/src/routes/users.ts` (new)\n  - Endpoints: GET `/api/users/me`, PATCH `/api/users/me`, GET `/api/users`, GET `/api/users/:id`, PATCH `/api/users/:id/role`, DELETE `/api/users/:id`\n  - Purpose: User profile and admin user management\n  - _Leverage: Existing route patterns, `plans/EPIC-5-multi-user.md` User Management Endpoints_\n  - _Requirements: REQ-5, REQ-10_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in RESTful API design | Task: Create `packages/backend/src/routes/users.ts`. All routes require `requireAuth` middleware. (1) `GET /me` -- return current user profile from req.user.id (exclude passwordHash). (2) `PATCH /me` -- validate body (optional: displayName, avatarUrl, currentPassword, newPassword). If changing password, verify currentPassword first, then hash newPassword. Update profile. (3) `GET /` -- requireAdminOrOwner. List all users with optional role/active query filters. Exclude passwordHash from results. (4) `GET /:id` -- requireAdminOrOwner. Get user by ID with their active sessions. (5) `PATCH /:id/role` -- requireOwner. Validate body (role: 'admin' or 'member'). Cannot change owner's role (400). Update role. (6) `DELETE /:id` -- requireOwner. Cannot delete owner (403). Deactivate user, revoke all their sessions. Use Zod for request validation. | Restrictions: NEVER expose password_hash in any response. Password change requires current password verification. Owner cannot be deleted or demoted. Use `.js` extension in imports. | Success: All endpoints compile, auth middleware applied, owner protection works, password change requires current password._\n\n- [ ] 13. Implement invitation routes\n  - Files: `packages/backend/src/routes/invitations.ts` (new)\n  - Endpoints: POST `/api/invitations`, GET `/api/invitations`, DELETE `/api/invitations/:id`\n  - Purpose: Invite code CRUD for owner/admin\n  - _Leverage: Existing route patterns, `plans/EPIC-5-multi-user.md` Invitation Endpoints_\n  - _Requirements: REQ-2_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer | Task: Create `packages/backend/src/routes/invitations.ts`. All routes require `requireAuth` and `requireAdminOrOwner`. (1) `POST /` -- validate body (optional: maxUses default 1, expiresIn as duration string like '7d'/'24h'/'30m', role default 'member' must be 'admin' or 'member'). Generate 8-char code via nanoid. Parse expiresIn to compute expiresAt datetime. Create invitation record. Return invitation with a generated link: `https://{host}/register?code={code}`. (2) `GET /` -- list all invitations. Optional `active=true` query filter to show only non-expired, non-exhausted invitations. (3) `DELETE /:id` -- delete invitation by ID. Return success. Use Zod for validation. Generate nanoid for invitation ID and code (use custom alphabet for code: alphanumeric). | Restrictions: Duration parsing must handle 'd' (days), 'h' (hours), 'm' (minutes). Codes must be URL-safe. Use `.js` extension in imports. | Success: All endpoints compile, code generation works, duration parsing correct, active filter works._\n\n- [ ] 14. Add server permission routes to existing server routes\n  - Files: `packages/backend/src/routes/servers.ts` (modify) or new file mounted alongside\n  - Endpoints: GET `/api/servers/:serverId/permissions`, PUT `/api/servers/:serverId/permissions/:userId`, DELETE `/api/servers/:serverId/permissions/:userId`\n  - Add `requireServerPermission` middleware to existing server endpoints\n  - Purpose: Granular per-server access control\n  - _Leverage: `packages/backend/src/routes/servers.ts` (existing), server-permission model_\n  - _Requirements: REQ-6_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in Express routing and authorization | Task: Read `packages/backend/src/routes/servers.ts`. (A) Add permission management endpoints (either in this file or a new file mounted under `/api/servers`): (1) `GET /:serverId/permissions` -- requireAdminOrOwner. Return all user permissions for this server (JOIN with users for username/displayName). (2) `PUT /:serverId/permissions/:userId` -- requireAdminOrOwner. Validate body (canView, canStart, canConsole, canEdit as booleans). Upsert permission record. (3) `DELETE /:serverId/permissions/:userId` -- requireAdminOrOwner. Delete permission record. (B) Add `requireServerPermission` middleware to existing server routes: GET server detail needs 'can_view', POST start/stop/restart/kill needs 'can_start', POST command needs 'can_console', PATCH server / PUT properties needs 'can_edit'. GET server list must filter by visible servers for members. Reference `plans/EPIC-5-multi-user.md` Server Permission Endpoints and Permission System. | Restrictions: Owner/Admin always bypass permission checks (handled in middleware). Do NOT break existing route paths or response formats. The server list endpoint must filter results for members (only show servers with can_view). Use `.js` extension in imports. | Success: Permission CRUD works, existing server routes enforce permissions, members see only permitted servers, owner/admin see all._\n\n- [ ] 15. Implement security middleware (rate limiting, CORS, Helmet)\n  - Files: `packages/backend/src/middleware/rate-limit.ts` (new), `packages/backend/src/middleware/cors-config.ts` (new), `packages/backend/src/middleware/security.ts` (new)\n  - Rate limiting: 100 req/min general, 5 req/15min auth\n  - CORS: Allow Tauri origin + custom domain\n  - Helmet: CSP, HSTS, referrer policy\n  - Purpose: Security hardening for network-facing deployment\n  - _Leverage: `plans/EPIC-5-multi-user.md` Rate Limiting, CORS, Security Headers sections_\n  - _Requirements: REQ-9_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Security Engineer with expertise in Express security middleware | Task: Install packages: `npm install express-rate-limit helmet cors -w backend && npm install -D @types/cors -w backend`. Create three middleware files: (1) `rate-limit.ts` -- export `authRateLimit` (5 req per 15 min, message 'Too many authentication attempts'), export `apiRateLimit` (100 req per 1 min, skip localhost in development). (2) `cors-config.ts` -- export cors options: in development allow all origins, in production allow only 'tauri://localhost', 'https://tauri.localhost', and CUSTOM_DOMAIN env var if set. Include credentials, methods (GET/POST/PUT/PATCH/DELETE), and allowed headers (Content-Type, Authorization). (3) `security.ts` -- export Helmet config with CSP (self for default/script, self+ws/wss for connect, self+data+modrinth CDN for img, self+unsafe-inline for style), HSTS (1 year, includeSubDomains, preload), strict-origin-when-cross-origin referrer policy. Reference `plans/EPIC-5-multi-user.md` sections on Rate Limiting, CORS, Security Headers. | Restrictions: NEVER use `cors({ origin: '*' })` in production. Do NOT disable Helmet in development. Use `.js` extension in imports. | Success: All three middleware files compile, rate limits configured correctly, CORS whitelist includes Tauri origins, Helmet sets proper headers._\n\n- [ ] 16. Implement TLS/HTTPS service\n  - Files: `packages/backend/src/services/tls.ts` (new)\n  - Support 4 modes: letsencrypt (ACME HTTP-01), custom cert, self-signed, disabled\n  - Auto-renewal for Let's Encrypt (30 days before expiry)\n  - Purpose: Encrypted connections for network-facing deployment\n  - _Leverage: `plans/EPIC-5-multi-user.md` TLS/HTTPS Setup section_\n  - _Requirements: REQ-7_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Developer with expertise in TLS/SSL, ACME protocol, and certificate management | Task: Install packages: `npm install @root/acme node-forge -w backend && npm install -D @types/node-forge -w backend`. Create `packages/backend/src/services/tls.ts`. Define `TLSConfig` interface: `{ mode: 'letsencrypt' | 'custom' | 'self-signed' | 'disabled', domain?: string, email?: string, certPath?: string, keyPath?: string }`. Implement `setupTLS(config: TLSConfig, dataDir: string): Promise<{cert: string, key: string} | null>` that delegates based on mode: (1) letsencrypt -- use @root/acme to provision cert via HTTP-01 challenge. Store certs in `{dataDir}/certs/{domain}/`. Check for existing valid cert first. Renew if expiring within 30 days. (2) custom -- read cert and key from provided file paths. (3) self-signed -- generate 2048-bit RSA cert via node-forge with CN=localhost, 1 year validity. Store in `{dataDir}/certs/self-signed/`. (4) disabled -- return null. Add helper `isCertExpiringSoon(certPem)` checking if less than 30 days remain. Reference `plans/EPIC-5-multi-user.md` TLS/HTTPS Setup. | Restrictions: ACME challenge files must be served by Express (a separate ACME route handles this). Self-signed certs should warn in logs. Do NOT block server startup if TLS fails -- fall back to HTTP. Use `.js` extension in imports. | Success: All 4 modes compile, Let's Encrypt flow uses ACME client, custom certs load from disk, self-signed generates valid cert, disabled returns null._\n\n- [ ] 17. Implement UPnP port forwarding service\n  - Files: `packages/backend/src/services/upnp.ts` (new)\n  - Automatic port forwarding via UPnP, with graceful fallback\n  - Purpose: Simplify network setup for hosts\n  - _Leverage: `plans/EPIC-5-multi-user.md` Network Configuration section_\n  - _Requirements: REQ-8_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Developer with expertise in network protocols | Task: Install package: `npm install nat-upnp -w backend`. Create `packages/backend/src/services/upnp.ts`. Implement: (1) `setupPortForwarding(port: number): Promise<boolean>` -- create UPnP client, attempt port mapping (public=port, private=port, ttl=0, description='MC Server Manager'). Log success or warn on failure. Return boolean. (2) `removePortForwarding(port: number): Promise<void>` -- attempt to remove mapping, warn on failure. Use Pino logger for all logging. Reference `plans/EPIC-5-multi-user.md` Network Configuration. | Restrictions: UPnP is best-effort. NEVER throw on failure. Always catch and log. Do NOT block server startup on UPnP failure. Use `.js` extension in imports. | Success: Functions compile, port forwarding attempts work on supported routers, failures are logged gracefully._\n\n- [ ] 18. Create ACME challenge route\n  - Files: `packages/backend/src/routes/acme.ts` (new)\n  - Serve ACME HTTP-01 challenge tokens at `/.well-known/acme-challenge/:token`\n  - Purpose: Let's Encrypt certificate validation\n  - _Leverage: `plans/EPIC-5-multi-user.md` ACME Challenge Route section_\n  - _Requirements: REQ-7_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer | Task: Create `packages/backend/src/routes/acme.ts`. Implement a single route: `GET /.well-known/acme-challenge/:token`. Read the challenge file from `{dataDir}/acme-challenge/{token}`. Return as text/plain. Return 404 if file not found. Export the router. This route must be mounted BEFORE any auth middleware (ACME challenges must be publicly accessible). Reference `plans/EPIC-5-multi-user.md` ACME Challenge Route. | Restrictions: No auth on this route. Validate token parameter to prevent path traversal (reject tokens containing '/' or '..'). Use `.js` extension in imports. | Success: Route compiles, serves challenge files, returns 404 for missing, path traversal prevented._\n\n- [ ] 19. Wire up backend -- mount routes, middleware, HTTPS server, periodic cleanup\n  - Files: `packages/backend/src/app.ts` (modify), `packages/backend/src/index.ts` (modify), `packages/backend/src/config.ts` (modify)\n  - Mount all new routes and middleware in correct order\n  - Update server startup to support HTTPS\n  - Add periodic cleanup timer (sessions, login attempts)\n  - Update config with host, TLS, UPnP settings\n  - Purpose: Integrate all backend auth components\n  - _Leverage: Existing `app.ts`, `index.ts`, `config.ts` files_\n  - _Requirements: REQ-7, REQ-8, REQ-9_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in Express application architecture | Task: Read `packages/backend/src/app.ts`, `packages/backend/src/index.ts`, and `packages/backend/src/config.ts`. Make these changes: (A) `config.ts` -- add: `host` (from HOST env or '0.0.0.0'), TLS config fields (tls_mode, tls_domain, tls_email, tls_cert_path, tls_key_path from env vars), `upnpEnabled` (from UPNP_ENABLED env or false). (B) `app.ts` -- add middleware in order: (1) ACME challenge route (before everything), (2) Helmet security headers, (3) CORS, (4) API rate limiter on `/api`, (5) Auth rate limiter on `/api/auth`. Mount routes: `/api/auth` -> auth routes, `/api/users` -> user routes, `/api/invitations` -> invitation routes. Existing server routes keep their mount point but gain auth middleware. (C) `index.ts` -- import `setupTLS`. Load TLS config from settings/env. If TLS returns cert+key, create `https.createServer()`. Otherwise create `http.createServer()`. Attach WebSocket server to the HTTP/HTTPS server. Bind to `config.host` instead of localhost. Add `setInterval` for cleanup: every hour call `cleanupExpiredSessions()` and `cleanupOldAttempts()`. If UPnP enabled, call `setupPortForwarding()` on startup. (D) Handle graceful shutdown: on SIGINT/SIGTERM, call `removePortForwarding()` if UPnP was set up. | Restrictions: Do NOT break existing route mounting. Middleware order matters: ACME first, then security headers, CORS, rate limiters, then routes. Do NOT remove existing middleware or routes. Use `.js` extension in imports. | Success: Server starts with all middleware and routes, HTTPS works when TLS configured, cleanup runs hourly, UPnP attempted if enabled, existing functionality preserved._\n\n- [ ] 20. Add WebSocket authentication\n  - Files: WebSocket handler files (find in `packages/backend/src/`)\n  - Verify JWT on WebSocket connection upgrade\n  - Add permission checks to subscribe/command messages\n  - Purpose: Secure WebSocket connections\n  - _Leverage: `packages/backend/src/api/ws.ts` or equivalent WebSocket handler_\n  - _Requirements: REQ-3, REQ-6_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in WebSocket security | Task: Find the WebSocket handler file(s) in `packages/backend/src/` (likely `ws/` directory or a ws handler file). Read them to understand current WS architecture. Add authentication: (1) On connection upgrade, extract the access token from the URL query parameter (`?token=...`) or from the first message. Verify via `verifyAccessToken()`. If invalid, close the connection with code 4001 and reason 'Unauthorized'. Attach user info to the WebSocket connection object. (2) On 'subscribe' message, check if the user has `can_view` permission for the requested serverId (owner/admin bypass). Reject with error message if denied. (3) On 'command' message, check `can_console` permission for the serverId. Reject if denied. (4) Handle single-user mode: if no users exist in the database, skip all auth checks (backward compatibility). | Restrictions: Do NOT break existing WebSocket message format. Token can be passed as query param on connection URL OR in the protocol header. Do NOT use cookies for WS auth. Use `.js` extension in imports. | Success: WS connections require valid JWT, subscribe checks view permission, command checks console permission, single-user mode works without auth._\n\n- [ ] 21. Implement frontend auth API client\n  - Files: `packages/frontend/src/api/auth.ts` (new), `packages/frontend/src/api/users.ts` (new), `packages/frontend/src/api/invitations.ts` (new), `packages/frontend/src/api/client.ts` (modify)\n  - Auth API: setup, register, login, refresh, logout\n  - User/invitation API clients\n  - Modify main API client to inject Authorization header\n  - Purpose: Frontend API layer for all auth operations\n  - _Leverage: `packages/frontend/src/api/client.ts` for existing API patterns, `plans/EPIC-5-multi-user.md` Auth API Client section_\n  - _Requirements: REQ-10_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in API client design | Task: Read `packages/frontend/src/api/client.ts` to understand existing patterns (BASE_URL, fetch wrappers). (A) Create `auth.ts` with functions: `setupAccount(data: SetupRequest): Promise<AuthResponse>`, `register(data: RegisterRequest): Promise<AuthResponse>`, `login(data: LoginRequest): Promise<AuthResponse>`, `refreshAccessToken(refreshToken: string): Promise<RefreshResponse>`, `logout(refreshToken: string): Promise<void>`. Each wraps fetch with proper method, headers, body, error handling. (B) Create `users.ts`: `getCurrentUser()`, `updateProfile(data)`, `getUsers()`, `getUserById(id)`, `updateUserRole(id, role)`, `deleteUser(id)`. All include Authorization header. (C) Create `invitations.ts`: `createInvitation(data)`, `getInvitations()`, `deleteInvitation(id)`. All include Authorization header. (D) Modify `client.ts` to add a helper that injects `Authorization: Bearer {token}` from localStorage on all API calls. Add a 401 response interceptor that attempts token refresh before failing. Reference `plans/EPIC-5-multi-user.md` Auth API Client. | Restrictions: Store tokens in localStorage (Tauri secure storage is a future enhancement). The 401 interceptor must not loop infinitely (if refresh also returns 401, redirect to login). Do NOT modify existing API function signatures in client.ts (add new helpers alongside). | Success: All API functions compile, Authorization header injected automatically, 401 interceptor refreshes token, existing API functions still work._\n\n- [ ] 22. Implement AuthContext and token refresh\n  - Files: `packages/frontend/src/contexts/AuthContext.tsx` (new)\n  - React context providing auth state, automatic token refresh, logout\n  - Decode JWT payload for user info\n  - Purpose: App-wide auth state management\n  - _Leverage: `plans/EPIC-5-multi-user.md` Auth Context section_\n  - _Requirements: REQ-3, REQ-10_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in context providers and token management | Task: Create `packages/frontend/src/contexts/AuthContext.tsx`. (1) Define `AuthContextValue`: `{ user: User | null, accessToken: string | null, isAuthenticated: boolean, isLoading: boolean, login: (response: AuthResponse) => void, logout: () => void }`. (2) `AuthProvider` component: on mount, check localStorage for accessToken. Decode JWT payload (base64 decode the middle segment) to extract user info. Set up a timer to refresh the token 1 minute before expiry. If token is already expired on mount, attempt immediate refresh. On refresh failure, clear tokens and set user to null. `login` function stores tokens and sets user. `logout` function calls logout API, clears localStorage, sets user to null. (3) Export `useAuth()` hook that throws if used outside provider. (4) Handle the \"no users exist\" case: expose a way to check if setup is needed (could be a separate API call or derived from a 401 on /api/users/me). Reference `plans/EPIC-5-multi-user.md` Auth Context. | Restrictions: Do NOT use Zustand for auth state (use React Context as auth is cross-cutting). Token decode must handle malformed tokens gracefully. Do NOT store sensitive data in React state beyond what's in the JWT. | Success: Context provides auth state, auto-refresh works, logout clears everything, useAuth hook works._\n\n- [ ] 23. Create Setup, Login, and Register pages\n  - Files: `packages/frontend/src/pages/Setup.tsx` (new), `packages/frontend/src/pages/Login.tsx` (new), `packages/frontend/src/pages/Register.tsx` (new)\n  - Setup wizard: username, display name, password fields\n  - Login page: username, password with error handling\n  - Register page: invite code (from URL query), username, display name, password\n  - Purpose: User-facing auth UI\n  - _Leverage: Existing page patterns in `packages/frontend/src/pages/`, Tailwind styling, `plans/EPIC-5-multi-user.md` Frontend sections_\n  - _Requirements: REQ-1, REQ-2, REQ-3, REQ-10_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in form design and Tailwind CSS | Task: Read existing pages in `packages/frontend/src/pages/` for styling patterns (Tailwind classes, layout, color scheme). Create three pages: (1) `Setup.tsx` -- centered card layout (dark theme consistent with existing app). Title \"Welcome to MC Server Manager\". Subtitle about creating owner account. Form with username (3-20 chars, alphanumeric+underscore), display name (1-50 chars), password (min 8 chars) inputs. Submit calls `setupAccount()`, stores tokens via AuthContext login(), navigates to '/'. Show error on failure. (2) `Login.tsx` -- centered card. Title \"Login\". Username and password fields. Submit calls `login()`, stores tokens, navigates to '/'. Handle 429 (rate limit) with specific message. Generic error for bad credentials. (3) `Register.tsx` -- centered card. Title \"Join Community\". Read invite code from URL query param `code` (via useSearchParams). Show code field (pre-filled if from URL). Username, display name, password fields. Submit calls `register()`, stores tokens, navigates to '/'. Show specific errors for invalid/expired codes. All pages use Tailwind dark theme: bg-slate-900 background, bg-slate-800 cards, slate-700 inputs, blue-600 buttons. Reference `plans/EPIC-5-multi-user.md` Frontend sections. | Restrictions: Use default exports (React page convention). Do NOT add any auth check redirects here (ProtectedRoute handles that). Use sonner for toast notifications on errors. Match existing app styling exactly. | Success: All three pages render correctly, forms validate inputs, API calls work, tokens stored on success, errors displayed._\n\n- [ ] 24. Create Admin panel page\n  - Files: `packages/frontend/src/pages/Admin.tsx` (new)\n  - User list with role management, invitation list with create/delete\n  - Copy-to-clipboard for invite codes/links\n  - Purpose: Admin UI for user and invitation management\n  - _Leverage: Existing table/list patterns from server list, `plans/EPIC-5-multi-user.md` Admin Panel section_\n  - _Requirements: REQ-5, REQ-10_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in admin dashboards and Tailwind CSS | Task: Create `packages/frontend/src/pages/Admin.tsx`. Two sections: (A) Users section -- table with columns: Username, Display Name, Role, Status (active/inactive), Actions. Owner role shown as badge (non-editable). Other users have a role dropdown (admin/member) that calls updateUserRole on change. Delete button for non-owner users (with confirmation dialog) calls deleteUser. (B) Invitations section -- header with \"Create Invite\" button. Table with columns: Code (monospace font), Uses (current/max, show infinity symbol for unlimited), Role, Expires, Actions. Create button opens a simple form or directly creates with defaults (1 use, 7 day expiry, member role). Each row has copy-code button (copies to clipboard with toast confirmation) and delete button. Load data on mount via useEffect. Use Tailwind dark theme matching existing pages. Use lucide-react icons. Reference `plans/EPIC-5-multi-user.md` Admin Panel. | Restrictions: Only accessible by owner/admin (route guard handles this, but also check role in component). Use default export. Match existing table styling from other pages. Use sonner for toasts. | Success: User table loads and displays, role changes work, user deletion works, invite creation works, copy-to-clipboard works, table styling matches app._\n\n- [ ] 25. Create ProtectedRoute component and wire up routing\n  - Files: `packages/frontend/src/components/ProtectedRoute.tsx` (new), `packages/frontend/src/App.tsx` (modify), `packages/frontend/src/main.tsx` (modify)\n  - ProtectedRoute redirects to login if not authenticated\n  - Add AuthProvider wrapper\n  - Add routes for /setup, /login, /register, /admin\n  - Purpose: Route protection and app-level auth integration\n  - _Leverage: `packages/frontend/src/App.tsx` (existing routing), React Router patterns_\n  - _Requirements: REQ-10_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in React Router and auth patterns | Task: (1) Create `packages/frontend/src/components/ProtectedRoute.tsx` -- wraps children. Uses `useAuth()`. If `isLoading`, show a loading spinner. If not authenticated, redirect to `/login` via `<Navigate to=\"/login\" replace />`. If authenticated, render children. (2) Read `packages/frontend/src/App.tsx`. Add new routes: `/setup` -> Setup page, `/login` -> Login page, `/register` -> Register page, `/admin` -> Admin page (wrapped in ProtectedRoute + role check for admin/owner). Wrap all existing dashboard routes with ProtectedRoute. Add logic: if accessing '/' and no users exist (check via API or context), redirect to '/setup'. (3) Read `packages/frontend/src/main.tsx`. Wrap the app with `<AuthProvider>`. (4) Update the WebSocket client (`packages/frontend/src/api/ws.ts`) to include the access token in the connection URL as a query parameter (`?token={accessToken}`). | Restrictions: Do NOT remove or restructure existing routes. ProtectedRoute must handle the loading state (don't flash login page). Admin page must also check user role (not just auth). Use `.js` extension in imports where needed. | Success: Unauthenticated users redirected to login, authenticated users see dashboard, admin page restricted to owner/admin, setup page shows when no users exist, WebSocket passes token._\n\n- [ ] 26. Add backward compatibility for single-user mode\n  - Files: Multiple backend files (middleware, routes)\n  - When no users exist in the database, skip all auth checks\n  - Existing functionality works without login\n  - Purpose: Backward compatibility for users who don't need multi-user\n  - _Leverage: User model countUsers(), auth middleware_\n  - _Requirements: REQ-1 (AC-5)_\n  - _Prompt: Implement the task for spec multi-user-foundation, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer | Task: Implement single-user mode bypass. When no users exist in the database (countUsers() === 0), the app should work exactly as before without requiring authentication. (1) In `requireAuth` middleware: check if countUsers() === 0. If so, skip JWT verification and call next() without setting req.user. Cache the count (check once on startup and after user creation, not on every request). (2) In `requireServerPermission` middleware: if req.user is undefined (single-user mode), allow all permissions. (3) In WebSocket auth: if no users exist, skip token verification. (4) In frontend: add an API endpoint or use an existing one to check if setup is needed (GET `/api/auth/status` returning `{ setupRequired: boolean, multiUser: boolean }`). AuthContext uses this on mount to determine whether to redirect to setup or skip auth entirely. | Restrictions: Do NOT create a permanent \"skip auth\" backdoor. The single-user bypass must ONLY work when countUsers() === 0. Once an owner account is created, all auth is enforced. Cache invalidation must happen when first user is created. | Success: App works without login when no users exist, creating owner account enables auth for all subsequent requests, no security bypass after setup._\n",
  "fileStats": {
    "size": 50884,
    "lines": 235,
    "lastModified": "2026-02-12T00:15:44.419Z"
  },
  "comments": []
}
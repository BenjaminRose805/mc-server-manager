{
  "id": "snapshot_1770854735528_blr13v56l",
  "approvalId": "approval_1770854544132_ts0pwtdpa",
  "approvalTitle": "EPIC-5: Multi-User Foundation â€” Requirements Document",
  "version": 2,
  "timestamp": "2026-02-12T00:05:35.528Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document -- Multi-User Foundation\n\n## Introduction\n\nTransform MC Server Manager from a single-user desktop application into a multi-user community platform. The host runs the Express backend as a network-facing server that friends connect to over the internet. This epic implements authentication, authorization, invitation-based registration, role-based permissions, TLS/HTTPS security, and the frontend auth UI.\n\nThis is the platform pivot -- all social features (Friends & Chat, Shared Servers, Voice Communication, Mod Sync) depend on this multi-user foundation being in place.\n\n## Alignment with Product Vision\n\nMC Server Manager evolves from \"manage my servers locally\" to \"invite friends to my community.\" The host shares their server dashboard with friends who can view server status, join game servers, and (in later epics) chat and voice call. This requires:\n- Secure user authentication (JWT + refresh tokens)\n- Controlled access via invite codes (no open registration)\n- Role-based permissions (Owner/Admin/Member with granular per-server control)\n- TLS/HTTPS for network-facing security\n\nPrerequisite for: Epic 6 (Friends & Chat), Epic 7 (Shared Servers), Epic 8 (Voice), Epic 9 (Mod Sync).\n\n---\n\n## Requirements\n\n### REQ-1: Initial Setup (Owner Account)\n\n**User Story:** As the host, I want to create an owner account on first launch, so that I have full control over my community.\n\n#### Acceptance Criteria\n\n1. WHEN the application starts with no users in the database THEN the system SHALL display a setup wizard prompting for username, password, and display name.\n2. WHEN the setup form is submitted THEN the system SHALL create the first user with `role=owner` and hash the password using argon2id.\n3. WHEN setup completes THEN the system SHALL return JWT access token (15-minute expiry) and refresh token (30-day expiry) and redirect to the dashboard.\n4. WHEN an owner account already exists THEN the setup endpoint SHALL return 409 Conflict.\n5. WHEN running locally without multi-user configured THEN existing single-user functionality SHALL continue to work without requiring login.\n\n---\n\n### REQ-2: Invitation-Based Registration\n\n**User Story:** As the host, I want to generate invite codes for friends, so that only people I trust can access my community.\n\n#### Acceptance Criteria\n\n1. WHEN the owner or admin creates an invitation THEN the system SHALL generate a unique 8-character code with configurable: max uses (default 1), expiration duration, and assigned role (default member).\n2. WHEN a friend registers with a valid invite code THEN the system SHALL create their account with the role specified in the invitation and increment the usage counter.\n3. IF an invite code has reached its max uses THEN the system SHALL reject registration with a clear error.\n4. IF an invite code has expired THEN the system SHALL reject registration with a clear error.\n5. WHEN the owner or admin lists invitations THEN the system SHALL show: code, uses/max, role, expiration, and creation date.\n6. WHEN the owner or admin deletes an invitation THEN the system SHALL invalidate the code immediately.\n\n---\n\n### REQ-3: Login and Session Management\n\n**User Story:** As a user, I want to log in with my username and password, so that I can access the community dashboard.\n\n#### Acceptance Criteria\n\n1. WHEN the user submits valid credentials THEN the system SHALL return a JWT access token (15-minute expiry) and a refresh token (30-day expiry stored as SHA-256 hash in the sessions table).\n2. WHEN the access token expires THEN the frontend SHALL automatically refresh it using the refresh token without user interaction.\n3. WHEN the refresh token is used THEN the system SHALL verify it against the sessions table, check expiry, and optionally rotate the token.\n4. WHEN the user logs out THEN the system SHALL delete the session record (invalidating the refresh token) and the frontend SHALL discard both tokens.\n5. WHEN the user selects \"logout all sessions\" THEN the system SHALL delete all session records for that user, forcing re-authentication on all devices.\n6. IF the user's account is deactivated THEN login and token refresh SHALL be rejected.\n\n---\n\n### REQ-4: Brute Force Protection\n\n**User Story:** As the host, I want login attempts to be rate-limited, so that attackers cannot guess passwords through brute force.\n\n#### Acceptance Criteria\n\n1. WHEN 5 failed login attempts occur for the same username or IP within 15 minutes THEN the system SHALL block further attempts for that username/IP with a 429 response.\n2. WHEN a successful login occurs THEN the system SHALL clear the failed attempt counter for that username.\n3. WHEN login attempts are recorded THEN the system SHALL store: username, IP address, success/failure, and timestamp.\n4. WHEN old login attempt records exceed 7 days THEN the system SHALL clean them up automatically.\n\n---\n\n### REQ-5: Role-Based Access Control\n\n**User Story:** As the host, I want to assign roles to users, so that I can control what each person can do.\n\n#### Acceptance Criteria\n\n1. WHEN a user has the Owner role THEN they SHALL have full access to all features, servers, and administrative functions.\n2. WHEN a user has the Admin role THEN they SHALL have full access to all servers and the ability to manage users (except the Owner) and create invitations.\n3. WHEN a user has the Member role THEN they SHALL only have access to servers where they have been explicitly granted permissions.\n4. WHEN the Owner changes a user's role THEN the system SHALL update it immediately and the user's next token refresh SHALL reflect the new role.\n5. WHEN any user (except the Owner) is deactivated THEN their sessions SHALL be revoked and they SHALL be unable to log in.\n6. The Owner account SHALL NOT be deletable or demotable.\n\n---\n\n### REQ-6: Granular Server Permissions\n\n**User Story:** As the host, I want to control exactly what each member can do on each server, so that I can give limited access to friends.\n\n#### Acceptance Criteria\n\n1. WHEN a Member views the server list THEN they SHALL only see servers where they have `can_view` permission.\n2. WHEN permissions are configured for a user on a server THEN the system SHALL support: `can_view` (see server), `can_start` (start/stop/restart), `can_console` (send commands), `can_edit` (change settings).\n3. WHEN a user lacks the required permission for an action THEN the API SHALL return 403 Forbidden and the UI SHALL hide or disable the corresponding controls.\n4. WHEN an Owner or Admin accesses any server THEN permission checks SHALL be bypassed (full access).\n5. WHEN a server is deleted THEN all associated permission records SHALL be cascade-deleted.\n\n---\n\n### REQ-7: TLS/HTTPS Support\n\n**User Story:** As the host, I want my community server to use HTTPS, so that connections from friends are encrypted and secure.\n\n#### Acceptance Criteria\n\n1. WHEN TLS mode is set to \"letsencrypt\" THEN the system SHALL automatically provision and renew certificates from Let's Encrypt using the HTTP-01 challenge.\n2. WHEN TLS mode is set to \"custom\" THEN the system SHALL load user-provided certificate and key files.\n3. WHEN TLS mode is set to \"self-signed\" THEN the system SHALL generate a self-signed certificate for LAN-only use.\n4. WHEN TLS mode is set to \"disabled\" THEN the system SHALL run plain HTTP (with a warning log).\n5. WHEN a Let's Encrypt certificate is within 30 days of expiry THEN the system SHALL automatically renew it.\n6. WHEN TLS is enabled THEN the WebSocket server SHALL also use the TLS certificate (wss://).\n\n---\n\n### REQ-8: Network Configuration\n\n**User Story:** As the host, I want to configure how my community server is accessible on the network, so that friends can connect from the internet.\n\n#### Acceptance Criteria\n\n1. WHEN multi-user mode is enabled THEN the backend SHALL bind to `0.0.0.0` (all interfaces) instead of `127.0.0.1`.\n2. WHEN UPnP is enabled in settings THEN the system SHALL attempt automatic port forwarding via UPnP.\n3. IF UPnP port forwarding fails THEN the system SHALL log a warning and display manual port forwarding instructions.\n4. WHEN the user views network settings THEN the system SHALL show: current bind address, port, public IP (detected), TLS status, and UPnP status.\n\n---\n\n### REQ-9: Security Hardening\n\n**User Story:** As the host, I want the server to follow security best practices, so that my community is protected from attacks.\n\n#### Acceptance Criteria\n\n1. WHEN the server starts THEN it SHALL apply security headers via Helmet (CSP, HSTS, referrer policy, etc.).\n2. WHEN the server starts THEN it SHALL configure CORS to only allow the Tauri app origin and any configured custom domain.\n3. WHEN API endpoints are called THEN a general rate limiter SHALL allow a maximum of 100 requests per minute per IP.\n4. WHEN auth endpoints are called THEN a strict rate limiter SHALL allow a maximum of 5 requests per 15 minutes per IP.\n5. WHEN any request contains user input THEN it SHALL be validated using Zod schemas before processing.\n6. WHEN JWT secrets are needed THEN the system SHALL auto-generate a 64-byte random secret on first startup and store it in the settings table.\n\n---\n\n### REQ-10: Frontend Auth UI\n\n**User Story:** As a user, I want login, registration, and admin pages, so that I can manage my account and community.\n\n#### Acceptance Criteria\n\n1. WHEN no users exist THEN the app SHALL show the setup wizard at the root route.\n2. WHEN the user is not authenticated THEN all routes SHALL redirect to the login page.\n3. WHEN the user is authenticated THEN the app SHALL show the dashboard with a user menu (profile, logout).\n4. WHEN a friend has an invite code THEN they SHALL be able to register via `/register?code=...`.\n5. WHEN an Owner or Admin navigates to the admin panel THEN they SHALL see: user list (with role management), active invitations (with create/delete), and server permission management.\n6. WHEN a Member navigates to the admin panel THEN the system SHALL deny access and redirect to the dashboard.\n\n---\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Responsibility Principle**: Auth services (password hashing, JWT, sessions, brute force) SHALL each be in separate files.\n- **Modular Design**: Auth middleware SHALL be composable (`requireAuth`, `requireRole('admin')`, `requireServerPermission('can_start')`).\n- **Backward Compatibility**: When running in single-user mode (no users exist), all existing functionality SHALL work without authentication.\n- **Clear Interfaces**: All auth types (User, Session, Invitation, etc.) SHALL be defined in the shared package.\n\n### Performance\n- JWT verification SHALL be synchronous and under 1ms (HS256 with cached secret).\n- Password hashing with argon2id SHALL complete within 500ms (configurable via memory/time cost parameters).\n- Token refresh SHALL be seamless -- users SHALL NOT experience authentication interruptions.\n\n### Security\n- Passwords SHALL be hashed with argon2id (OWASP recommended), NOT bcrypt or SHA-256.\n- Refresh tokens SHALL be hashed (SHA-256) before database storage -- never stored in plaintext.\n- JWT secrets SHALL be minimum 64 bytes of cryptographically random data.\n- All sensitive data (passwords, tokens) SHALL be excluded from logs.\n- Error responses SHALL NOT leak internal details (no stack traces, no \"user not found\" vs \"wrong password\" distinction).\n\n### Reliability\n- IF the JWT secret is lost (database corruption) THEN all tokens are automatically invalidated and users must re-authenticate.\n- IF TLS certificate provisioning fails THEN the server SHALL fall back to HTTP with clear warnings.\n- Session cleanup (expired tokens, old login attempts) SHALL run on a periodic timer (every hour).\n\n### Usability\n- Token refresh SHALL be invisible to users -- the frontend handles it automatically.\n- The setup wizard SHALL be simple: 3 fields (username, display name, password).\n- Invite codes SHALL be short (8 characters) and easy to share via text/chat.\n- The admin panel SHALL provide one-click invite code generation with copy-to-clipboard.\n",
  "fileStats": {
    "size": 12090,
    "lines": 197,
    "lastModified": "2026-02-12T00:01:19.114Z"
  },
  "comments": []
}
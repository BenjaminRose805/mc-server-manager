{
  "id": "snapshot_1771046819426_15mihrgaw",
  "approvalId": "approval_1771046819412_fv9z05idn",
  "approvalTitle": "Application Logging - Tasks",
  "version": 1,
  "timestamp": "2026-02-14T05:26:59.426Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document\n\n- [ ] 1. Create frontend logger utility\n  - Files: `packages/frontend/src/utils/logger.ts` (new)\n  - Create a lightweight structured logging utility for the browser with level-based filtering\n  - Purpose: Foundation for all frontend logging — must exist before any frontend catch blocks can be updated\n  - _Leverage: `packages/backend/src/utils/logger.ts` for interface inspiration (Pino's level-based API with context objects)_\n  - _Requirements: REQ-5_\n  - _Prompt: Implement the task for spec application-logging, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Frontend TypeScript Developer | Task: Create `packages/frontend/src/utils/logger.ts`. This is a zero-dependency browser logger. Read `packages/backend/src/utils/logger.ts` to understand the backend's Pino logger pattern (level methods with context objects). Create a logger with this interface: `type LogLevel = 'debug' | 'info' | 'warn' | 'error'; interface LogContext { [key: string]: unknown; } interface Logger { debug(message: string, context?: LogContext): void; info(message: string, context?: LogContext): void; warn(message: string, context?: LogContext): void; error(message: string, context?: LogContext): void; }`. Export `const logger: Logger`. Implementation: each level method calls the corresponding `console.*` method with format `[LEVEL] message` as first arg and context as second arg (so it's expandable in DevTools). In production builds (check `import.meta.env.PROD`), suppress `debug` level unless `localStorage.getItem('debug') === 'true'`. Wrap each console call in try-catch so logging never breaks the app. | Restrictions: Zero dependencies — do NOT import any npm packages. Do NOT use classes — use a plain object with methods. Keep it under 40 lines. Do NOT add any external error reporting (Sentry, etc.). | Success: File compiles, exports `logger`, calling `logger.warn(\"test\", { foo: 1 })` outputs `[WARN] test` with `{ foo: 1 }` in browser console. `npm run build -w frontend` succeeds. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 2. Enhance backend error middleware with request context\n  - Files: `packages/backend/src/app.ts` (modify)\n  - Add request method, path, query, and user ID to all error log entries; log AppError (4xx) at warn level\n  - Purpose: The highest-value single change — makes all API errors debuggable from logs\n  - _Leverage: `packages/backend/src/app.ts` (existing error middleware at bottom of file), `packages/backend/src/utils/errors.ts` (AppError class with statusCode, code), `packages/backend/src/middleware/auth.ts` (req.user shape)_\n  - _Requirements: REQ-1_\n  - _Prompt: Implement the task for spec application-logging, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer | Task: Read `packages/backend/src/app.ts` — find the error handling middleware at the bottom (the `app.use((err, _req, res, _next) => { ... })` block). Currently, `AppError` instances (4xx) are returned to the client with NO logging. Unexpected errors (5xx) are logged but with only `{ err }` — no request context. Modify the error middleware: (1) For `AppError` instances: add `logger.warn({ statusCode: err.statusCode, code: err.code, method: req.method, path: req.path, userId: req.user?.id }, err.message)` BEFORE the `res.status()` call. (2) For unexpected errors: change the existing `logger.error({ err }, \"Unhandled error\")` to `logger.error({ err, method: req.method, path: req.path, query: req.query, userId: req.user?.id }, \"Unhandled error\")`. Also change `_req` to `req` in the parameter list since we now use it. The `logger` import already exists in this file. | Restrictions: Do NOT change response bodies or status codes. Do NOT change middleware ordering. Do NOT log request bodies (they may contain passwords on auth routes). Keep the existing `_next` unused parameter name. | Success: When a 404 AppError is thrown, logs show `WARN` with method, path, statusCode, code, userId. When a 500 occurs, logs show `ERROR` with full err stack, method, path, query, userId. `npm run build -w backend` succeeds. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 3. Add rate-limit and auth middleware logging\n  - Files: `packages/backend/src/middleware/rate-limit.ts` (modify), `packages/backend/src/middleware/auth.ts` (modify)\n  - Log rate limit rejections and auth/authorization failures\n  - Purpose: Makes rate limiting visible in logs (the exact gap that caused the original 429 debugging difficulty) and creates an auth rejection audit trail\n  - _Leverage: `packages/backend/src/middleware/rate-limit.ts` (existing authRateLimit config), `packages/backend/src/middleware/auth.ts` (existing requireAuth, requireRole, etc.), `packages/backend/src/utils/logger.ts` (Pino logger)_\n  - _Requirements: REQ-3, REQ-8_\n  - _Prompt: Implement the task for spec application-logging, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer | Task: (1) Read `packages/backend/src/middleware/rate-limit.ts`. Add `import { logger } from \"../utils/logger.js\";` at top. Add a `handler` option to the `authRateLimit` config: `handler: (req, res) => { logger.warn({ ip: req.ip, path: req.path, method: req.method }, \"Auth rate limit exceeded\"); res.status(429).json({ error: \"Too many authentication attempts, please try again later\" }); }`. (2) Read `packages/backend/src/middleware/auth.ts`. Add `import { logger } from \"../utils/logger.js\";` at top. In `requireAuth`: after the check `if (!header || ...)`, add `logger.warn({ path: req.path, method: req.method }, \"Missing or malformed Authorization header\");` before the throw. After `if (!payload)`, add `logger.warn({ path: req.path, method: req.method }, \"Invalid or expired access token\");` before the throw. In `requireRole`: when role check fails, add `logger.warn({ path: req.path, userId: req.user?.id, role: req.user?.role, requiredRoles: roles }, \"Insufficient role\");` before the throw. In `requireServerPermission`: when permission check fails, add `logger.warn({ path: req.path, userId: req.user?.id, serverId: rawId, permission }, \"Server permission denied\");` before the throw. | Restrictions: Do NOT change any existing error messages or status codes. Do NOT change the `message` field in the rate limit config — it's replaced by the handler. Keep the `skip: (req) => req.method === \"GET\"` behavior. Use `.js` extension in imports. | Success: Rate limit rejections appear in logs with IP and path. Auth failures appear with path, userId, and reason. `npm run build -w backend` succeeds. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 4. Add session and brute-force service logging\n  - Files: `packages/backend/src/services/session.ts` (modify), `packages/backend/src/services/brute-force.ts` (modify)\n  - Add logger import and log security-sensitive operations (session create/revoke, lockout, cleanup)\n  - Purpose: Security audit trail for auth operations\n  - _Leverage: `packages/backend/src/services/session.ts` (existing functions), `packages/backend/src/services/brute-force.ts` (existing functions), `packages/backend/src/utils/logger.ts`_\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec application-logging, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer | Task: (1) Read `packages/backend/src/services/session.ts`. Add `import { logger } from \"../utils/logger.js\";` at top. Add logging: in `createSession` after the INSERT succeeds: `logger.info({ userId, sessionId: id }, \"Session created\");`. In `revokeSession`: `logger.info({ sessionId }, \"Session revoked\");`. In `revokeAllUserSessions` after DELETE: `logger.info({ userId, revokedCount: result.changes }, \"All user sessions revoked\");`. In `cleanupExpiredSessions` after DELETE: `logger.info({ cleanedUp: result.changes }, \"Expired sessions cleaned up\");`. (2) Read `packages/backend/src/services/brute-force.ts`. Add `import { logger } from \"../utils/logger.js\";` at top. In `isLockedOut`, when the function is about to return `true` (count >= MAX): add `logger.warn({ username, ipAddress }, \"Login lockout triggered\");` before the return. In `cleanupOldAttempts` after the DELETE: `logger.info({ cleanedUp: result.changes }, \"Old login attempts cleaned up\");`. | Restrictions: Do NOT change any existing return values or behavior. Do NOT log passwords or tokens. Use `.js` extension in imports. | Success: Login creates session log entry. Lockout triggers warn entry with username/IP. Cleanup logs count. `npm run build -w backend` succeeds. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 5. Add WebSocket lifecycle logging\n  - Files: `packages/backend/src/ws/handlers.ts` (modify)\n  - Log WebSocket auth success/failure, auth timeout, and client disconnect events\n  - Purpose: Visibility into WebSocket connection lifecycle for debugging real-time communication issues\n  - _Leverage: `packages/backend/src/ws/handlers.ts` (existing handlers — logger already imported), `packages/backend/src/ws/index.ts` (existing connection logging for reference)_\n  - _Requirements: REQ-4_\n  - _Prompt: Implement the task for spec application-logging, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with WebSocket expertise | Task: Read `packages/backend/src/ws/handlers.ts`. The `logger` import already exists. Add logging at these points: (1) In the `msg.type === \"auth\"` block — after `authenticatedClients.set(ws, ...)` and before `sendMessage(ws, { type: \"auth:ok\" })`: add `logger.info({ userId: payload.sub, username: payload.username }, \"WebSocket client authenticated\");`. (2) In the same block — when `!payload` (auth failed), before `ws.close(4001, \"Auth failed\")`: add `logger.warn(\"WebSocket auth failed: invalid or expired token\");`. (3) In the `initAuth` function — inside the `setTimeout` callback, when `!authenticatedClients.has(ws)` and before `ws.close(4001, \"Auth timeout\")`: add `logger.warn(\"WebSocket auth timeout — closing connection\");`. (4) In `handleDisconnect` — at the start of the function, before cleanup: `const user = authenticatedClients.get(ws); const subs = clientSubscriptions.get(ws); logger.debug({ userId: user?.id, subscriptionCount: subs?.size ?? 0 }, \"WebSocket client disconnected\");`. | Restrictions: Do NOT change any existing behavior (close codes, messages, cleanup logic). Keep existing debug-level logging for subscribe/unsubscribe as-is. | Success: Connecting with valid token logs info with userId. Invalid token logs warn. Timeout logs warn. Disconnect logs debug with userId and sub count. `npm run build -w backend` succeeds. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 6. Remediate backend silent catch blocks\n  - Files: `packages/backend/src/services/java.ts` (modify), `packages/backend/src/services/server-manager.ts` (modify), `packages/backend/src/services/process.ts` (modify), `packages/backend/src/services/auth.ts` (modify), `packages/backend/src/services/jwt.ts` (modify), `packages/backend/src/middleware/cors-config.ts` (modify), `packages/backend/src/ws/handlers.ts` (modify), `packages/backend/src/providers/forge.ts` (modify), `packages/backend/src/providers/neoforge.ts` (modify)\n  - Add debug/warn level logging to all empty catch blocks across backend services\n  - Purpose: Eliminate silent failures that make debugging impossible\n  - _Leverage: `packages/backend/src/utils/logger.ts` (Pino logger), each file's existing logging patterns_\n  - _Requirements: REQ-2_\n  - _Prompt: Implement the task for spec application-logging, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer | Task: Add logging to all empty or insufficiently-logged catch blocks in the following files. For each file, add `import { logger } from \"../utils/logger.js\";` (or adjust relative path) if not already imported. Use `logger.debug` for expected/probing failures, `logger.warn` for recoverable but unexpected failures. Specific changes: (1) `services/java.ts` — 9 empty catch blocks at lines ~105, 122, 230, 266, 301, 355, 375, 479, 499. These are Java detection probing operations. Add `catch (err) { logger.debug({ err, path: <relevant-path-variable> }, \"Java probe failed\"); }` or similar with the relevant context (the path or command being probed). The logger import needs to be added (it already exists in this file, verify). (2) `services/server-manager.ts` — line ~329 `catch {}` during graceful stop: change to `catch (err) { logger.warn({ err, serverId: id }, \"Error during graceful server stop\"); resolve(); }`. Line ~341 `catch { /* already dead */ }`: change to `catch (err) { logger.debug({ err, serverId: id }, \"Force-kill failed — process likely already dead\"); }`. (3) `services/process.ts` — line ~244 empty catch during stdin write: change to `catch (err) { logger.warn({ err, serverId: this.serverId }, \"Failed to write stop command to stdin\"); }`. (4) `services/auth.ts` — line ~20 empty catch in verifyPassword: add `import { logger } from \"../utils/logger.js\";` and change to `catch (err) { logger.debug({ err }, \"Password verification failed — argon2 error\"); return false; }`. (5) `services/jwt.ts` — line ~53 empty catch in verifyAccessToken: add `import { logger } from \"../utils/logger.js\";` and change to `catch (err) { logger.debug(\"JWT verification failed\"); return null; }`. (6) `middleware/cors-config.ts` — line ~17 empty catch in URL parsing: add `import { logger } from \"../utils/logger.js\";` and change to `catch (err) { logger.debug({ origin }, \"CORS origin URL parse failed\"); return false; }`. (7) `ws/handlers.ts` — line ~88 empty catch for JSON parse: logger already imported. Change to `catch (err) { logger.warn({ raw: raw.slice(0, 200) }, \"Failed to parse WebSocket message as JSON\"); }`. (8) `providers/forge.ts` — line ~131 empty catch: add `catch (err) { logger.debug({ err }, \"Forge version parse failed\"); }`. Lines ~400, ~410 empty catches for cleanup: add `catch (err) { logger.debug({ err }, \"Forge installer cleanup failed\"); }`. (9) `providers/neoforge.ts` — lines ~355, ~368 empty catches: add `catch (err) { logger.debug({ err }, \"NeoForge installer cleanup failed\"); }`. | Restrictions: Do NOT change any existing return values, control flow, or error handling behavior. Only ADD logging inside existing catch blocks. Preserve any existing comments. Use `.js` extension in all imports. For java.ts, read each catch block to understand what's being probed and add the appropriate context variable. | Success: No empty catch blocks remain in these files. All use logger.debug or logger.warn with context. Existing behavior unchanged. `npm run build -w backend` succeeds. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 7. Remediate frontend silent catch blocks and add logging to error handlers\n  - Files: `packages/frontend/src/contexts/AuthContext.tsx` (modify), `packages/frontend/src/api/ws.ts` (modify), `packages/frontend/src/pages/CreateServer.tsx` (modify), `packages/frontend/src/pages/Mods.tsx` (modify), `packages/frontend/src/pages/ServerDetail.tsx` (modify), `packages/frontend/src/pages/Login.tsx` (modify), `packages/frontend/src/pages/Launcher.tsx` (modify), `packages/frontend/src/pages/AppSettings.tsx` (modify), `packages/frontend/src/pages/InstanceDetail.tsx` (modify), `packages/frontend/src/components/ModList.tsx` (modify), `packages/frontend/src/components/ServerControls.tsx` (modify), `packages/frontend/src/components/PropertiesForm.tsx` (modify)\n  - Add structured logging to all frontend catch blocks — silent catches, toast-only catches, and error-state-only catches\n  - Purpose: Make frontend errors visible to developers for debugging\n  - _Leverage: `packages/frontend/src/utils/logger.ts` (created in task 1), existing catch block patterns in each file_\n  - _Requirements: REQ-6_\n  - _Prompt: Implement the task for spec application-logging, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer | Task: Add `import { logger } from \"@/utils/logger\";` to each file listed below. Add a `logger.warn` or `logger.error` call inside every catch block BEFORE the existing behavior (toast, error state, etc.). Use this pattern for extracting error info: `const errorMsg = err instanceof Error ? err.message : String(err); const status = err && typeof err === \"object\" && \"status\" in err ? (err as { status: number }).status : undefined;`. Specific files and changes: (1) `contexts/AuthContext.tsx` — 4 catch blocks: line ~106 (token refresh timer failure): `logger.warn(\"Token refresh failed\", { error: errorMsg });`. Line ~139 (logout API failure): `logger.warn(\"Logout API call failed\", { error: errorMsg });`. Line ~160 (auth status check failure): `logger.debug(\"Auth status check failed\", { error: errorMsg });`. Line ~204 (initial token refresh failure): `logger.warn(\"Initial token refresh failed\", { error: errorMsg });`. (2) `api/ws.ts` — line ~73 (JSON parse failure): add `catch (err) { logger.warn(\"Failed to parse WebSocket message\", { error: err instanceof Error ? err.message : String(err) }); }`. Line ~86 (onerror): add `logger.warn(\"WebSocket connection error\");` inside the onerror handler. In `scheduleReconnect`, at the start: add `logger.debug(\"WebSocket scheduling reconnect\", { delayMs: this.reconnectDelay });`. (3) `pages/CreateServer.tsx` — lines ~130, ~134 (silent .catch blocks for Java/system info): replace empty `.catch(() => {})` with `.catch((err) => { logger.warn(\"Failed to fetch system info\", { error: err instanceof Error ? err.message : String(err) }); })`. Line ~440 (version fetch): same pattern with message \"Failed to fetch versions\". (4) `pages/Mods.tsx` — lines ~886, ~890, ~900 (silent .catch blocks): replace with logger.warn calls describing what failed (e.g., \"Failed to fetch mod categories\", \"Failed to fetch modpack categories\", \"Failed to fetch settings\"). (5) `pages/ServerDetail.tsx` — lines ~129, ~152: add `logger.error(\"Failed to load server\", { error: errorMsg, serverId: id });` before existing error state setting. (6) `pages/Login.tsx` — line ~33: add `logger.warn(\"Login failed\", { error: errorMsg, status });` before existing error handling. (7) `pages/Launcher.tsx` — lines ~24, ~43, ~59: add `logger.warn` with appropriate message before each `toast.error`. (8) `pages/AppSettings.tsx` — lines ~85, ~115: add `logger.warn` before toast. (9) `pages/InstanceDetail.tsx` — lines ~75, ~89, ~238, ~466, ~491: add `logger.warn` before toast/error state. (10) `components/ModList.tsx` — lines ~103, ~124, ~146, ~171, ~196, ~226: add `logger.warn` before toast. (11) `components/ServerControls.tsx` — line ~71: add `logger.warn(\"Server control action failed\", { error: errorMsg, serverId });` before toast. (12) `components/PropertiesForm.tsx` — lines ~63, ~147: add `logger.warn` before toast. NOTE: The exact line numbers may have shifted — find each catch block by reading the file. Focus on matching the pattern (catch block near a toast.error or empty catch). | Restrictions: Do NOT remove any existing behavior (toasts, error states). ADD logging BEFORE existing handling. Do NOT change any UI. Use `@/utils/logger` import path (not relative). | Success: Every catch block in these files has a logger call. No more empty catches. No more toast-only catches without logging. All existing toasts and error states still work. `npm run build -w frontend` succeeds. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 8. Enhance ErrorBoundary with structured logging\n  - Files: `packages/frontend/src/components/ErrorBoundary.tsx` (modify)\n  - Replace console.error with structured logger call including component stack and route\n  - Purpose: Make React component crashes visible through the structured logger\n  - _Leverage: `packages/frontend/src/utils/logger.ts` (created in task 1), `packages/frontend/src/components/ErrorBoundary.tsx` (existing ErrorBoundary)_\n  - _Requirements: REQ-7_\n  - _Prompt: Implement the task for spec application-logging, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer | Task: Read `packages/frontend/src/components/ErrorBoundary.tsx`. Currently line ~24 has `console.error('[ErrorBoundary] Uncaught error:', error, info.componentStack);`. Add `import { logger } from \"@/utils/logger\";` at the top of the file. Replace the `console.error` line with: `logger.error(\"Uncaught React error\", { error: error.message, stack: error.stack, componentStack: info.componentStack, url: window.location.pathname });`. This captures the error message, stack trace, React component stack, and the current route — all structured for debugging. | Restrictions: Do NOT change the ErrorBoundary UI (the fallback render). Do NOT change getDerivedStateFromError. Do NOT add try-catch around the logger call (the logger itself is already safe). Keep the class component pattern (ErrorBoundary must be a class component). | Success: When a React component crashes, the browser console shows a structured error log with error message, stack, component stack, and URL path. `npm run build -w frontend` succeeds. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 9. Verification and build check\n  - Files: Various (read-only verification, fix any issues found)\n  - Run full build, verify logging works end-to-end, fix any compilation issues\n  - Purpose: Ensure everything compiles and integrates correctly\n  - _Leverage: Root `package.json` build scripts_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec application-logging, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Senior Developer | Task: (1) Run `npm run build -w shared && npm run build -w backend` — must succeed with zero errors. (2) Run `npm run build -w frontend` — must succeed with zero errors. (3) If any build fails, read the error, find the source file, and fix the issue (likely a missed import, wrong import path, or type mismatch). (4) Verify that all backend files modified in tasks 2-6 still have valid `.js` extensions on imports. (5) Verify that all frontend files modified in tasks 7-8 use `@/utils/logger` import path. (6) Run `grep -r \"catch {}\" packages/backend/src/` and `grep -r \"catch {}\" packages/frontend/src/` to verify no empty catch blocks remain in files that were part of this spec. Some empty catches in files NOT part of this spec are acceptable. | Restrictions: Do NOT make functional changes — this is verification only. Only fix compilation errors or missed imports. | Success: Full build passes with zero errors. No empty catch blocks in files modified by this spec. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n",
  "fileStats": {
    "size": 23760,
    "lines": 74,
    "lastModified": "2026-02-14T05:26:53.888Z"
  },
  "comments": []
}
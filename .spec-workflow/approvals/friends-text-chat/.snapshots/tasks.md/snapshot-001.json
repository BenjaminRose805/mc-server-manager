{
  "id": "snapshot_1770856003275_8gr65dyxy",
  "approvalId": "approval_1770856003265_zamd5bims",
  "approvalTitle": "EPIC-6: Friends & Text Chat â€” Tasks Document",
  "version": 1,
  "timestamp": "2026-02-12T00:26:43.275Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document -- Friends & Text Chat\n\n- [ ] 1. Add shared friend, chat, and WebSocket types\n  - Files: `shared/src/index.ts` (modify)\n  - Add types: `FriendshipStatus`, `PresenceStatus`, `Friendship`, `Presence`, `Friend`, `FriendRequest`, `ChannelType`, `MessageType`, `Channel`, `ChannelMember`, `Message`, `MessageRead`, `TypingEvent`\n  - Add WebSocket message types: `ChatSendMessage`, `ChatTypingMessage`, `ChatMessageEvent`, `ChatTypingEvent`, `PresenceUpdateEvent`, `FriendRequestReceivedEvent`, `FriendStatusChangedEvent`\n  - Purpose: Foundation types for the entire friends and chat system\n  - _Leverage: `shared/src/index.ts` for existing type patterns, `.spec-workflow/specs/friends-text-chat/design.md` Data Models section_\n  - _Requirements: REQ-1, REQ-3, REQ-4, REQ-5, REQ-6, REQ-7_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: TypeScript Developer with expertise in shared type definitions | Task: Read `shared/src/index.ts` to understand existing type patterns. Add all friend/chat types from `.spec-workflow/specs/friends-text-chat/design.md` Data Models section: (1) Friend types: `FriendshipStatus` ('pending'|'accepted'|'rejected'), `PresenceStatus` ('online'|'offline'|'in-game'), `Friendship` interface (id, userId, friendId, status, createdAt, updatedAt), `Presence` interface (userId, status, details optional object with serverId and serverName, lastSeen), `Friend` interface (id, username, displayName, presence), `FriendRequest` interface (id, fromUser: {id, username, displayName}, createdAt). (2) Chat types: `ChannelType` ('text'|'dm'), `MessageType` ('text'|'system'), `Channel` (id, type, name, description, createdBy, createdAt, updatedAt, unreadCount?, lastMessage?, members?), `ChannelMember` (userId, username, displayName, joinedAt), `Message` (id, channelId, senderId, senderUsername, senderDisplayName, content, type, createdAt, editedAt), `MessageRead` (channelId, userId, lastReadMessageId, updatedAt), `TypingEvent` (channelId, userId, username). (3) WebSocket client messages: `ChatSendMessage` (type='chat:send', channelId, content), `ChatTypingMessage` (type='chat:typing', channelId). (4) WebSocket server messages: `ChatMessageEvent`, `ChatTypingEvent`, `PresenceUpdateEvent`, `FriendRequestReceivedEvent`, `FriendStatusChangedEvent`. Export all types. | Restrictions: Do NOT remove or rename any existing types. Do NOT modify existing WebSocket message type unions -- extend them or create new ones. | Success: All types compile, all exported, existing types unchanged, `npm run build -w shared` succeeds._\n\n- [ ] 2. Create database migration for friends and chat tables\n  - Files: `packages/backend/migrations/007_friends_chat.sql` (new)\n  - Create tables: `friendships`, `channels`, `channel_members`, `messages`, `message_reads`\n  - Add all indexes and constraints as defined in design\n  - Purpose: Database schema for the social system\n  - _Leverage: `packages/backend/migrations/` for existing patterns, `.spec-workflow/specs/friends-text-chat/design.md` Data Models section, `plans/EPIC-6-friends-chat.md` Phase 6A_\n  - _Requirements: REQ-1, REQ-4, REQ-5, REQ-6, REQ-8_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Database Engineer with expertise in SQLite schema design | Task: Check existing migrations in `packages/backend/migrations/` to confirm the next number (should be 007 since 006 is used by multi-user). Create `007_friends_chat.sql` with tables: (1) `friendships`: id TEXT PK, user_id TEXT FK users, friend_id TEXT FK users, status TEXT DEFAULT 'pending', created_at, updated_at. UNIQUE(user_id, friend_id), CHECK(user_id != friend_id), CHECK(status IN ('pending','accepted','rejected')). Indexes on (user_id, status) and (friend_id, status). (2) `channels`: id TEXT PK, type TEXT DEFAULT 'text', name TEXT, description TEXT, created_by TEXT FK users ON DELETE SET NULL, created_at, updated_at. CHECK type IN ('text','dm'). CHECK name NOT NULL when text, NULL when dm. Indexes on type, created_by. (3) `channel_members`: channel_id TEXT FK channels, user_id TEXT FK users, joined_at. PK(channel_id, user_id). Index on user_id. (4) `messages`: id TEXT PK, channel_id TEXT FK channels, sender_id TEXT FK users, content TEXT NOT NULL, type TEXT DEFAULT 'text', created_at, edited_at. CHECK type IN ('text','system'), CHECK length(content) greater than 0 AND length(content) at most 4000. Index on (channel_id, created_at DESC), sender_id. (5) `message_reads`: channel_id TEXT FK channels, user_id TEXT FK users, last_read_msg_id TEXT FK messages, updated_at. PK(channel_id, user_id). Index on user_id. All FKs use ON DELETE CASCADE. Use `DEFAULT (datetime('now'))` for timestamps. Reference `plans/EPIC-6-friends-chat.md` Phase 6A. | Restrictions: Do NOT modify existing migrations. All FKs reference existing tables (users from migration 006, servers from 001). | Success: SQL is valid, all tables created with correct constraints and indexes._\n\n- [ ] 3. Create friendship database model\n  - Files: `packages/backend/src/models/friendship.ts` (new)\n  - Functions: createFriendRequest, updateFriendshipStatus, createReverseFriendship, getFriendship, getFriendshipById, getFriends, getPendingRequests, deleteFriendship\n  - Purpose: Data access layer for friend system\n  - _Leverage: Existing model files for patterns, `plans/EPIC-6-friends-chat.md` Phase 6C.1_\n  - _Requirements: REQ-1, REQ-2_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in SQLite models | Task: Read existing model files in `packages/backend/src/models/` for the pattern (database access, prepared statements). Create `packages/backend/src/models/friendship.ts` with functions: (1) `createFriendRequest(userId, friendId): Friendship` -- INSERT with status='pending', nanoid for ID. (2) `updateFriendshipStatus(friendshipId, status): void` -- UPDATE status and updated_at. (3) `createReverseFriendship(friendshipId): void` -- read the accepted friendship, INSERT reverse edge (friend_id->user_id) with status='accepted'. Use ON CONFLICT DO UPDATE for idempotency. (4) `getFriendship(userId, friendId): Friendship | null`. (5) `getFriendshipById(id): Friendship | null`. (6) `getFriends(userId): Friendship[]` -- WHERE user_id=? AND status='accepted', ORDER BY updated_at DESC. (7) `getPendingRequests(userId): Friendship[]` -- WHERE friend_id=? AND status='pending' (requests TO this user). (8) `deleteFriendship(userId, friendId): void` -- DELETE both directions. Map snake_case to camelCase. Reference `plans/EPIC-6-friends-chat.md` Phase 6C.1. | Restrictions: Use prepared statements. Follow existing model patterns exactly. Use `.js` extension in imports. | Success: All functions compile, bidirectional friendship storage works, pending queries return correct direction._\n\n- [ ] 4. Create FriendManager service\n  - Files: `packages/backend/src/services/friend-manager.ts` (new)\n  - Business logic: sendFriendRequest (validates username, checks duplicates), acceptFriendRequest (creates reverse edge), rejectFriendRequest, removeFriend, getFriends (with presence), getPendingRequests\n  - Purpose: Friend request lifecycle with validation\n  - _Leverage: `plans/EPIC-6-friends-chat.md` Phase 6C.2, friendship model, user model, presence manager_\n  - _Requirements: REQ-1, REQ-2_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in business logic services | Task: Create `packages/backend/src/services/friend-manager.ts`. Export singleton `friendManager`. Implement: (1) `sendFriendRequest(fromUserId, toUsername)` -- lookup user by username (NotFoundError if not found), reject self-request (ConflictError), check existing friendship in both directions (ConflictError with specific message: 'Already friends', 'Friend request already sent', 'This user has already sent you a friend request'). Create pending request. (2) `acceptFriendRequest(userId, friendshipId)` -- verify friendship exists, verify friendId===userId (ForbiddenError), verify status==='pending' (ConflictError), update to accepted, create reverse edge. (3) `rejectFriendRequest(userId, friendshipId)` -- same verification, update to rejected. (4) `removeFriend(userId, friendId)` -- verify friendship exists and is accepted, delete both directions. (5) `getFriends(userId): Friend[]` -- get friendships, map to Friend[] with user info and presence from presenceManager. (6) `getPendingRequests(userId): FriendRequest[]` -- get pending, map with fromUser info. Reference `plans/EPIC-6-friends-chat.md` Phase 6C.2. | Restrictions: Use existing error classes (ConflictError, NotFoundError, ForbiddenError). Presence manager import may be circular -- use lazy import or pass as parameter. Use `.js` extension in imports. | Success: All validation cases covered, bidirectional friendship created on accept, presence included in friends list._\n\n- [ ] 5. Create PresenceManager service\n  - Files: `packages/backend/src/services/presence-manager.ts` (new)\n  - In-memory presence tracking with EventEmitter for change broadcasting\n  - Functions: setOnline, setOffline, setInGame, getPresence, getAllPresences\n  - Purpose: Track user online/offline/in-game status\n  - _Leverage: `plans/EPIC-6-friends-chat.md` Phase 6D.1_\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in event-driven architecture | Task: Create `packages/backend/src/services/presence-manager.ts`. Export singleton `presenceManager`. Class `PresenceManager extends EventEmitter` with: (1) Private `presences: Map<string, PresenceData>` for in-memory tracking. (2) `setOnline(userId)` -- set status='online', update lastSeen, emit 'presence:changed' event. (3) `setOffline(userId)` -- set status='offline', update lastSeen, emit event. (4) `setInGame(userId, serverId, serverName)` -- set status='in-game' with details, emit event. (5) `getPresence(userId): Presence` -- return from map, or default offline if not tracked. (6) `getAllPresences(): Map<string, Presence>`. The 'presence:changed' event is consumed by WebSocket handlers to broadcast to friends. Reference `plans/EPIC-6-friends-chat.md` Phase 6D.1. | Restrictions: This is in-memory only -- no database persistence. Presence is derived from connection state. Use Node EventEmitter, not external packages. Use `.js` extension in imports. | Success: Presence state machine works (online -> in-game -> online -> offline), events emitted on changes, default offline for unknown users._\n\n- [ ] 6. Create channel and message database models\n  - Files: `packages/backend/src/models/channel.ts` (new), `packages/backend/src/models/message.ts` (new)\n  - Channel model: createChannel, getChannelById, getTextChannels, getUserChannels, getDMChannel, addChannelMember, getChannelMembers, deleteChannel\n  - Message model: createMessage, getMessageById, getChannelMessages (paginated), updateMessageRead, getUnreadCount\n  - Purpose: Data access for channels, messages, and read tracking\n  - _Leverage: Existing model patterns, `plans/EPIC-6-friends-chat.md` Phases 6E.1, 6E.2_\n  - _Requirements: REQ-4, REQ-5, REQ-6, REQ-8_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in SQLite models and pagination | Task: Create two model files: (A) `channel.ts`: (1) `createChannel(type, name, description, createdBy): Channel`. (2) `getChannelById(id): Channel | null`. (3) `getTextChannels(): Channel[]` -- WHERE type='text'. (4) `getUserChannels(userId): Channel[]` -- JOIN channel_members, ORDER BY updated_at DESC. (5) `getDMChannel(user1Id, user2Id): Channel | null` -- JOIN two channel_members entries WHERE type='dm'. (6) `addChannelMember(channelId, userId)` -- INSERT with ON CONFLICT DO NOTHING. (7) `getChannelMembers(channelId): ChannelMember[]` -- JOIN users for username/displayName. (8) `deleteChannel(id)`. (B) `message.ts`: (1) `createMessage(channelId, senderId, content, type): Message` -- INSERT message, update channel updated_at, return full message with sender info (JOIN users). (2) `getMessageById(id): Message | null` -- JOIN users. (3) `getChannelMessages(channelId, limit=50, before?): Message[]` -- paginate by created_at DESC using before message's timestamp. Return in chronological order (reverse after query). JOIN users for sender info. (4) `updateMessageRead(channelId, userId, messageId)` -- INSERT OR REPLACE into message_reads. (5) `getUnreadCount(channelId, userId): number` -- count messages after last_read_msg_id. Map snake_case to camelCase. Reference `plans/EPIC-6-friends-chat.md` Phases 6E.1-6E.2. | Restrictions: Use prepared statements. Pagination must handle the `before` cursor correctly. getDMChannel must find the channel where BOTH users are members. Use `.js` extension in imports. | Success: Channel CRUD works, DM channel lookup is correct, message pagination returns correct order, unread count is accurate._\n\n- [ ] 7. Create ChannelManager and MessageManager services\n  - Files: `packages/backend/src/services/channel-manager.ts` (new), `packages/backend/src/services/message-manager.ts` (new)\n  - ChannelManager: createTextChannel (admin only, auto-add all members), getOrCreateDMChannel (idempotent), getUserChannels, deleteTextChannel\n  - MessageManager: sendMessage (with membership check), getMessages (with membership check), markRead\n  - Purpose: Business logic for channels and messaging\n  - _Leverage: `plans/EPIC-6-friends-chat.md` Phases 6E.3, 6E.4_\n  - _Requirements: REQ-4, REQ-5, REQ-6, REQ-8_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in service layer patterns | Task: Create two services: (A) `channel-manager.ts` -- export singleton `channelManager`. (1) `createTextChannel(name, description, createdBy)` -- check user role is owner/admin (ForbiddenError if member). Create channel with type='text'. Auto-add ALL existing users via listUsers + addChannelMember. (2) `getOrCreateDMChannel(user1Id, user2Id): Channel` -- check for existing DM channel via getDMChannel. If none, create channel type='dm' (name=null, createdBy=null), add both users as members. Return channel. (3) `getUserChannels(userId): Channel[]`. (4) `deleteTextChannel(channelId, userId)` -- verify channel exists, is type='text', user is owner/admin. Delete. (B) `message-manager.ts` -- export singleton `messageManager`. (1) `sendMessage(channelId, senderId, content): Message` -- verify channel exists, verify sender is a member (getChannelMembers), create message. (2) `getMessages(channelId, userId, limit, before?): Message[]` -- verify membership, return paginated messages. (3) `markRead(channelId, userId, messageId)` -- update message_reads. Reference `plans/EPIC-6-friends-chat.md` Phases 6E.3-6E.4. | Restrictions: Use error classes from utils/errors.ts. DM channel creation must be idempotent (return existing if found). Membership check before every message send. Use `.js` extension in imports. | Success: Text channels require admin, DMs are idempotent, membership enforced on send/read._\n\n- [ ] 8. Create friend, channel, and message REST routes\n  - Files: `packages/backend/src/routes/friends.ts` (new), `packages/backend/src/routes/channels.ts` (new), `packages/backend/src/routes/messages.ts` (new)\n  - Friend routes: POST request, POST accept/reject, DELETE remove, GET list, GET pending\n  - Channel routes: POST create, GET list, POST dm/:userId, DELETE channel\n  - Message routes: GET history (paginated), POST mark read\n  - Purpose: REST API for social features\n  - _Leverage: Existing route patterns, Zod validation, `plans/EPIC-6-friends-chat.md` Phases 6C.3, 6E.5, 6E.6_\n  - _Requirements: REQ-1, REQ-2, REQ-4, REQ-5, REQ-6, REQ-8_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in Express routing and Zod validation | Task: Read existing route files for patterns. Create three route files, all requiring `requireAuth` middleware: (A) `friends.ts`: `POST /request` (body with username field), `POST /:friendshipId/accept`, `POST /:friendshipId/reject`, `DELETE /:friendId`, `GET /` (list friends), `GET /requests` (pending requests). Use Zod for request body validation. (B) `channels.ts`: `POST /` (body with name and optional description, admin only), `GET /` (user's channels), `POST /dm/:userId` (get or create DM), `DELETE /:channelId` (admin only). (C) `messages.ts`: `GET /:channelId` (query: limit, before for pagination), `POST /:channelId/read` (body with messageId field). All error handling via next(err). Reference `plans/EPIC-6-friends-chat.md` Phases 6C.3, 6E.5, 6E.6. | Restrictions: Use Zod for ALL request body validation. Follow existing route handler try/catch/next pattern. Friend request sends by username not ID. Use `.js` extension in imports. | Success: All routes compile, Zod validates inputs, auth required on all, admin check on channel create/delete._\n\n- [ ] 9. Mount new routes in app.ts\n  - Files: `packages/backend/src/app.ts` (modify)\n  - Mount: `/api/friends`, `/api/channels`, `/api/messages`\n  - Purpose: Register social routes in Express application\n  - _Leverage: Existing route mounting in `packages/backend/src/app.ts`_\n  - _Requirements: REQ-1, REQ-4, REQ-6_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer | Task: Read `packages/backend/src/app.ts` to see how existing routes are mounted. Add imports and mount points for the three new route files: (1) Import friends routes, mount at `/api/friends`. (2) Import channels routes, mount at `/api/channels`. (3) Import messages routes, mount at `/api/messages`. Place them after existing route mounts but before error handling middleware. | Restrictions: Do NOT modify existing route mounts. Do NOT change middleware order. Use `.js` extension in imports. | Success: All three route groups accessible, existing routes unaffected._\n\n- [ ] 10. Add WebSocket handlers for chat, friend, and presence events\n  - Files: WebSocket handler files in `packages/backend/src/` (modify)\n  - Handle client messages: chat:send, chat:typing\n  - Add broadcast helpers: broadcastToUser, broadcastToChannel\n  - Wire presence manager on connect/disconnect\n  - Wire presence change events to friend broadcasting\n  - Purpose: Real-time communication for all social features\n  - _Leverage: Existing WS handler pattern, `plans/EPIC-6-friends-chat.md` Phases 6F.1, 6F.2, 6D.2_\n  - _Requirements: REQ-1, REQ-3, REQ-6, REQ-7_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in WebSocket real-time systems | Task: Find the WebSocket handler files in `packages/backend/src/` (likely `ws/` directory). Read them to understand the current message handling pattern. Make these changes: (1) On WebSocket connection: call `presenceManager.setOnline(userId)`. On close: call `presenceManager.setOffline(userId)`. (2) Add handler for `chat:send` messages: call `messageManager.sendMessage()`, then broadcast `chat:message` event to all channel members via `broadcastToChannel()`. (3) Add handler for `chat:typing` messages: broadcast `chat:typing` event to channel members (excluding sender). Use 3-second auto-clear timeout tracked in a Map. (4) Add `broadcastToUser(userId, message)` helper: find all WebSocket clients with matching userId, send JSON message. (5) Add `broadcastToChannel(channelId, message, excludeUserId?)` helper: get channel members, broadcast to each via broadcastToUser. (6) Listen on presenceManager 'presence:changed' event: when presence changes, get user's friends, broadcast `presence:update` to each friend. (7) On friend request created (hook from friendManager or call directly from route): broadcast `friend:request_received` to the recipient. Reference `plans/EPIC-6-friends-chat.md` Phases 6D.2, 6F.1, 6F.2. | Restrictions: Do NOT break existing console/server WS handlers. Add new cases to the existing switch statement. Typing timeouts must be cleaned up (prevent memory leaks). Use `.js` extension in imports. | Success: Chat messages broadcast in real-time, typing indicators work, presence broadcasts to friends on connect/disconnect, existing WS functionality preserved._\n\n- [ ] 11. Wire presence to Minecraft server player tracking\n  - Files: `packages/backend/src/services/server-manager.ts` or process handler (modify)\n  - Update presence to \"in-game\" when player joins a MC server, back to \"online\" when they leave\n  - Purpose: In-game presence detection\n  - _Leverage: Existing player join/leave log parsing, `plans/EPIC-6-friends-chat.md` Phase 6D.3_\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer | Task: Find where Minecraft server stdout is parsed for player join/leave events (likely in `packages/backend/src/services/process.ts` or `server-manager.ts` -- search for player join regex patterns like 'joined the game' or player list tracking). Add presence updates: (1) When a player joins a MC server, look up the user account by Minecraft username. If found, call `presenceManager.setInGame(userId, serverId, serverName)`. (2) When a player leaves, call `presenceManager.setOnline(userId)` (back to online, not in-game). (3) The Minecraft username to user account mapping requires a `minecraft_username` column on the users table. If this column doesn't exist from Epic 5, note it as a prerequisite but don't add a migration here (it can be added to the 007 migration in task 2 or via a separate ALTER TABLE). For now, implement the logic with a `getUserByMinecraftUsername()` helper in the user model that queries `WHERE minecraft_username = ?`. | Restrictions: This is best-effort -- if no user account is linked to the MC username, skip silently. Do NOT break existing player tracking. Use `.js` extension in imports. | Success: Player joining MC server updates their presence to in-game, leaving updates back to online, unlinked usernames silently ignored._\n\n- [ ] 12. Create frontend API clients for friends, channels, and messages\n  - Files: `packages/frontend/src/api/friends.ts` (new), `packages/frontend/src/api/channels.ts` (new), `packages/frontend/src/api/messages.ts` (new)\n  - Purpose: Frontend API layer for all social endpoints\n  - _Leverage: `packages/frontend/src/api/client.ts` for existing patterns_\n  - _Requirements: REQ-1, REQ-4, REQ-6_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in API client design | Task: Read `packages/frontend/src/api/client.ts` for existing fetch wrapper patterns (BASE_URL, headers, error handling). Create three API client files: (A) `friends.ts`: `getFriends()`, `getPendingRequests()`, `sendFriendRequest(username)`, `acceptFriendRequest(friendshipId)`, `rejectFriendRequest(friendshipId)`, `removeFriend(friendId)`. (B) `channels.ts`: `fetchChannels()`, `createTextChannel(name, description?)`, `getOrCreateDM(userId)`, `deleteChannel(channelId)`. (C) `messages.ts`: `fetchMessages(channelId, limit?, before?)`, `markAsRead(channelId, messageId)`. All functions include Authorization header from localStorage. Follow existing patterns for error handling (check res.ok, throw with message). | Restrictions: Use the same fetch pattern as existing API client. Include Authorization bearer token. Do NOT duplicate the auth header logic -- use the helper from client.ts if one was added in Epic 5. | Success: All API functions compile, match backend endpoint signatures, include auth headers._\n\n- [ ] 13. Create chatStore and friendStore (Zustand)\n  - Files: `packages/frontend/src/stores/chatStore.ts` (new), `packages/frontend/src/stores/friendStore.ts` (new)\n  - chatStore: channels, messages (Map by channelId), activeChannelId, typingUsers\n  - friendStore: friends list, pending requests, presence updates\n  - Purpose: State management for chat and social features\n  - _Leverage: `packages/frontend/src/stores/serverStore.ts` for Zustand patterns, `plans/EPIC-6-friends-chat.md` Phases 6G.1, 6G.2_\n  - _Requirements: REQ-2, REQ-4, REQ-6, REQ-7, REQ-8_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in Zustand state management | Task: Read `packages/frontend/src/stores/serverStore.ts` for the Zustand store pattern. Create two stores: (A) `chatStore.ts` with state: `channels: Channel[]`, `messages: Map<string, Message[]>` (channelId to messages), `activeChannelId: string | null`, `typingUsers: Map<string, Set<string>>` (channelId to set of userIds). Actions: `setChannels`, `addChannel`, `setActiveChannel`, `setMessages(channelId, msgs)`, `addMessage(msg)` (append to channel's array), `addTypingUser(channelId, userId)`, `removeTypingUser(channelId, userId)`. (B) `friendStore.ts` with state: `friends: Friend[]`, `requests: FriendRequest[]`. Actions: `setFriends`, `setRequests`, `updatePresence(userId, presence)` (update friend's presence in-place), `addRequest`, `removeRequest(requestId)`. Reference `plans/EPIC-6-friends-chat.md` Phases 6G.1, 6G.2. | Restrictions: Follow existing Zustand patterns exactly (create with set/get). Messages Map should handle missing channels gracefully. Do NOT use immer or other middleware. | Success: Both stores compile, actions update state correctly, Map-based message storage works._\n\n- [ ] 14. Wire WebSocket events to chat and friend stores\n  - Files: `packages/frontend/src/api/ws.ts` (modify)\n  - Handle new server events: chat:message, chat:typing, presence:update, friend:request_received, friend:status_changed\n  - Dispatch to chatStore and friendStore\n  - Purpose: Real-time updates from server to frontend state\n  - _Leverage: Existing WS event handling in `packages/frontend/src/api/ws.ts`, `plans/EPIC-6-friends-chat.md` Phase 6G.3_\n  - _Requirements: REQ-1, REQ-3, REQ-6, REQ-7, REQ-9_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in WebSocket event handling | Task: Read `packages/frontend/src/api/ws.ts` to understand the existing onmessage handler (likely a switch on msg.type). Add new cases: (1) `chat:message` -- call `useChatStore.getState().addMessage(msg.message)`. If msg.message.channelId !== activeChannelId, trigger desktop notification (see task 18). (2) `chat:typing` -- call `useChatStore.getState().addTypingUser(msg.channelId, msg.userId)`. Set 3-second timeout to call `removeTypingUser`. (3) `presence:update` -- call `useFriendStore.getState().updatePresence(msg.userId, msg.presence)`. (4) `friend:request_received` -- call `useFriendStore.getState().addRequest(msg.request)`. Trigger desktop notification. (5) `friend:status_changed` -- could trigger a full friends list refresh or handle inline. Reference `plans/EPIC-6-friends-chat.md` Phase 6G.3. | Restrictions: Do NOT break existing WS event handlers (console, status, stats). Import stores at module level. Typing timeout must clean up properly. Use `.js` extension in imports if needed. | Success: All new WS events dispatched to correct stores, existing events unaffected, typing auto-clears after 3s._\n\n- [ ] 15. Create PresenceBadge component\n  - Files: `packages/frontend/src/components/presence/PresenceBadge.tsx` (new)\n  - Small colored dot: green (online), amber (in-game), gray (offline)\n  - Purpose: Visual presence indicator used throughout the app\n  - _Leverage: Existing Tailwind component patterns_\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in UI components | Task: Create `packages/frontend/src/components/presence/PresenceBadge.tsx`. A small component that renders a colored dot based on presence status. Props: `status: PresenceStatus` ('online'|'offline'|'in-game'), optional `size?: 'sm'|'md'|'lg'` (default 'md'). Render a rounded-full div with: green-500 for online, amber-500 for in-game (with optional tooltip showing server name), slate-500 for offline. Sizes: sm=w-2 h-2, md=w-3 h-3, lg=w-4 h-4. Export as named export. | Restrictions: Pure presentational component. No state or side effects. Use Tailwind classes only. | Success: Badge renders correct color for each status, three size options work._\n\n- [ ] 16. Create chat UI components (MessageList, MessageInput, ChatSidebar, FriendsList, ChannelList, TypingIndicator, FriendRequestModal)\n  - Files: `packages/frontend/src/components/chat/` (new directory with multiple files)\n  - MessageList: virtualized message rendering with auto-scroll\n  - MessageInput: textarea with Enter to send, Shift+Enter for newline, typing indicator emission\n  - ChatSidebar: combined friends list + channel list sidebar\n  - FriendsList: friends with presence badges, sorted by status\n  - ChannelList: text channels + DMs with unread badges\n  - TypingIndicator: \"User is typing...\" display\n  - FriendRequestModal: send friend request by username, show pending requests\n  - Purpose: Complete chat UI component library\n  - _Leverage: @tanstack/react-virtual (existing), Tailwind patterns, `plans/EPIC-6-friends-chat.md` Phases 6G.4-6G.5_\n  - _Requirements: REQ-2, REQ-4, REQ-5, REQ-6, REQ-7, REQ-8_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in chat UIs and virtualized lists | Task: Install `react-markdown` (`npm install react-markdown -w frontend`). Also check if `date-fns` is installed (`npm ls date-fns -w frontend`); if not, install it. Create these components in `packages/frontend/src/components/chat/`: (1) `MessageList.tsx` -- uses @tanstack/react-virtual (useVirtualizer). Props: messages: Message[]. Render each message with avatar placeholder (first letter of username in circle), display name, relative timestamp (date-fns formatDistanceToNow), content rendered via react-markdown. Auto-scroll to bottom on new messages. (2) `MessageInput.tsx` -- Props: channelId: string. Textarea with Enter to send, Shift+Enter for newline. On change, emit chat:typing via WS (debounced to 3s). Max 4000 chars. Show markdown help text below. (3) `ChatSidebar.tsx` -- Props: channels, activeChannelId, onSelectChannel, friends. Two sections: text channels and DMs. Show unread count badges. (4) `FriendsList.tsx` -- Props: friends: Friend[]. Sort by presence (online/in-game first). Show PresenceBadge next to each name. Click opens DM. (5) `ChannelList.tsx` -- Props: channels (filtered by type), activeId, onSelect. Show # prefix for text channels, user avatar for DMs. Unread badge. (6) `TypingIndicator.tsx` -- Props: typingUsers: string[] (usernames). Show \"User is typing...\" or \"User1, User2 are typing...\" with animated dots. (7) `FriendRequestModal.tsx` -- Input field for username, send button. Below: list of pending requests with accept/reject buttons. Reference `plans/EPIC-6-friends-chat.md` Phases 6G.4-6G.5. All components use Tailwind dark theme (slate-800/900 backgrounds, white text). | Restrictions: Use @tanstack/react-virtual for MessageList (NOT window scrolling). Use react-markdown with default settings (no dangerouslySetInnerHTML). Match existing app color scheme. Use lucide-react for icons. Use sonner for toasts. | Success: All 7 components render correctly, virtualized list performs well, markdown renders safely, typing indicator shows/hides, friend requests can be sent and accepted._\n\n- [ ] 17. Create Chat page and wire up routing\n  - Files: `packages/frontend/src/pages/Chat.tsx` (new), `packages/frontend/src/App.tsx` (modify)\n  - Chat page: sidebar + message area layout, load channels on mount, load messages on channel select\n  - Add /chat route to App.tsx\n  - Purpose: Main chat view accessible from navigation\n  - _Leverage: Existing page patterns, `plans/EPIC-6-friends-chat.md` Phase 6G.6_\n  - _Requirements: REQ-4, REQ-5, REQ-6_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in page composition | Task: (1) Create `packages/frontend/src/pages/Chat.tsx`. Layout: flex row, full height. Left: ChatSidebar (fixed width ~280px). Right: flex column with channel header (name), MessageList (flex-1), TypingIndicator, MessageInput. On mount: fetch channels via API, fetch friends via API, set in stores. On activeChannelId change: fetch messages for that channel. Show \"Select a channel to start chatting\" placeholder when no channel is active. For DM channels, show the other user's display name as the header. (2) Read `packages/frontend/src/App.tsx`. Add a `/chat` route pointing to the Chat page, wrapped in ProtectedRoute. Add a navigation link to Chat in the app's nav/sidebar if one exists. Use default export for Chat.tsx. Reference `plans/EPIC-6-friends-chat.md` Phase 6G.6. | Restrictions: Wrap in ProtectedRoute (auth required). Match existing page layout patterns. Do NOT create a separate layout -- reuse existing app shell. | Success: Chat page loads channels and friends, selecting a channel loads messages, sending messages works in real-time, route is accessible from navigation._\n\n- [ ] 18. Add desktop notifications for messages and friend requests\n  - Files: `packages/frontend/src/api/ws.ts` (modify, may already be partially done in task 14)\n  - Show Tauri native notifications for messages in non-active channels and friend requests\n  - Request notification permission on app load\n  - Purpose: Desktop notifications for important events\n  - _Leverage: Tauri notification plugin, `plans/EPIC-6-friends-chat.md` Phase 6H_\n  - _Requirements: REQ-9_\n  - _Prompt: Implement the task for spec friends-text-chat, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in Tauri desktop integration | Task: Read `packages/frontend/src/api/ws.ts` to see the WebSocket event handler (may already have chat:message and friend:request_received handlers from task 14). Add notification logic: (1) At module initialization or app startup, check if running in Tauri (`window.__TAURI__` or similar). If so, use `@tauri-apps/plugin-notification` to check permission and request if not granted. If not Tauri (browser mode), use the browser Notification API as fallback. (2) On `chat:message` event: if the message's channelId is NOT the active channel (check chatStore.activeChannelId), send a notification with title=senderDisplayName, body=content truncated to 100 chars. (3) On `friend:request_received` event: send notification with title='Friend Request', body='{username} sent you a friend request'. (4) Create a helper `sendDesktopNotification(title, body)` that handles both Tauri and browser notification APIs. | Restrictions: Check if Tauri APIs are available before calling them (app may run in browser during dev). Do NOT show notification for messages in the currently active channel. Notification permission request should only happen once. | Success: Notifications appear for messages in non-active channels, friend requests trigger notifications, works in both Tauri and browser modes._\n",
  "fileStats": {
    "size": 36462,
    "lines": 165,
    "lastModified": "2026-02-12T00:26:37.313Z"
  },
  "comments": []
}
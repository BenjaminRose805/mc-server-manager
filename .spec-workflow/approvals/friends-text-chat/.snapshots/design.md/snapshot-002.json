{
  "id": "snapshot_1770855744108_2umlxe39j",
  "approvalId": "approval_1770855719286_durehcrlh",
  "approvalTitle": "EPIC-6: Friends & Text Chat â€” Design Document",
  "version": 2,
  "timestamp": "2026-02-12T00:22:24.108Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document -- Friends & Text Chat\n\n## Overview\n\nAdd a social layer to MC Server Manager: friend system with presence tracking, direct messages, text channels, typing indicators, unread tracking, and desktop notifications. All real-time communication extends the existing WebSocket infrastructure with new message types. Message persistence uses the existing SQLite database. The UI adds a chat page with a sidebar (friends + channels) and a message view.\n\n## Steering Document Alignment\n\nNo steering docs exist. This design follows existing project conventions (Express routes, Zod validation, SQLite models, Zustand stores, Tailwind UI, WebSocket message protocol with `type` discriminator).\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **WebSocket server (`packages/backend/src/ws/`)**: Already handles real-time messaging for console output. Extended with new message types for chat, presence, and friend events. Same connection, same protocol pattern.\n- **WebSocket client (`packages/frontend/src/api/ws.ts`)**: `WsClient` with auto-reconnect. Extended to handle new server message types and dispatch to new stores.\n- **Zustand store pattern (`packages/frontend/src/stores/serverStore.ts`)**: Pattern for new `chatStore.ts` and `friendStore.ts`. WebSocket events write directly to stores.\n- **@tanstack/react-virtual**: Already used for console output virtualization. Reused for message list rendering.\n- **Auth middleware (`packages/backend/src/middleware/auth.ts`)**: All new routes require `requireAuth`. Channel creation requires `requireAdminOrOwner`.\n- **Error classes (`packages/backend/src/utils/errors.ts`)**: `NotFoundError`, `ConflictError`, `ForbiddenError` used in friend/channel/message services.\n- **Zod validation**: All new route handlers use Zod schemas following existing patterns.\n- **Pino logger**: Existing logger for friend/chat event logging.\n- **Tauri notification plugin**: Available from Epic 1 for desktop notifications.\n\n### Integration Points\n- **`users` table**: Foreign key target for friendships, channel_members, messages. Optional `minecraft_username` column added for in-game presence detection.\n- **WebSocket connection lifecycle**: Presence set online/offline on connect/disconnect. User ID already attached to socket from Epic 5 auth.\n- **Server process player tracking**: Parse player join/leave log lines to update presence to \"in-game\".\n- **Express app (`app.ts`)**: Mount new routes for friends, channels, messages.\n- **Frontend routing (`App.tsx`)**: Add `/chat` route for chat page.\n\n## Architecture\n\n### Message Flow\n\n```\nUser A types message in channel\n  --> Client sends WS: { type: 'chat:send', channelId, content }\n  --> Server validates (member check, content length)\n  --> Server persists to messages table (with sender info JOIN)\n  --> Server broadcasts to all channel members:\n      { type: 'chat:message', message: { id, channelId, senderId, senderUsername, content, createdAt } }\n  --> Each recipient's WsClient dispatches to chatStore.addMessage()\n  --> React re-renders MessageList with new message\n  --> If recipient is not viewing that channel: unread count increments + desktop notification\n```\n\n### Presence Flow\n\n```\nUser connects via WebSocket\n  --> Server: presenceManager.setOnline(userId)\n  --> Server broadcasts to all friends: { type: 'presence:update', userId, presence: { status: 'online' } }\n  --> Friends' friendStore.updatePresence() updates UI\n\nUser joins MC server (detected via log parsing)\n  --> Server: presenceManager.setInGame(userId, serverId, serverName)\n  --> Broadcast to friends: { type: 'presence:update', ..., presence: { status: 'in-game', details: { serverName } } }\n\nUser disconnects\n  --> Server: presenceManager.setOffline(userId)\n  --> Broadcast to friends: { type: 'presence:update', ..., presence: { status: 'offline' } }\n```\n\n### Friend Request Flow\n\n```\nUser A sends request to User B (by username)\n  --> POST /api/friends/request { username: 'B' }\n  --> Server validates (not self, not duplicate, user exists)\n  --> Insert friendship (user_id=A, friend_id=B, status='pending')\n  --> WS broadcast to B: { type: 'friend:request_received', request: { id, fromUser: {...} } }\n  --> B sees notification + pending request in UI\n\nUser B accepts\n  --> POST /api/friends/:friendshipId/accept\n  --> Update status to 'accepted'\n  --> Insert reverse edge (user_id=B, friend_id=A, status='accepted')\n  --> WS broadcast to both: { type: 'friend:status_changed', status: 'accepted' }\n```\n\n### Modular Design Principles\n- **Unified Channel Model**: Both DMs and text channels are stored in the same `channels` table with a `type` discriminator. Unified message storage, rendering, and unread tracking.\n- **Service Separation**: `FriendManager`, `PresenceManager`, `ChannelManager`, `MessageManager` are each in separate files with single responsibilities.\n- **Store Separation**: `chatStore` (channels, messages, typing) and `friendStore` (friends, presence, requests) are separate Zustand stores.\n- **Component Isolation**: Chat components (`MessageList`, `MessageInput`, `ChatSidebar`, `FriendsList`, `ChannelList`, `PresenceBadge`, `TypingIndicator`) are small, focused, and reusable.\n- **WebSocket Protocol Extension**: New message types follow the existing `{ type: string, ...payload }` discriminated union pattern.\n\n## Components and Interfaces\n\n### Component 1: Friendship Model (`packages/backend/src/models/friendship.ts`)\n- **Purpose**: CRUD for friendships table -- create request, update status, create reverse edge, query friends/pending, delete both directions\n- **Interfaces**: `createFriendRequest(userId, friendId)`, `updateFriendshipStatus(id, status)`, `createReverseFriendship(id)`, `getFriendship(userId, friendId)`, `getFriends(userId)`, `getPendingRequests(userId)`, `deleteFriendship(userId, friendId)`\n- **Dependencies**: Database module, nanoid\n- **Reuses**: Existing model patterns (prepared statements, snake_case to camelCase mapping)\n\n### Component 2: FriendManager Service (`packages/backend/src/services/friend-manager.ts`)\n- **Purpose**: Business logic for friend requests -- validation, duplicate checking, accept/reject flow\n- **Interfaces**: `sendFriendRequest(fromUserId, toUsername)`, `acceptFriendRequest(userId, friendshipId)`, `rejectFriendRequest(userId, friendshipId)`, `removeFriend(userId, friendId)`, `getFriends(userId): Friend[]`, `getPendingRequests(userId): FriendRequest[]`\n- **Dependencies**: Friendship model, user model, PresenceManager, error classes\n- **Reuses**: Error classes (ConflictError, NotFoundError, ForbiddenError)\n\n### Component 3: PresenceManager Service (`packages/backend/src/services/presence-manager.ts`)\n- **Purpose**: In-memory presence tracking (online/offline/in-game) with event emission for broadcasting\n- **Interfaces**: `setOnline(userId)`, `setOffline(userId)`, `setInGame(userId, serverId, serverName)`, `getPresence(userId): Presence`, `getAllPresences(): Map`\n- **Dependencies**: EventEmitter (Node built-in), friendship model (for broadcasting to friends)\n- **Reuses**: None (new in-memory service, extends EventEmitter)\n\n### Component 4: Channel Model (`packages/backend/src/models/channel.ts`)\n- **Purpose**: CRUD for channels and channel_members tables\n- **Interfaces**: `createChannel(type, name, description, createdBy)`, `getChannelById(id)`, `getTextChannels()`, `getUserChannels(userId)`, `getDMChannel(user1Id, user2Id)`, `addChannelMember(channelId, userId)`, `getChannelMembers(channelId)`, `deleteChannel(id)`\n- **Dependencies**: Database module, nanoid\n- **Reuses**: Existing model patterns\n\n### Component 5: Message Model (`packages/backend/src/models/message.ts`)\n- **Purpose**: CRUD for messages and message_reads tables, with pagination and unread counting\n- **Interfaces**: `createMessage(channelId, senderId, content, type)`, `getMessageById(id)`, `getChannelMessages(channelId, limit, before?)`, `updateMessageRead(channelId, userId, messageId)`, `getUnreadCount(channelId, userId)`\n- **Dependencies**: Database module, nanoid\n- **Reuses**: Existing model patterns. Messages JOIN with users table for sender info.\n\n### Component 6: ChannelManager Service (`packages/backend/src/services/channel-manager.ts`)\n- **Purpose**: Channel business logic -- create text channels (admin only, auto-add all members), get-or-create DM channels (idempotent), delete text channels\n- **Interfaces**: `createTextChannel(name, description, createdBy)`, `getOrCreateDMChannel(user1Id, user2Id)`, `getUserChannels(userId)`, `deleteTextChannel(channelId, userId)`\n- **Dependencies**: Channel model, user model, error classes\n- **Reuses**: Error classes\n\n### Component 7: MessageManager Service (`packages/backend/src/services/message-manager.ts`)\n- **Purpose**: Message business logic -- send (with membership validation), get with pagination, mark read\n- **Interfaces**: `sendMessage(channelId, senderId, content): Message`, `getMessages(channelId, userId, limit, before?)`, `markRead(channelId, userId, messageId)`\n- **Dependencies**: Message model, channel model, error classes\n- **Reuses**: Error classes\n\n### Component 8: Friend Routes (`packages/backend/src/routes/friends.ts`)\n- **Purpose**: REST API for friend operations\n- **Endpoints**: `POST /api/friends/request`, `POST /api/friends/:id/accept`, `POST /api/friends/:id/reject`, `DELETE /api/friends/:id`, `GET /api/friends`, `GET /api/friends/requests`\n- **Dependencies**: FriendManager, auth middleware, Zod\n- **Reuses**: Route handler patterns\n\n### Component 9: Channel Routes (`packages/backend/src/routes/channels.ts`)\n- **Purpose**: REST API for channel CRUD\n- **Endpoints**: `POST /api/channels`, `GET /api/channels`, `POST /api/channels/dm/:userId`, `DELETE /api/channels/:id`\n- **Dependencies**: ChannelManager, auth middleware, Zod\n- **Reuses**: Route handler patterns\n\n### Component 10: Message Routes (`packages/backend/src/routes/messages.ts`)\n- **Purpose**: REST API for message history and read tracking\n- **Endpoints**: `GET /api/messages/:channelId`, `POST /api/messages/:channelId/read`\n- **Dependencies**: MessageManager, auth middleware, Zod\n- **Reuses**: Route handler patterns\n\n### Component 11: WebSocket Chat/Friend/Presence Handlers (modify existing WS handler)\n- **Purpose**: Handle real-time messages: `chat:send`, `chat:typing`, `friend:accept/reject/remove`, presence broadcasts\n- **Interfaces**: Extended `handleClientMessage()` switch cases, `broadcastToUser()`, `broadcastToChannel()` helper functions\n- **Dependencies**: FriendManager, MessageManager, PresenceManager, channel model\n- **Reuses**: Existing WebSocket message handling pattern\n\n### Component 12: Chat Store (`packages/frontend/src/stores/chatStore.ts`)\n- **Purpose**: Zustand store for channels, messages (per-channel map), active channel, typing users\n- **Interfaces**: `setChannels`, `addChannel`, `setActiveChannel`, `setMessages`, `addMessage`, `addTypingUser`, `removeTypingUser`\n- **Dependencies**: Zustand\n- **Reuses**: Store pattern from serverStore.ts\n\n### Component 13: Friend Store (`packages/frontend/src/stores/friendStore.ts`)\n- **Purpose**: Zustand store for friends list, pending requests, and presence updates\n- **Interfaces**: `setFriends`, `setRequests`, `updatePresence`, `addRequest`, `removeRequest`\n- **Dependencies**: Zustand\n- **Reuses**: Store pattern from serverStore.ts\n\n### Component 14: Chat Page (`packages/frontend/src/pages/Chat.tsx`)\n- **Purpose**: Main chat view with sidebar + message area\n- **Dependencies**: ChatSidebar, MessageList, MessageInput, chatStore, channel/message API clients\n- **Reuses**: Page layout patterns\n\n### Component 15: Chat UI Components (`packages/frontend/src/components/chat/`)\n- **Purpose**: `MessageList` (virtualized), `MessageInput` (markdown + Enter to send), `ChatSidebar`, `FriendsList`, `ChannelList`, `FriendRequestModal`, `TypingIndicator`\n- **Dependencies**: @tanstack/react-virtual, react-markdown (new dep), chatStore, friendStore, WS client\n- **Reuses**: @tanstack/react-virtual (already used for console), Tailwind component patterns\n\n### Component 16: PresenceBadge (`packages/frontend/src/components/presence/PresenceBadge.tsx`)\n- **Purpose**: Small colored dot indicating online (green), in-game (amber), offline (gray)\n- **Dependencies**: None (pure presentational)\n- **Reuses**: Tailwind styling patterns\n\n## Data Models\n\n### friendships table\n```sql\nCREATE TABLE friendships (\n  id            TEXT PRIMARY KEY,\n  user_id       TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  friend_id     TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  status        TEXT NOT NULL DEFAULT 'pending',   -- pending | accepted | rejected\n  created_at    TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at    TEXT NOT NULL DEFAULT (datetime('now')),\n  UNIQUE(user_id, friend_id),\n  CHECK(user_id != friend_id),\n  CHECK(status IN ('pending', 'accepted', 'rejected'))\n);\n```\nBidirectional storage: when A befriends B, two rows exist (A->B and B->A) both with status='accepted'. Enables efficient `WHERE user_id = ? AND status = 'accepted'` queries.\n\n### channels table\n```sql\nCREATE TABLE channels (\n  id            TEXT PRIMARY KEY,\n  type          TEXT NOT NULL DEFAULT 'text',       -- text | dm\n  name          TEXT,                                -- NULL for DMs\n  description   TEXT,\n  created_by    TEXT REFERENCES users(id) ON DELETE SET NULL,\n  created_at    TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at    TEXT NOT NULL DEFAULT (datetime('now')),\n  CHECK(type IN ('text', 'dm')),\n  CHECK((type = 'text' AND name IS NOT NULL) OR (type = 'dm' AND name IS NULL))\n);\n```\n\n### channel_members table\n```sql\nCREATE TABLE channel_members (\n  channel_id    TEXT NOT NULL REFERENCES channels(id) ON DELETE CASCADE,\n  user_id       TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  joined_at     TEXT NOT NULL DEFAULT (datetime('now')),\n  PRIMARY KEY (channel_id, user_id)\n);\n```\n\n### messages table\n```sql\nCREATE TABLE messages (\n  id            TEXT PRIMARY KEY,\n  channel_id    TEXT NOT NULL REFERENCES channels(id) ON DELETE CASCADE,\n  sender_id     TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  content       TEXT NOT NULL,\n  type          TEXT NOT NULL DEFAULT 'text',       -- text | system\n  created_at    TEXT NOT NULL DEFAULT (datetime('now')),\n  edited_at     TEXT,\n  CHECK(type IN ('text', 'system')),\n  CHECK(length(content) > 0 AND length(content) <= 4000)\n);\n```\nIndexed on `(channel_id, created_at DESC)` for paginated queries.\n\n### message_reads table\n```sql\nCREATE TABLE message_reads (\n  channel_id        TEXT NOT NULL REFERENCES channels(id) ON DELETE CASCADE,\n  user_id           TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  last_read_msg_id  TEXT NOT NULL REFERENCES messages(id) ON DELETE CASCADE,\n  updated_at        TEXT NOT NULL DEFAULT (datetime('now')),\n  PRIMARY KEY (channel_id, user_id)\n);\n```\n\n### Shared TypeScript Types\n\n```typescript\n// Friend types\nexport type FriendshipStatus = 'pending' | 'accepted' | 'rejected';\nexport type PresenceStatus = 'online' | 'offline' | 'in-game';\n\nexport interface Friendship { id, userId, friendId, status, createdAt, updatedAt }\nexport interface Presence { userId, status, details?: { serverId?, serverName? }, lastSeen }\nexport interface Friend { id, username, displayName, presence }\nexport interface FriendRequest { id, fromUser: { id, username, displayName }, createdAt }\n\n// Chat types\nexport type ChannelType = 'text' | 'dm';\nexport type MessageType = 'text' | 'system';\n\nexport interface Channel { id, type, name, description, createdBy, createdAt, updatedAt, unreadCount?, lastMessage?, members? }\nexport interface ChannelMember { userId, username, displayName, joinedAt }\nexport interface Message { id, channelId, senderId, senderUsername, senderDisplayName, content, type, createdAt, editedAt }\nexport interface MessageRead { channelId, userId, lastReadMessageId, updatedAt }\nexport interface TypingEvent { channelId, userId, username }\n\n// WebSocket message types (client -> server)\nChatSendMessage: { type: 'chat:send', channelId, content }\nChatTypingMessage: { type: 'chat:typing', channelId }\n\n// WebSocket message types (server -> client)\nChatMessageEvent: { type: 'chat:message', message }\nChatTypingEvent: { type: 'chat:typing', channelId, userId, username }\nPresenceUpdateEvent: { type: 'presence:update', userId, presence }\nFriendRequestReceivedEvent: { type: 'friend:request_received', request }\nFriendStatusChangedEvent: { type: 'friend:status_changed', friendshipId, status }\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Friend request to non-existent user**\n   - **Handling**: Return 404 NotFoundError. FriendManager checks user exists by username.\n   - **User Impact**: \"User not found\" error in UI.\n\n2. **Duplicate friend request**\n   - **Handling**: Return 409 ConflictError with specific message (already friends, already pending, reverse pending).\n   - **User Impact**: \"Already friends\" / \"Friend request already sent\" / \"This user has already sent you a request\" toast.\n\n3. **Message in channel user is not a member of**\n   - **Handling**: Return 403 ForbiddenError. MessageManager checks channel membership before persisting.\n   - **User Impact**: \"Not a member of this channel\" error (should not happen in normal UI flow).\n\n4. **Message exceeds 4000 character limit**\n   - **Handling**: Zod validation rejects at route level. DB CHECK constraint as safety net.\n   - **User Impact**: Character counter in input prevents submission. Error toast if bypassed.\n\n5. **DM to non-friend**\n   - **Handling**: ChannelManager checks friendship exists before creating DM channel. Return 403.\n   - **User Impact**: DM option only shown for friends in UI.\n\n6. **WebSocket disconnect during chat**\n   - **Handling**: Auto-reconnect (existing). On reconnect, re-fetch recent messages for active channel. Presence re-established.\n   - **User Impact**: Brief \"Reconnecting...\" indicator, then seamless recovery.\n\n7. **Text channel creation by non-admin**\n   - **Handling**: ChannelManager checks user role. Return 403.\n   - **User Impact**: Create channel button only visible to admin/owner.\n\n## File Structure\n\n### New Files\n```\npackages/backend/migrations/007_friends_chat.sql          # All social tables\npackages/backend/src/models/friendship.ts                  # Friendship DB queries\npackages/backend/src/models/channel.ts                     # Channel + member DB queries\npackages/backend/src/models/message.ts                     # Message + read DB queries\npackages/backend/src/services/friend-manager.ts            # Friend request logic\npackages/backend/src/services/presence-manager.ts          # In-memory presence tracking\npackages/backend/src/services/channel-manager.ts           # Channel business logic\npackages/backend/src/services/message-manager.ts           # Message business logic\npackages/backend/src/routes/friends.ts                     # Friend REST API\npackages/backend/src/routes/channels.ts                    # Channel REST API\npackages/backend/src/routes/messages.ts                    # Message REST API\npackages/frontend/src/stores/chatStore.ts                  # Chat Zustand store\npackages/frontend/src/stores/friendStore.ts                # Friend Zustand store\npackages/frontend/src/pages/Chat.tsx                       # Main chat page\npackages/frontend/src/components/chat/ChatSidebar.tsx      # Sidebar (friends + channels)\npackages/frontend/src/components/chat/MessageList.tsx      # Virtualized message list\npackages/frontend/src/components/chat/MessageInput.tsx     # Markdown input\npackages/frontend/src/components/chat/FriendsList.tsx      # Friends with presence\npackages/frontend/src/components/chat/ChannelList.tsx      # Text channel list\npackages/frontend/src/components/chat/FriendRequestModal.tsx  # Send/accept requests\npackages/frontend/src/components/chat/TypingIndicator.tsx  # \"User is typing...\"\npackages/frontend/src/components/presence/PresenceBadge.tsx # Online/offline badge\npackages/frontend/src/api/friends.ts                       # Friend API client\npackages/frontend/src/api/channels.ts                      # Channel API client\npackages/frontend/src/api/messages.ts                      # Message API client\n```\n\n### Modified Files\n```\nshared/src/index.ts                                        # Export friend, chat, WS types\npackages/backend/src/app.ts                                # Mount friend/channel/message routes\npackages/backend/src/ws/handlers.ts (or equivalent)        # Add chat/friend/presence WS handlers\npackages/backend/src/ws/index.ts (or equivalent)           # Wire presence on connect/disconnect\npackages/backend/src/services/server-manager.ts            # Update presence on player join/leave\npackages/frontend/src/api/ws.ts                            # Handle new WS events, dispatch to stores\npackages/frontend/src/App.tsx                              # Add /chat route\n```\n\n## Dependencies\n\n### New Backend npm Packages\n- None required. All functionality uses existing packages (ws, express, better-sqlite3, zod, nanoid, pino).\n\n### New Frontend npm Packages\n- `react-markdown` -- Render basic Markdown in messages (bold, italic, code, links).\n- `date-fns` -- Format message timestamps as relative time (\"2 minutes ago\"). May already be available.\n\n## Testing Strategy\n\n### Unit Testing\n- No automated test framework exists. Manual verification.\n- Key verification: friend request lifecycle, message persistence, presence state machine, unread counting.\n\n### Integration Testing\n- **Friend system**: Send request -> accept -> appears in both friends lists -> remove -> disappears from both\n- **Friend rejection**: Send request -> reject -> request removed, no friendship created\n- **Presence**: Connect -> online broadcast to friends -> join MC server -> in-game broadcast -> disconnect -> offline broadcast\n- **Text channels**: Admin creates -> all members see it -> send message -> all members receive via WS\n- **DMs**: Open DM with friend -> creates channel -> send message -> friend receives -> reply works -> re-open DM returns same channel\n- **Typing**: Type in channel -> other members see indicator -> stops after 3s\n- **Unread**: Message arrives in inactive channel -> badge count increments -> open channel -> count resets\n- **Pagination**: Send 100+ messages -> scroll up -> loads older batch -> messages in order\n- **Notifications**: Message in non-active channel -> desktop notification appears\n\n### End-to-End Testing\n- Full social flow: Register two users -> send friend request -> accept -> open DM -> send messages back and forth -> see presence changes -> create text channel -> chat in channel\n- Reconnect test: Disconnect network -> reconnect -> presence restored, missed messages loaded\n",
  "fileStats": {
    "size": 22769,
    "lines": 390,
    "lastModified": "2026-02-12T00:21:52.449Z"
  },
  "comments": []
}
{
  "id": "snapshot_1770855579637_j40bxmbxo",
  "approvalId": "approval_1770855502926_oz1wotufd",
  "approvalTitle": "EPIC-6: Friends & Text Chat â€” Requirements Document",
  "version": 2,
  "timestamp": "2026-02-12T00:19:39.637Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document -- Friends & Text Chat\n\n## Introduction\n\nAdd social features to the MC Server Manager community platform: a friend system with presence tracking, direct messages, and text channels. This transforms the application from a server management tool into a lightweight social hub where gaming groups can coordinate, chat, and see who's online and what they're playing.\n\nThis epic extends the existing WebSocket infrastructure (already handling console output) with new message types for chat, presence, and friend events. No new transport layer is needed.\n\n## Alignment with Product Vision\n\nAfter Epic 5 (Multi-User Foundation), users can authenticate and connect to a shared community server. Epic 6 adds the social layer: friends, presence awareness, and real-time text communication. This makes the platform a natural gathering place for gaming groups rather than just a server dashboard.\n\nPrerequisite for: Epic 9 (Mod Sync -- friend-based server sharing).\nDependencies: Epic 5 (Multi-User Foundation) for user accounts and authentication.\n\n---\n\n## Requirements\n\n### REQ-1: Friend Requests\n\n**User Story:** As a user, I want to send friend requests to other community members, so that I can build my friends list and see when they are online.\n\n#### Acceptance Criteria\n\n1. WHEN a user sends a friend request by username THEN the system SHALL create a pending friendship record and notify the recipient in real time via WebSocket.\n2. WHEN a user receives a friend request THEN the system SHALL display it in a pending requests list and show a desktop notification.\n3. WHEN the recipient accepts a friend request THEN the system SHALL create a bidirectional friendship (both directions stored) and notify both users.\n4. WHEN the recipient rejects a friend request THEN the system SHALL mark the request as rejected and notify the sender.\n5. WHEN a user sends a friend request to themselves THEN the system SHALL reject it with a clear error.\n6. WHEN a user sends a duplicate friend request (already pending, accepted, or reverse pending) THEN the system SHALL reject it with a specific error message.\n\n---\n\n### REQ-2: Friends List\n\n**User Story:** As a user, I want to see my friends list with their online status, so that I can know who is available to play.\n\n#### Acceptance Criteria\n\n1. WHEN a user views their friends list THEN the system SHALL display all accepted friends with their username, display name, and current presence status.\n2. WHEN a user removes a friend THEN the system SHALL delete both direction friendship records and notify the other user.\n3. WHEN the friends list is displayed THEN friends SHALL be sorted by presence status (online/in-game first, then offline) and alphabetically within each group.\n\n---\n\n### REQ-3: Presence Tracking\n\n**User Story:** As a user, I want to see whether my friends are online, offline, or in a Minecraft game, so that I can coordinate gameplay.\n\n#### Acceptance Criteria\n\n1. WHEN a user connects via WebSocket THEN the system SHALL set their presence to \"online\" and broadcast the update to all their friends.\n2. WHEN a user disconnects (WebSocket close) THEN the system SHALL set their presence to \"offline\" and broadcast the update to all their friends.\n3. WHEN a user joins a Minecraft server (detected via player join log parsing) THEN the system SHALL set their presence to \"in-game\" with the server name, and broadcast to friends.\n4. WHEN a user leaves a Minecraft server THEN the system SHALL set their presence back to \"online\" and broadcast to friends.\n5. WHEN a user views a friend's profile THEN the system SHALL display a presence indicator badge (green for online, yellow for in-game, gray for offline).\n6. WHEN the application reconnects after a network interruption THEN the system SHALL re-establish correct presence state for all friends.\n\n---\n\n### REQ-4: Text Channels\n\n**User Story:** As an admin, I want to create text channels for the community, so that members have shared spaces to chat by topic.\n\n#### Acceptance Criteria\n\n1. WHEN an owner or admin creates a text channel THEN the system SHALL create it with a name and optional description, and automatically add all community members.\n2. WHEN a new user joins the community THEN they SHALL be automatically added to all existing text channels.\n3. WHEN a user views the channel list THEN the system SHALL display all text channels they are a member of, with unread message counts.\n4. WHEN an owner or admin deletes a text channel THEN the system SHALL remove it and all associated messages and read markers.\n5. WHEN a member attempts to create or delete a text channel THEN the system SHALL deny the action with a 403 error.\n\n---\n\n### REQ-5: Direct Messages\n\n**User Story:** As a user, I want to send direct messages to my friends, so that we can have private conversations.\n\n#### Acceptance Criteria\n\n1. WHEN a user initiates a DM with a friend THEN the system SHALL find or create a DM channel between the two users.\n2. WHEN a DM channel is created THEN it SHALL have exactly two members and no public name (displayed as the other user's name).\n3. WHEN a user views their channel list THEN DM channels SHALL appear alongside text channels, showing the other user's display name and presence.\n4. DM channels SHALL NOT be deletable (conversations are permanent).\n5. WHEN a user sends a DM to a non-friend THEN the system SHALL deny the action (friendship required for DMs).\n\n---\n\n### REQ-6: Messaging\n\n**User Story:** As a user, I want to send and receive text messages in channels and DMs, so that I can communicate with my community.\n\n#### Acceptance Criteria\n\n1. WHEN a user sends a message in a channel THEN the system SHALL persist it and broadcast it to all channel members in real time via WebSocket.\n2. WHEN a user opens a channel THEN the system SHALL load the most recent 50 messages and support pagination (load more on scroll up).\n3. WHEN a message is received THEN it SHALL display the sender's display name, avatar placeholder, message content, and relative timestamp.\n4. Messages SHALL support basic Markdown: **bold**, *italic*, `inline code`, and [links](url).\n5. Messages SHALL have a maximum length of 4000 characters.\n6. WHEN a message is sent THEN the channel's `updated_at` timestamp SHALL be updated for sorting the channel list.\n\n---\n\n### REQ-7: Typing Indicators\n\n**User Story:** As a user, I want to see when someone is typing in a channel, so that I know a response is coming.\n\n#### Acceptance Criteria\n\n1. WHEN a user starts typing in a channel THEN a typing indicator event SHALL be broadcast to other channel members via WebSocket.\n2. Typing events SHALL be debounced on the client (maximum 1 event per 3 seconds).\n3. The typing indicator SHALL automatically clear after 3 seconds of no typing events.\n4. WHEN multiple users are typing THEN the indicator SHALL show all typing usernames.\n5. The typing indicator SHALL NOT be shown for the user's own typing.\n\n---\n\n### REQ-8: Unread Tracking\n\n**User Story:** As a user, I want to see which channels have unread messages, so that I can quickly find new conversations.\n\n#### Acceptance Criteria\n\n1. WHEN a user opens a channel THEN the system SHALL mark the latest message as read for that user.\n2. WHEN a message arrives in a channel the user is not currently viewing THEN the unread count for that channel SHALL increment.\n3. WHEN the user views the channel list THEN each channel SHALL display its unread message count (badge).\n4. WHEN the user opens a channel with unread messages THEN the unread count SHALL reset to zero.\n\n---\n\n### REQ-9: Desktop Notifications\n\n**User Story:** As a user, I want to receive desktop notifications for new messages and friend requests, so that I don't miss important events.\n\n#### Acceptance Criteria\n\n1. WHEN a message arrives in a channel the user is NOT currently viewing THEN a desktop notification SHALL appear showing the sender name and message preview (first 100 characters).\n2. WHEN a friend request is received THEN a desktop notification SHALL appear showing the requester's username.\n3. WHEN the app is in the foreground and the user is viewing the active channel THEN no notification SHALL be shown for messages in that channel.\n4. Desktop notifications SHALL use the Tauri notification plugin (native OS notifications).\n5. WHEN the user has not granted notification permission THEN the app SHALL request it once on first load.\n\n---\n\n## Non-Functional Requirements\n\n### Performance\n- Message list rendering SHALL use virtualization (@tanstack/react-virtual) to handle large message histories without performance degradation.\n- Message pagination SHALL load 50 messages per batch. Older messages loaded on scroll.\n- The `messages` table SHALL have a composite index on `(channel_id, created_at DESC)` for efficient paginated queries.\n- Presence updates SHALL be broadcast only to friends (not all users) to minimize WebSocket traffic.\n- Typing indicator events SHALL NOT be persisted in the database.\n\n### Scalability\n- The system is designed for small communities (10-50 users). No message broker or Redis required.\n- All message persistence uses the existing SQLite database.\n- WebSocket broadcasts use in-process fan-out (iterate connected clients).\n\n### Security\n- Users can only send messages in channels they are members of.\n- DMs require an accepted friendship.\n- Only owners/admins can create and delete text channels.\n- Message content is validated (non-empty, max 4000 chars) before persistence.\n- Markdown rendering uses `react-markdown` with default sanitization (no raw HTML injection).\n- All chat/friend/presence API endpoints require JWT authentication (from Epic 5).\n\n### Reliability\n- WebSocket auto-reconnect (already implemented) re-establishes presence and chat subscriptions.\n- On reconnect, the client re-fetches recent messages to catch up on missed ones.\n- Presence state is derived from WebSocket connection state (source of truth) -- no stale state possible.\n- Bidirectional friendship storage ensures consistent friend queries regardless of who initiated.\n\n### User Experience\n- Friends are sorted by presence (online/in-game first) for quick visibility.\n- Channel list sorted by most recent activity.\n- Enter key sends messages, Shift+Enter for newlines.\n- Markdown formatting help shown below the input field.\n- Presence badges use intuitive colors: green (online), yellow/amber (in-game), gray (offline).\n",
  "fileStats": {
    "size": 10412,
    "lines": 180,
    "lastModified": "2026-02-12T00:18:17.099Z"
  },
  "comments": []
}
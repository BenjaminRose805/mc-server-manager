{
  "id": "snapshot_1770856785248_4t03093g0",
  "approvalId": "approval_1770856785236_ddowux7js",
  "approvalTitle": "EPIC-7: Shared Minecraft Servers â€” Tasks Document",
  "version": 1,
  "timestamp": "2026-02-12T00:39:45.248Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document -- Shared Minecraft Servers\n\n- [ ] 1. Add shared server and permission types to shared package\n  - Files: `shared/src/index.ts` (modify)\n  - Add types: `ServerPermissionLevel`, `ServerPermission`, `SharedServerInfo`, `ServerSharingSettings`, `GrantPermissionRequest`, `JoinServerResponse`\n  - Add WebSocket message types for shared server events: `SharedServerStatusEvent`, `SharedServerStatsEvent`\n  - Purpose: Foundation types for the entire shared server system\n  - _Leverage: `shared/src/index.ts` for existing type patterns, `.spec-workflow/specs/shared-minecraft-servers/design.md` Data Models section_\n  - _Requirements: REQ-1, REQ-2, REQ-3, REQ-4, REQ-7_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: TypeScript Developer with expertise in shared type definitions for monorepo packages | Task: Read `shared/src/index.ts` to understand existing type patterns and exports (especially `ServerStatus`, `ServerType`, and any existing WebSocket message types). Add all shared server types from `.spec-workflow/specs/shared-minecraft-servers/design.md` Data Models section: (1) `ServerPermissionLevel` type alias: `'view' | 'join' | 'manage' | 'admin'`. (2) `ServerPermission` interface with fields: id (string), serverId (string), userId (string), permission (ServerPermissionLevel), grantedBy (string), grantedAt (number). (3) `SharedServerInfo` interface with fields: id, sharedName, sharedDescription (string or null), status (ServerStatus), playerCount (number), maxPlayers (number), version (string), type (ServerType), onlinePlayers (string array), myPermission (ServerPermissionLevel or null), sharedAt (number). (4) `ServerSharingSettings` interface: shared (boolean), sharedName (string), sharedDescription (string or null). (5) `GrantPermissionRequest` interface: userId (string), permission (ServerPermissionLevel). (6) `JoinServerResponse` interface: address (string), port (number), version (string), requiresMods (boolean). (7) WebSocket event types: `SharedServerStatusEvent` with type 'shared:status', serverId, status fields. `SharedServerStatsEvent` with type 'shared:stats', serverId, playerCount, maxPlayers, onlinePlayers fields. Export all types. | Restrictions: Do NOT remove or rename any existing types. Do NOT modify existing WebSocket message type unions -- extend them or create new ones. | Success: All types compile, all exported, existing types unchanged, `npm run build -w shared` succeeds._\n\n- [ ] 2. Create database migration for shared servers\n  - Files: `packages/backend/migrations/008_shared_servers.sql` (new)\n  - ALTER servers table with sharing columns, CREATE server_permissions table with indexes\n  - Purpose: Database schema for server sharing and per-user permissions\n  - _Leverage: `packages/backend/migrations/` for existing migration patterns, `.spec-workflow/specs/shared-minecraft-servers/design.md` Data Models section, `plans/EPIC-7-shared-servers.md` Phase 7A_\n  - _Requirements: REQ-1, REQ-2, REQ-5_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Database Engineer with expertise in SQLite schema design and migrations | Task: Check existing migrations in `packages/backend/migrations/` to confirm the next number is 008 (006 is multi-user, 007 is friends-chat). Create `008_shared_servers.sql` with: (1) ALTER TABLE servers ADD COLUMN shared INTEGER DEFAULT 0 NOT NULL. (2) ALTER TABLE servers ADD COLUMN shared_name TEXT. (3) ALTER TABLE servers ADD COLUMN shared_description TEXT. (4) ALTER TABLE servers ADD COLUMN shared_at INTEGER. (5) CREATE INDEX idx_servers_shared ON servers(shared) WHERE shared = 1 (partial index for querying shared servers). (6) CREATE TABLE server_permissions with columns: id TEXT PRIMARY KEY, server_id TEXT NOT NULL, user_id TEXT NOT NULL, permission TEXT NOT NULL with CHECK constraint (permission IN ('view', 'join', 'manage', 'admin')), granted_by TEXT NOT NULL, granted_at INTEGER NOT NULL. Foreign keys: server_id REFERENCES servers(id) ON DELETE CASCADE, user_id REFERENCES users(id) ON DELETE CASCADE, granted_by REFERENCES users(id). UNIQUE constraint on (server_id, user_id). (7) CREATE INDEX idx_server_permissions_server ON server_permissions(server_id). (8) CREATE INDEX idx_server_permissions_user ON server_permissions(user_id). Reference `plans/EPIC-7-shared-servers.md` Phase 7A. | Restrictions: Do NOT modify existing migrations. All foreign keys reference existing tables (servers from 001, users from 006). | Success: SQL is valid, all columns added to servers, server_permissions table created with correct constraints and indexes._\n\n- [ ] 3. Create server permission database model\n  - Files: `packages/backend/src/models/server-permission.ts` (new)\n  - Functions: hasPermission (hierarchy check), getServerPermission, grantPermission (upsert), revokePermission, listServerPermissions, listUserPermissions\n  - Permission hierarchy: view=1, join=2, manage=3, admin=4\n  - Purpose: Data access layer for per-server user permissions with hierarchical level checking\n  - _Leverage: Existing model files in `packages/backend/src/models/` for patterns, `plans/EPIC-7-shared-servers.md` Phase 7B.1_\n  - _Requirements: REQ-2_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in SQLite models | Task: Read existing model files in `packages/backend/src/models/` to understand the pattern (database access, prepared statements). Create `packages/backend/src/models/server-permission.ts` with: (1) A `PERMISSION_HIERARCHY` constant mapping: view=1, join=2, manage=3, admin=4. (2) `hasPermission(userLevel: ServerPermissionLevel or null, requiredLevel: ServerPermissionLevel): boolean` -- return false if userLevel is null, otherwise compare numeric values from the hierarchy. (3) `getServerPermission(serverId, userId): ServerPermission or null` -- SELECT from server_permissions WHERE server_id=? AND user_id=?, map snake_case to camelCase. (4) `grantPermission(serverId, userId, permission, grantedBy): ServerPermission` -- INSERT with nanoid for id, current timestamp for grantedAt, ON CONFLICT(server_id, user_id) DO UPDATE SET permission, granted_by, granted_at. Return the permission record. (5) `revokePermission(serverId, userId): void` -- DELETE FROM server_permissions WHERE server_id=? AND user_id=?. (6) `listServerPermissions(serverId): ServerPermission[]` -- SELECT all for a server, ORDER BY granted_at DESC. (7) `listUserPermissions(userId): ServerPermission[]` -- SELECT all for a user. Map snake_case to camelCase in all functions. Reference `plans/EPIC-7-shared-servers.md` Phase 7B.1. | Restrictions: Use prepared statements. Follow existing model patterns exactly. Use `.js` extension in imports. Use nanoid for IDs. | Success: All functions compile, permission hierarchy check works correctly, upsert handles both insert and update, snake_case to camelCase mapping correct._\n\n- [ ] 4. Create server permission middleware\n  - Files: `packages/backend/src/middleware/server-permission.ts` (new)\n  - Middleware factory: requireServerPermission(requiredLevel) returns Express middleware\n  - Extracts userId from req, serverId from route params, checks permission via model\n  - Purpose: Reusable Express middleware for permission-gating any route by server and permission level\n  - _Leverage: `packages/backend/src/middleware/auth.ts` for middleware patterns, `plans/EPIC-7-shared-servers.md` Phase 7B.2_\n  - _Requirements: REQ-2, REQ-4, REQ-6, REQ-8_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in Express middleware and TypeScript | Task: Read `packages/backend/src/middleware/auth.ts` to understand the existing middleware pattern (how req.user or req.userId is set by auth middleware). Create `packages/backend/src/middleware/server-permission.ts` with: (1) An `AuthenticatedRequest` interface extending Express Request with optional userId (string) field -- OR reuse the one from auth.ts if it exists. (2) `requireServerPermission(requiredLevel: ServerPermissionLevel)` -- returns an Express middleware function that: extracts userId from req (throw UnauthorizedError if missing), extracts serverId from req.params.id or req.params.serverId (throw Error if missing), calls getServerPermission(serverId, userId), calls hasPermission(permission level or null, requiredLevel), throws ForbiddenError with message \"Requires requiredLevel permission for this server\" if denied, calls next() if allowed. Import getServerPermission and hasPermission from the server-permission model. Import UnauthorizedError and ForbiddenError from utils/errors. Reference `plans/EPIC-7-shared-servers.md` Phase 7B.2. | Restrictions: Must compose with requireAuth (assumes auth middleware already ran and set userId). Do NOT duplicate auth checking logic. Use `.js` extension in imports. | Success: Middleware compiles, correctly denies access when permission insufficient, allows access when permission sufficient, throws appropriate error types._\n\n- [ ] 5. Create whitelist sync service\n  - Files: `packages/backend/src/services/whitelist-sync.ts` (new)\n  - Singleton service: addUser, removeUser, syncAll\n  - Reads/writes whitelist.json, sends stdin commands to running servers\n  - Purpose: Automatically manage Minecraft server whitelists based on community permissions\n  - _Leverage: `packages/backend/src/services/server-manager.ts` for ServerManager access, `plans/EPIC-7-shared-servers.md` Phase 7C.1_\n  - _Requirements: REQ-5_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in file I/O and child process communication | Task: Read `packages/backend/src/services/server-manager.ts` to understand how to access server processes and send commands (look for sendCommand or similar methods, and how to check if a server is running). Create `packages/backend/src/services/whitelist-sync.ts` with a `WhitelistSyncService` class exported as singleton `whitelistSyncService`. Define a `WhitelistEntry` interface with uuid (string) and name (string). Implement: (1) `async addUser(server, minecraftUsername, minecraftUuid): Promise<void>` -- read whitelist.json from server.path, add entry if not already present (check by uuid), write back. If server is running (check via serverManager.getServer), send \"whitelist add username\" and \"whitelist reload\" commands via sendCommand. Log the action via Pino logger. (2) `async removeUser(server, minecraftUsername, minecraftUuid): Promise<void>` -- read whitelist.json, filter out entry by uuid, write back if changed. If server running, send \"whitelist remove username\" and \"whitelist reload\". Log the action. (3) `async syncAll(server, authorizedUsers: Array with username and uuid): Promise<void>` -- build complete whitelist from authorizedUsers array, write to whitelist.json, if server running send \"whitelist reload\". Log the action. (4) Private `readWhitelist(path): WhitelistEntry[]` -- read and parse JSON, return empty array if file missing or invalid. (5) Private `writeWhitelist(path, whitelist): void` -- JSON.stringify with 2-space indent, write to file. Use fs readFileSync/writeFileSync/existsSync. Import path.join for constructing file paths. Reference `plans/EPIC-7-shared-servers.md` Phase 7C.1. | Restrictions: All methods should catch and log errors gracefully -- whitelist sync failures must NOT throw and block the caller. Use Pino logger for all logging. Use `.js` extension in imports. | Success: addUser adds to whitelist.json and sends commands if running, removeUser removes correctly, syncAll rebuilds the full list, corrupted JSON handled gracefully._\n\n- [ ] 6. Wire whitelist sync to permission changes\n  - Files: `packages/backend/src/models/server-permission.ts` (modify)\n  - After grantPermission: if permission is \"join\" or higher, trigger whitelist addUser\n  - After revokePermission: if old permission was \"join\" or higher, trigger whitelist removeUser\n  - Purpose: Automatically sync whitelists whenever permissions change\n  - _Leverage: `packages/backend/src/services/whitelist-sync.ts` (from task 5), `plans/EPIC-7-shared-servers.md` Phase 7C.2_\n  - _Requirements: REQ-5_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer | Task: Read `packages/backend/src/models/server-permission.ts` (created in task 3). Modify the `grantPermission` function: after the database INSERT/UPDATE, check if the granted permission level is \"join\" or higher using `hasPermission(permission, 'join')`. If so, look up the server via `getServer(serverId)` from the server model, look up the user via `getUser(userId)` or equivalent from the user model (Epic 5). If both exist and the user has minecraftUsername and minecraftUuid fields, call `whitelistSyncService.addUser(server, user.minecraftUsername, user.minecraftUuid)` with a `.catch()` to log errors (fire-and-forget). Modify the `revokePermission` function: before deleting the record, read the current permission via `getServerPermission(serverId, userId)`. After deletion, if the old permission existed and was \"join\" or higher, look up server and user, call `whitelistSyncService.removeUser()` with a `.catch()`. Import whitelistSyncService, getServer from server model, getUser from user model, and logger. Reference `plans/EPIC-7-shared-servers.md` Phase 7C.2. | Restrictions: Whitelist sync is fire-and-forget -- use .catch() to log errors, do NOT await or throw. If the user model does not have minecraftUsername/minecraftUuid fields (Epic 3 not implemented), the sync should be silently skipped with a debug log. Use `.js` extension in imports. | Success: Granting \"join\" or higher triggers whitelist add, revoking \"join\" or higher triggers whitelist remove, errors are logged but do not block the permission change, missing MC account silently skipped._\n\n- [ ] 7. Create community servers API routes\n  - Files: `packages/backend/src/routes/community-servers.ts` (new)\n  - Endpoints: GET /api/community/servers (list shared), GET /api/community/servers/:id (detail), POST /api/community/servers/:id/join (get connection info)\n  - Purpose: REST API for browsing and joining shared servers\n  - _Leverage: Existing route files for patterns, Zod validation, `plans/EPIC-7-shared-servers.md` Phases 7D.1, 7D.2_\n  - _Requirements: REQ-3, REQ-4, REQ-7_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in Express routing and Zod validation | Task: Read existing route files in `packages/backend/src/routes/` for the pattern (router setup, Zod schemas, error handling, middleware usage). Create `packages/backend/src/routes/community-servers.ts` with: (1) `GET /` (list shared servers) -- require auth via `requireAuth` middleware. Query servers table WHERE shared=1, ORDER BY shared_at DESC. For each server, look up the requesting user's permission via getServerPermission(serverId, userId), get the server process status and player list from serverManager.getServer(). Map results to SharedServerInfo objects (id, sharedName from shared_name, sharedDescription from shared_description, status from process or 'stopped', playerCount from process players length or 0, maxPlayers, version, type, onlinePlayers from process players or empty array, myPermission from permission or null, sharedAt from shared_at). Return JSON array. (2) `GET /:id` (server detail) -- require auth. Query servers WHERE id=? AND shared=1, return 404 if not found. Build SharedServerInfo same as above. Return JSON. (3) `POST /:id/join` (join server) -- require auth, require server permission 'join' via requireServerPermission('join') middleware. Query server for port and version. Return JoinServerResponse with address 'localhost' (placeholder for actual host from settings), port, version, requiresMods false (placeholder until Epic 2). Use default export for the router. Reference `plans/EPIC-7-shared-servers.md` Phases 7D.1, 7D.2. | Restrictions: Use requireAuth from Epic 5 auth middleware. Follow existing route handler try/catch/next pattern. Use `.js` extension in imports. | Success: All three endpoints compile, list returns only shared servers, detail returns 404 for non-shared, join requires \"join\" permission and returns connection info._\n\n- [ ] 8. Create server sharing and permission management routes\n  - Files: `packages/backend/src/routes/server-sharing.ts` (new)\n  - Endpoints: PUT /api/servers/:id/sharing (toggle sharing), GET /api/servers/:id/permissions (list), PUT /api/servers/:id/permissions/:userId (grant), DELETE /api/servers/:id/permissions/:userId (revoke)\n  - Purpose: REST API for managing sharing settings and per-user permissions\n  - _Leverage: Existing route patterns, Zod validation, `plans/EPIC-7-shared-servers.md` Phases 7D.3, 7D.4_\n  - _Requirements: REQ-1, REQ-2, REQ-5_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in Express routing and Zod validation | Task: Read existing route files for patterns. Create `packages/backend/src/routes/server-sharing.ts` with: (1) `PUT /:id/sharing` -- require auth, require server permission 'admin'. Validate body with Zod schema: shared (boolean), sharedName (string, min 1, max 100, optional), sharedDescription (string, max 500, optional, nullable). Look up server via getServer(id), return 404 if not found. Update servers table: SET shared, shared_name (default to server.name if not provided), shared_description, shared_at (Date.now() if enabling, null if disabling). If enabling sharing, call listServerPermissions to get all users with join or higher permission, resolve their MC accounts, call whitelistSyncService.syncAll() with .catch() for fire-and-forget. Return success JSON. (2) `GET /:id/permissions` -- require auth, require server permission 'admin'. Call listServerPermissions(serverId). Return JSON array. (3) `PUT /:id/permissions/:userId` -- require auth, require server permission 'admin'. Validate body with Zod: userId (string), permission (enum 'view', 'join', 'manage', 'admin'). Call grantPermission(serverId, userId, permission, req.userId). Return the permission record. (4) `DELETE /:id/permissions/:userId` -- require auth, require server permission 'admin'. Call revokePermission(serverId, userId). Return success JSON. Use default export for the router. Reference `plans/EPIC-7-shared-servers.md` Phases 7D.3, 7D.4. | Restrictions: All permission management endpoints require \"admin\" permission via middleware. Use Zod for ALL request body validation. Use `.js` extension in imports. | Success: All endpoints compile, sharing toggle updates database correctly, whitelist syncs on enable, permission CRUD works with proper auth._\n\n- [ ] 9. Mount new routes in Express app\n  - Files: `packages/backend/src/index.ts` or `packages/backend/src/app.ts` (modify)\n  - Mount: /api/community/servers and /api/servers (sharing routes extending existing server routes)\n  - Purpose: Register shared server routes in the Express application\n  - _Leverage: Existing route mounting in `packages/backend/src/index.ts` or `packages/backend/src/app.ts`_\n  - _Requirements: REQ-1, REQ-3, REQ-4_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer | Task: Read `packages/backend/src/index.ts` and/or `packages/backend/src/app.ts` to see how existing routes are mounted (look for app.use statements with route paths). Add imports and mount points for the two new route files: (1) Import communityServersRouter from './routes/community-servers.js', mount at '/api/community/servers'. (2) Import serverSharingRouter from './routes/server-sharing.js', mount at '/api/servers' (this extends the existing /api/servers routes with sharing and permission endpoints). Place them after existing route mounts but before error handling middleware. Reference `plans/EPIC-7-shared-servers.md` Phase 7D.5. | Restrictions: Do NOT modify existing route mounts. Do NOT change middleware order. The server-sharing routes extend /api/servers -- ensure they do not conflict with existing server routes (the new endpoints use distinct paths like /:id/sharing and /:id/permissions/:userId). Use `.js` extension in imports. | Success: Both route groups accessible, existing routes unaffected, no path conflicts._\n\n- [ ] 10. Add WebSocket broadcasting for shared server events\n  - Files: `packages/backend/src/services/server-manager.ts` (modify), WebSocket handler files (modify)\n  - Add broadcastToAuthorizedUsers method that sends events only to users with view permission\n  - Call after status changes and player join/leave for shared servers\n  - Purpose: Real-time updates in the server browser for all authorized community members\n  - _Leverage: Existing WebSocket broadcast infrastructure, `plans/EPIC-7-shared-servers.md` Phase 7G_\n  - _Requirements: REQ-3, REQ-7_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in WebSocket real-time systems | Task: Read `packages/backend/src/services/server-manager.ts` to understand how server status changes are currently handled and how WebSocket events are broadcast (look for existing broadcast or emit patterns, and how the WebSocket server/clients are accessed). Also read the WebSocket handler files to understand how clients are tracked (especially whether userId is stored on the WebSocket client object). Make these changes: (1) Add a `broadcastToAuthorizedUsers(serverId, event)` method or function: call listServerPermissions(serverId) to get all users with any permission level, extract their userIds, iterate over all connected WebSocket clients, for each client that has a userId matching the authorized list send the JSON event. (2) In the server status change handler (where status transitions like starting to running, running to stopped, etc. are detected): check if the server has shared=1 (query DB or check a flag). If shared, call broadcastToAuthorizedUsers with a status event containing type 'shared:status', serverId, and the new status. (3) In the player join/leave handler (where player count changes): if server is shared, broadcast a stats event with type 'shared:stats', serverId, playerCount, maxPlayers, and onlinePlayers array. Import listServerPermissions from the server-permission model. Reference `plans/EPIC-7-shared-servers.md` Phase 7G. | Restrictions: Do NOT break existing WebSocket handlers (console, subscribe, command). Only broadcast to users who have permission, not all connected clients. Check that the server is shared before broadcasting (avoid unnecessary DB queries for non-shared servers). Use `.js` extension in imports. | Success: Status changes on shared servers broadcast to authorized users, player join/leave updates broadcast correctly, non-shared servers unaffected, existing WS functionality preserved._\n\n- [ ] 11. Create frontend API client for community servers\n  - Files: `packages/frontend/src/api/community-servers.ts` (new)\n  - Functions: listSharedServers, getSharedServer, joinServer, updateSharingSettings, listServerPermissions, grantServerPermission, revokeServerPermission\n  - Purpose: Frontend API layer for all shared server endpoints\n  - _Leverage: `packages/frontend/src/api/client.ts` for existing fetch patterns_\n  - _Requirements: REQ-1, REQ-3, REQ-4_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in API client design | Task: Read `packages/frontend/src/api/client.ts` for existing fetch wrapper patterns (BASE_URL, headers, error handling, auth token injection). Create `packages/frontend/src/api/community-servers.ts` with these functions: (1) `listSharedServers(): Promise<SharedServerInfo[]>` -- GET /api/community/servers with credentials include. (2) `getSharedServer(id: string): Promise<SharedServerInfo>` -- GET /api/community/servers/:id. (3) `joinServer(id: string): Promise<JoinServerResponse>` -- POST /api/community/servers/:id/join. (4) `updateSharingSettings(id: string, settings: ServerSharingSettings): Promise<void>` -- PUT /api/servers/:id/sharing with JSON body. (5) `listServerPermissions(id: string): Promise<ServerPermission[]>` -- GET /api/servers/:id/permissions. (6) `grantServerPermission(serverId: string, userId: string, permission: ServerPermissionLevel): Promise<ServerPermission>` -- PUT /api/servers/:serverId/permissions/:userId with JSON body containing userId and permission. (7) `revokeServerPermission(serverId: string, userId: string): Promise<void>` -- DELETE /api/servers/:serverId/permissions/:userId. All functions include Authorization header from the auth system (follow the pattern in client.ts). Check res.ok and throw descriptive errors on failure. Import types from '@mc-server-manager/shared'. | Restrictions: Use the same fetch pattern as existing API client. Include auth headers. Do NOT duplicate auth header logic -- use the helper from client.ts if one exists. | Success: All API functions compile, match backend endpoint signatures, include auth headers, throw on non-ok responses._\n\n- [ ] 12. Create ServerCard component\n  - Files: `packages/frontend/src/components/ServerCard.tsx` (new)\n  - Card with server name, type/version, status dot, player count, online players, Join/Manage buttons\n  - Permission-aware: shows different actions based on user's permission level\n  - Purpose: Individual server card for the community server browser grid\n  - _Leverage: Existing Tailwind component patterns, lucide-react icons, `plans/EPIC-7-shared-servers.md` Phase 7E.3_\n  - _Requirements: REQ-3, REQ-4, REQ-7, REQ-8_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in Tailwind CSS and component design | Task: Read existing components in `packages/frontend/src/components/` for Tailwind styling patterns (dark theme colors, border styles, button patterns). Create `packages/frontend/src/components/ServerCard.tsx` with props: server (SharedServerInfo). Implement: (1) Card container: bg-slate-800 rounded-lg p-4 border border-slate-700 hover:border-slate-600 transition. (2) Header: server.sharedName as h3, server type and version as subtitle, status dot (colored circle: green-500 for running, yellow-500 for starting, orange-500 for stopping, slate-500 for stopped, red-500 for crashed) with title tooltip. (3) Description: server.sharedDescription if present, line-clamp-2 for truncation. (4) Player info: Users icon from lucide-react, playerCount/maxPlayers, comma-separated onlinePlayers list if any. (5) Action buttons based on permission: if user can join (myPermission is join, manage, or admin), show Join button (blue-600, disabled when server not running or currently joining). If user can manage (manage or admin), show Settings icon button. If view-only (myPermission is null or 'view'), show \"View Only\" indicator with Eye icon. (6) Join handler: call joinServer API. Check if running in Tauri context. If yes, show \"Launching Minecraft...\" toast (placeholder for Epic 3). If no, copy address:port to clipboard via navigator.clipboard.writeText, show success toast. Handle errors with error toast. Use useState for joining state. Import icons from lucide-react (Users, Play, Settings, Eye). Import toast from sonner. Reference `plans/EPIC-7-shared-servers.md` Phase 7E.3. | Restrictions: Export as named export (not default). Use Tailwind classes only. Match existing dark theme colors. Do NOT implement actual Tauri IPC (placeholder for Epic 3). | Success: Card renders all server info correctly, status dot shows correct color, Join copies to clipboard with toast, buttons shown/hidden based on permission, disabled state works._\n\n- [ ] 13. Create ServerBrowser page\n  - Files: `packages/frontend/src/pages/ServerBrowser.tsx` (new)\n  - Page with responsive grid of ServerCards, loading state, empty state\n  - Purpose: Main community server browser page accessible from navigation\n  - _Leverage: Existing page patterns, `plans/EPIC-7-shared-servers.md` Phase 7E.2_\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in page composition and React hooks | Task: Read existing pages in `packages/frontend/src/pages/` for layout patterns (padding, heading styles, Tailwind classes). Create `packages/frontend/src/pages/ServerBrowser.tsx` with default export. Implement: (1) State: servers (SharedServerInfo array), loading (boolean, initially true). (2) On mount (useEffect): call listSharedServers() from the community-servers API client, set servers, catch errors (console.error), set loading to false in finally. (3) Loading state: centered flex container with Loader2 spinner from lucide-react (w-8 h-8 animate-spin text-blue-500). (4) Empty state: centered flex-col with \"No shared servers available\" (text-lg text-slate-400) and \"Ask your community admin to share a server\" (text-sm, mt-2). (5) Server grid: p-6 container, h1 \"Community Servers\" (text-2xl font-bold text-slate-100 mb-6), responsive grid (grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4) mapping servers to ServerCard components with key=server.id. Reference `plans/EPIC-7-shared-servers.md` Phase 7E.2. | Restrictions: Use default export (React page convention). Match existing page styling exactly. Do NOT add WebSocket subscription yet (task 10 handles backend broadcasting, the page can poll or be extended later). | Success: Page loads and displays server cards in responsive grid, loading spinner shown during fetch, empty state shown when no servers, responsive layout works at all breakpoints._\n\n- [ ] 14. Create ServerSharingSettings panel component\n  - Files: `packages/frontend/src/components/ServerSharingSettings.tsx` (new)\n  - Toggle for sharing, display name input, description textarea, save button\n  - Purpose: UI for server owners/admins to configure sharing settings\n  - _Leverage: Existing Tailwind form patterns, `plans/EPIC-7-shared-servers.md` Phase 7F.1_\n  - _Requirements: REQ-1_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in form components and Tailwind CSS | Task: Read existing components for form/input styling patterns. Create `packages/frontend/src/components/ServerSharingSettings.tsx` with named export `ServerSharingSettingsPanel`. Props: serverId (string), currentSettings (ServerSharingSettings), onUpdate (callback function). Implement: (1) Local state: settings (initialized from currentSettings), saving (boolean). (2) Sharing toggle: checkbox with label showing Globe icon (green-500) and \"Shared with community\" when enabled, or Lock icon (slate-500) and \"Private\" when disabled. (3) When shared is enabled, show additional fields: Display Name input (text, w-full, bg-slate-900 border-slate-700, placeholder \"Server name visible to members\") and Description textarea (w-full, h-24 resize-none, placeholder \"Optional description for the server browser\", bind to sharedDescription with empty string mapped to null). (4) Save button (px-4 py-2 bg-blue-600 hover:bg-blue-700, disabled state with bg-slate-700). (5) handleSave: set saving=true, call updateSharingSettings(serverId, settings), toast success on success, toast error on failure, set saving=false, call onUpdate callback. Container: bg-slate-800 rounded-lg p-6 border border-slate-700. Section heading \"Sharing Settings\" (text-xl font-semibold text-slate-100 mb-4). Import Globe and Lock icons from lucide-react. Import toast from sonner. | Restrictions: Named export (not default). Match existing dark theme. Do NOT implement permission management here (separate component). | Success: Toggle switches between shared and private, form fields appear/disappear correctly, save calls API and shows toast, onUpdate callback triggered on success._\n\n- [ ] 15. Create ServerPermissionsManager component\n  - Files: `packages/frontend/src/components/ServerPermissionsManager.tsx` (new)\n  - List of current permissions with color-coded badges, revoke button, add user button (placeholder)\n  - Purpose: UI for admins to view and manage per-user permissions on a server\n  - _Leverage: Existing Tailwind list/table patterns, `plans/EPIC-7-shared-servers.md` Phase 7F.2_\n  - _Requirements: REQ-2_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in list UIs and Tailwind CSS | Task: Create `packages/frontend/src/components/ServerPermissionsManager.tsx` with named export `ServerPermissionsManager`. Props: serverId (string). Implement: (1) State: permissions (ServerPermission array), loading (boolean). (2) loadPermissions function: call listServerPermissions(serverId), set state, catch and console.error, set loading=false. Call on mount via useEffect. (3) Header section: \"Permissions\" heading (text-xl font-semibold text-slate-100), \"Add User\" button (UserPlus icon from lucide-react, blue-600 bg) with onClick placeholder (TODO: open add user modal). (4) Empty state: \"No permissions set. Add users to share this server.\" (text-slate-400 text-sm). (5) Permission list: for each permission, render a row (bg-slate-900 rounded border border-slate-700 p-3) with userId (text-slate-200 font-medium), permission level as color-coded badge (view=slate-600, join=blue-600, manage=purple-600, admin=red-600, text-xs rounded px-2 py-1), and revoke button (Trash2 icon from lucide-react, text-red-400 hover:text-red-300). (6) handleRevoke: call revokeServerPermission(serverId, userId), toast success, reload permissions. handleGrant: call grantServerPermission(serverId, userId, permission), toast success, reload. Container: bg-slate-800 rounded-lg p-6 border border-slate-700. Import toast from sonner. | Restrictions: Named export. Match dark theme. The \"Add User\" functionality can be a TODO placeholder for now (modal implementation is a UI enhancement). | Success: Permissions load and display with color-coded badges, revoke button removes permission with toast, empty state shown when no permissions._\n\n- [ ] 16. Add server browser route to frontend routing\n  - Files: `packages/frontend/src/App.tsx` (modify)\n  - Add /community/servers route pointing to ServerBrowser page\n  - Purpose: Make the server browser accessible from the application navigation\n  - _Leverage: `packages/frontend/src/App.tsx` for existing routing patterns_\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in React Router | Task: Read `packages/frontend/src/App.tsx` to understand the current routing setup (BrowserRouter, Routes, Route components, any layout wrappers, ProtectedRoute usage). Add: (1) Import ServerBrowser from './pages/ServerBrowser'. (2) Add a new Route: path=\"/community/servers\" element pointing to ServerBrowser, wrapped in ProtectedRoute if the app uses auth-gated routing. (3) If the app has a sidebar or navigation component, add a link to \"/community/servers\" with a label like \"Community Servers\" or \"Server Browser\" with an appropriate icon. | Restrictions: Do NOT remove or restructure existing routes. If ProtectedRoute exists, use it. Match existing route and navigation patterns exactly. | Success: /community/servers route renders the ServerBrowser page, route is accessible from navigation, auth protection applied if applicable._\n\n- [ ] 17. Handle shared server WebSocket events in frontend\n  - Files: `packages/frontend/src/api/ws.ts` (modify), `packages/frontend/src/stores/serverStore.ts` (modify, optional)\n  - Handle shared:status and shared:stats events from WebSocket\n  - Update server browser data when events arrive\n  - Purpose: Real-time updates in the server browser without polling\n  - _Leverage: Existing WS event handling in `packages/frontend/src/api/ws.ts`_\n  - _Requirements: REQ-3, REQ-7_\n  - _Prompt: Implement the task for spec shared-minecraft-servers, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in WebSocket event handling and state management | Task: Read `packages/frontend/src/api/ws.ts` to understand the existing onmessage handler (likely a switch on msg.type or event-based dispatch). Also read `packages/frontend/src/stores/serverStore.ts` to understand the store pattern. Add handling for two new WebSocket event types: (1) `shared:status` -- when received, the event contains serverId and status fields. If the server browser page is displaying servers, update the matching server's status in the store or trigger a re-fetch. The simplest approach: if a shared server store or state exists, update the server's status field. Otherwise, store a Map of shared server updates that the ServerBrowser page can subscribe to. (2) `shared:stats` -- when received, the event contains serverId, playerCount, maxPlayers, and onlinePlayers fields. Update the matching server's player data. Consider adding a lightweight `sharedServerStore` (Zustand) or extending the existing serverStore with a `sharedServers` slice to hold this state. The store should have: `updateSharedServerStatus(serverId, status)` and `updateSharedServerStats(serverId, playerCount, maxPlayers, onlinePlayers)` actions. Wire the WS events to these store actions. | Restrictions: Do NOT break existing WS event handlers (console, status, stats for owned servers). Keep the implementation minimal -- the server browser can also poll on mount, so real-time updates are an enhancement. Use `.js` extension in imports if needed. | Success: WebSocket events for shared servers are handled, server browser updates in real-time when a shared server's status or player list changes, existing WS functionality preserved._\n",
  "fileStats": {
    "size": 39166,
    "lines": 146,
    "lastModified": "2026-02-12T00:35:09.189Z"
  },
  "comments": []
}
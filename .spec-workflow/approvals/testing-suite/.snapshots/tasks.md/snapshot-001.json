{
  "id": "snapshot_1771117143394_4zcx5o6bn",
  "approvalId": "approval_1771117143364_bgb667y4z",
  "approvalTitle": "Testing Suite - Tasks Document",
  "version": 1,
  "timestamp": "2026-02-15T00:59:03.394Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document\n\n- [ ] 1. Install dependencies and create root Vitest workspace config\n  - Files: `package.json` (modify), `vitest.workspace.ts` (new)\n  - Install `vitest` and `@vitest/coverage-v8` as root devDependencies. Create `vitest.workspace.ts` at project root that references the three testable packages: `shared/vitest.config.ts`, `packages/backend/vitest.config.ts`, `packages/frontend/vitest.config.ts`. Add `test`, `test:watch`, and `test:coverage` scripts to the root `package.json`.\n  - Purpose: Foundation — enables `npm test` from root to orchestrate all package test suites\n  - _Leverage: `package.json` for existing workspace config and scripts pattern_\n  - _Requirements: REQ-1, REQ-10_\n  - _Prompt: Implement the task for spec testing-suite, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: DevOps/Build Engineer | Task: (1) Read `package.json` to understand existing scripts and devDependencies. (2) Run `npm install -D vitest @vitest/coverage-v8` from the project root. (3) Create `vitest.workspace.ts` at project root with: `import { defineWorkspace } from 'vitest/config'; export default defineWorkspace(['shared/vitest.config.ts', 'packages/backend/vitest.config.ts', 'packages/frontend/vitest.config.ts'])`. (4) Add these scripts to root `package.json`: `\"test\": \"vitest run\"`, `\"test:watch\": \"vitest\"`, `\"test:coverage\": \"vitest run --coverage\"`. | Restrictions: Do NOT modify any existing scripts. Do NOT install packages in individual workspaces yet (that's later tasks). Do NOT create the per-package config files yet. | Success: `vitest.workspace.ts` exists at root, root `package.json` has test/test:watch/test:coverage scripts, vitest is installed in root devDependencies. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 2. Create shared package Vitest config and utility tests\n  - Files: `shared/vitest.config.ts` (new), `shared/package.json` (modify), `shared/src/index.test.ts` (new)\n  - Configure Vitest for the shared package (Node environment). Write comprehensive unit tests for all pure utility functions: `compareMcVersions`, `getMinJavaForMcVersion`, `getJavaMajorVersion`, `checkJavaMcCompat`. Add a `test` script to `shared/package.json`.\n  - Purpose: First tests in the project — proves Vitest works, covers critical shared logic\n  - _Leverage: `shared/src/index.ts` for function signatures and documented behavior, `shared/package.json` for existing scripts_\n  - _Requirements: REQ-1, REQ-3_\n  - _Prompt: Implement the task for spec testing-suite, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: TypeScript Developer specializing in unit testing | Task: (1) Read `shared/src/index.ts` thoroughly — find the functions `compareMcVersions`, `getMinJavaForMcVersion`, `getJavaMajorVersion`, `checkJavaMcCompat` and understand their behavior, parameters, and return types. Also find the `MC_JAVA_COMPAT` constant. (2) Read `shared/package.json`. (3) Create `shared/vitest.config.ts`: `import { defineConfig } from 'vitest/config'; export default defineConfig({ test: { name: 'shared', environment: 'node', globals: true, include: ['src/**/*.test.ts'], coverage: { provider: 'v8', include: ['src/**/*.ts'], exclude: ['src/**/*.test.ts'] } } })`. (4) Add `\"test\": \"vitest run\"` to `shared/package.json` scripts. (5) Create `shared/src/index.test.ts` with these test suites: **compareMcVersions**: test equal versions return 0, test 1.20 > 1.9 (numeric comparison not lexicographic), test 1.20.1 > 1.20, test versions with different segment counts (1.20 vs 1.20.0), test 1.0 < 1.1. **getMinJavaForMcVersion**: test MC 1.21 returns 21, test MC 1.20.4 returns 17, test MC 1.16.5 returns 8, test unknown high version returns highest known requirement, test very old version. **getJavaMajorVersion**: test old format \"1.8.0_392\" returns 8, test new format \"21.0.1\" returns 21, test \"17.0.2\" returns 17. **checkJavaMcCompat**: test compatible pair (Java 21 + MC 1.21) returns null, test incompatible pair (Java 8 + MC 1.21) returns warning string, test compatible old pair (Java 8 + MC 1.16.5) returns null. (6) Run `npx vitest run --project shared` to verify all tests pass. | Restrictions: Do NOT modify `shared/src/index.ts` — only test existing behavior. Use `describe`/`it`/`expect` from vitest globals. Do NOT import vitest functions (globals: true handles it). | Success: All tests pass, no existing code modified, `npm test -w @mc-server-manager/shared` works. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 3. Create backend Vitest config, setup file, and test utilities\n  - Files: `packages/backend/vitest.config.ts` (new), `packages/backend/package.json` (modify), `packages/backend/src/test-utils/setup.ts` (new), `packages/backend/src/test-utils/db.ts` (new), `packages/backend/src/test-utils/auth.ts` (new), `packages/backend/src/test-utils/factories.ts` (new)\n  - Install backend test dependencies (supertest, @types/supertest). Create Vitest config for Node environment with setup file. Create test utilities: DB helper (in-memory SQLite with migrations), auth helper (test user + JWT), and mock data factories.\n  - Purpose: Backend test infrastructure — all subsequent backend tests depend on these helpers\n  - _Leverage: `packages/backend/src/services/database.ts` for initDatabase/closeDatabase/getDb, `packages/backend/src/services/jwt.ts` for generateAccessToken/getOrCreateJWTSecret, `packages/backend/src/config.ts` for environment variable pattern, `packages/backend/src/models/user.ts` for user creation, `packages/backend/migrations/` for migration file path resolution_\n  - _Requirements: REQ-1, REQ-4, REQ-9_\n  - _Prompt: Implement the task for spec testing-suite, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer specializing in test infrastructure | Task: (1) Read these files first: `packages/backend/src/config.ts` (understand env var resolution for DB_PATH, LOG_LEVEL), `packages/backend/src/services/database.ts` (understand initDatabase, closeDatabase, getDb, runMigrations and how MC_MIGRATIONS_DIR env var controls migration directory), `packages/backend/src/services/jwt.ts` (understand generateAccessToken, getOrCreateJWTSecret), `packages/backend/src/models/user.ts` (find the createUser or equivalent function for inserting users), `packages/backend/package.json`. (2) Run `npm install -D supertest @types/supertest -w @mc-server-manager/backend`. (3) Create `packages/backend/vitest.config.ts`: `import { defineConfig } from 'vitest/config'; export default defineConfig({ test: { name: 'backend', environment: 'node', globals: true, setupFiles: ['./src/test-utils/setup.ts'], include: ['src/**/*.test.ts'], coverage: { provider: 'v8', include: ['src/**/*.ts'], exclude: ['src/**/*.test.ts', 'src/test-utils/**'] } } })`. (4) Add `\"test\": \"vitest run\"` to `packages/backend/package.json` scripts. (5) Create `packages/backend/src/test-utils/setup.ts`: Set `process.env.DB_PATH = ':memory:'`, `process.env.LOG_LEVEL = 'silent'`, and `process.env.MC_MIGRATIONS_DIR` pointing to the migrations directory (use `import { fileURLToPath } from 'node:url'` and resolve `'../../../migrations'` relative to the setup file). This file runs BEFORE any app module imports. (6) Create `packages/backend/src/test-utils/db.ts`: Export `setupTestDb()` which calls `initDatabase()` from `../services/database.js` and returns the db. Export `teardownTestDb()` which calls `closeDatabase()` from `../services/database.js`. Re-export `getDb`. (7) Create `packages/backend/src/test-utils/auth.ts`: Import `generateAccessToken` from `../services/jwt.js`, import `getDb` from `../services/database.js`, import `nanoid` from `nanoid`. Export `createTestUser(overrides?: { username?: string; role?: UserRole })` that: inserts a user into the users table (id via nanoid, username defaulting to 'testuser', role defaulting to 'owner', password_hash as a placeholder string, created_at as datetime('now')), then calls `generateAccessToken({ id, username, role })` to get a token, returns `{ id, username, role, token }`. Export `createTestOwner()` as shorthand. Check `packages/backend/src/models/user.ts` for the exact users table column names. (8) Create `packages/backend/src/test-utils/factories.ts`: Import `CreateServerRequest` from `@mc-server-manager/shared`. Export `buildCreateServerRequest(overrides?)` returning a valid object with defaults: `{ name: 'Test Server', type: 'vanilla', mcVersion: '1.21', port: 25565, jvmArgs: '-Xmx2G -Xms1G', javaPath: 'java', ...overrides }`. | Restrictions: Use `.js` extensions in ALL backend imports. Do NOT modify any existing source files. The setup file must set env vars BEFORE module-level config imports execute. Do NOT use `vi.mock()` for the database — use real in-memory SQLite. | Success: Config file compiles, setup file sets correct env vars, db helper can init/teardown in-memory DB, auth helper generates valid JWTs, factory produces valid request objects. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 4. Create backend unit tests (ConsoleBuffer, errors, Zod schemas, properties parser)\n  - Files: `packages/backend/src/services/console-buffer.test.ts` (new), `packages/backend/src/utils/errors.test.ts` (new), `packages/backend/src/routes/validation.test.ts` (new), `packages/backend/src/services/properties.test.ts` (new)\n  - Write unit tests for pure/isolated backend modules that don't require database or HTTP.\n  - Purpose: High-value unit tests covering data structures, error hierarchy, validation schemas, and file parsing\n  - _Leverage: `packages/backend/src/services/console-buffer.ts` (ConsoleBuffer class), `packages/backend/src/utils/errors.ts` (AppError, NotFoundError, etc.), `packages/backend/src/routes/validation.ts` (createServerSchema, updateServerSchema, updatePropertiesSchema), `packages/backend/src/services/properties.ts` (parseProperties, serializeProperties)_\n  - _Requirements: REQ-5_\n  - _Prompt: Implement the task for spec testing-suite, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend TypeScript Developer specializing in unit testing | Task: Read the source files listed below, then create test files. **(A) ConsoleBuffer tests** — Read `packages/backend/src/services/console-buffer.ts`. Create `packages/backend/src/services/console-buffer.test.ts` testing: (1) push adds a line and returns ConsoleLine with timestamp, (2) getLines returns empty array when buffer is empty, (3) getLines returns lines in chronological order, (4) buffer wraps around when capacity is exceeded — push more than capacity lines, verify getLines returns only the last N (capacity) lines in order, (5) getSize reflects actual count up to capacity, (6) clear resets the buffer. Use `new ConsoleBuffer(5)` for small-capacity tests to make wrap-around easy to test. **(B) Error tests** — Read `packages/backend/src/utils/errors.ts`. Create `packages/backend/src/utils/errors.test.ts` testing: AppError has default statusCode 500, NotFoundError has 404 and code \"NOT_FOUND\" and message includes resource and id, ValidationError has 400 and code \"VALIDATION_ERROR\", ConflictError has 409, UnauthorizedError has 401 and default message, ForbiddenError has 403 and default message. Test instanceof chain: NotFoundError instanceof AppError is true, AppError instanceof Error is true. **(C) Zod schema tests** — Read `packages/backend/src/routes/validation.ts`. Create `packages/backend/src/routes/validation.test.ts` testing: createServerSchema — valid input passes, missing name fails, name over 100 chars fails, invalid port (below 1024, above 65535, non-integer) fails, type defaults to 'vanilla', port defaults to 25565. updateServerSchema — empty object passes (all optional), invalid port fails. updatePropertiesSchema — valid record passes, empty key fails. **(D) Properties parser tests** — Read `packages/backend/src/services/properties.ts` focusing on `parseProperties` and `serializeProperties` functions. Create `packages/backend/src/services/properties.test.ts` testing: parseProperties — parses simple key=value, skips comment lines starting with #, skips empty lines, handles values containing = (split on first = only), preserves whitespace in values (don't trim right side), skips lines without =. serializeProperties — produces lines in alphabetical key order, includes header comment, ends with trailing newline. Round-trip: parseProperties(serializeProperties(props)) returns original props (ignoring comments). | Restrictions: Do NOT import from vitest — use globals. Do NOT modify any source files. Use `.js` extensions in imports for backend files. These are pure unit tests — do NOT import database or setup files. | Success: All test files compile, all tests pass when running `npx vitest run --project backend`. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 5. Create backend HTTP integration tests (server CRUD routes)\n  - Files: `packages/backend/src/routes/servers.test.ts` (new)\n  - Write supertest integration tests for core server CRUD endpoints: GET /api/servers, POST /api/servers, GET /api/servers/:id, PATCH /api/servers/:id, DELETE /api/servers/:id. These exercise the full stack (routes → services → models → SQLite) through HTTP.\n  - Purpose: Integration tests proving the API contract works end-to-end through the HTTP layer\n  - _Leverage: `packages/backend/src/app.ts` (exported Express app), `packages/backend/src/test-utils/db.ts` (setupTestDb/teardownTestDb), `packages/backend/src/test-utils/auth.ts` (createTestUser), `packages/backend/src/test-utils/factories.ts` (buildCreateServerRequest), `packages/backend/src/routes/servers.ts` for actual endpoint implementation_\n  - _Requirements: REQ-4, REQ-8_\n  - _Prompt: Implement the task for spec testing-suite, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer specializing in API integration testing | Task: (1) Read `packages/backend/src/routes/servers.ts` to understand endpoint paths, HTTP methods, request/response shapes, and auth requirements. (2) Read `packages/backend/src/app.ts` to confirm the app is exported. (3) Read the test utility files: `packages/backend/src/test-utils/db.ts`, `packages/backend/src/test-utils/auth.ts`, `packages/backend/src/test-utils/factories.ts`. (4) Create `packages/backend/src/routes/servers.test.ts`. Import `supertest` (default import), import `{ app }` from `../app.js`, import `{ setupTestDb, teardownTestDb }` from `../test-utils/db.js`, import `{ createTestOwner }` from `../test-utils/auth.js`, import `{ buildCreateServerRequest }` from `../test-utils/factories.js`. Structure: `beforeAll(() => { setupTestDb() })`, `afterAll(() => { teardownTestDb() })`. Declare `let owner: TestUser` and set it in beforeAll after DB setup. For each test use `supertest(app)` with `.set('Authorization', 'Bearer ' + owner.token)`. **Tests to write**: (a) `GET /api/servers` returns 200 with empty array initially. (b) `POST /api/servers` with valid body returns 201 and response has id, name, type, mcVersion, port fields matching request (NOTE: the server creation endpoint may trigger a download or setup — if it fails because there's no real JAR file, that's OK; test the response shape or handle the expected error). (c) `GET /api/servers/:id` with valid id returns 200 and matching server. (d) `GET /api/servers/:id` with invalid id returns 404. (e) `PATCH /api/servers/:id` with `{ name: 'Updated' }` returns 200 with updated name. (f) `DELETE /api/servers/:id` returns 200 or 204. (g) `POST /api/servers` with missing name returns 400. (h) `POST /api/servers` with invalid port returns 400. IMPORTANT: The POST endpoint may do file I/O (create server directory, download JAR). If tests fail due to missing Java or file system operations, you may need to mock the download/setup service with `vi.mock()` for those specific imports. Read the route handler to understand what services are called on POST and mock only what's necessary to prevent I/O. Do NOT mock the database. | Restrictions: Use `.js` extensions in all imports. Do NOT modify any application source files. The database must be real in-memory SQLite — no DB mocking. Mock only I/O-heavy services (download, file system setup) if needed for POST to succeed. Keep tests independent — each should work regardless of execution order. | Success: All tests pass with `npx vitest run --project backend`, HTTP status codes and response shapes are validated. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 6. Create frontend Vitest config, setup file, and test utilities\n  - Files: `packages/frontend/vitest.config.ts` (new), `packages/frontend/package.json` (modify), `packages/frontend/src/test-utils/setup.ts` (new), `packages/frontend/src/test-utils/render.ts` (new), `packages/frontend/src/test-utils/factories.ts` (new)\n  - Install frontend test dependencies (@testing-library/react, @testing-library/user-event, @testing-library/jest-dom, happy-dom). Create Vitest config for happy-dom environment with React plugin. Create test utilities: setup file with jest-dom matchers + cleanup, custom render with router, and mock data factories.\n  - Purpose: Frontend test infrastructure — all subsequent frontend tests depend on these helpers\n  - _Leverage: `packages/frontend/vite.config.ts` (React plugin config, path alias), `packages/frontend/src/App.tsx` (routing setup for MemoryRouter pattern), `packages/frontend/package.json`_\n  - _Requirements: REQ-1, REQ-6, REQ-9_\n  - _Prompt: Implement the task for spec testing-suite, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer specializing in test infrastructure | Task: (1) Read `packages/frontend/vite.config.ts` (understand React plugin and path alias config). Read `packages/frontend/package.json`. Read `packages/frontend/src/App.tsx` (understand routing structure). (2) Run `npm install -D @testing-library/react @testing-library/user-event @testing-library/jest-dom happy-dom -w @mc-server-manager/frontend`. (3) Create `packages/frontend/vitest.config.ts` — reference the design doc at `.spec-workflow/specs/testing-suite/design.md` Component 8 for the exact config. It uses the react plugin, happy-dom environment, globals true, setup file at `./src/test-utils/setup.ts`, includes `src/**/*.test.ts` and `src/**/*.test.tsx`, with v8 coverage excluding test-utils and main.tsx. The resolve alias maps `@` to the src directory. (4) Add `\"test\": \"vitest run\"` to `packages/frontend/package.json` scripts. (5) Create `packages/frontend/src/test-utils/setup.ts` — reference design doc Component 9. Import jest-dom vitest matchers, import cleanup from testing-library/react, run cleanup in afterEach. (6) Create `packages/frontend/src/test-utils/render.ts` — reference design doc Component 10. Export a renderWithRouter function that wraps a React element in MemoryRouter with configurable initialEntries. Re-export screen and waitFor from testing-library/react. (7) Create `packages/frontend/src/test-utils/factories.ts` — reference design doc Component 11. Export buildServer that returns a ServerWithStatus with sensible defaults (id test-server-1, name Test Server, type vanilla, mcVersion 1.21, port 25565, status stopped, playerCount 0, uptime null, etc.) where all fields can be overridden. Export buildServerList that creates N servers with sequential names and ids. | Restrictions: Do NOT modify existing source files. Do NOT modify `vite.config.ts` — the test config is a separate file. Use `@/` path alias only in test files that import from src. | Success: Config file compiles, `npx vitest run --project frontend` runs (0 tests found is fine — test files come in later tasks). Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 7. Create frontend store tests (Zustand serverStore)\n  - Files: `packages/frontend/src/stores/serverStore.test.ts` (new)\n  - Write unit tests for the Zustand store actions: fetchServers, updateServerStatus, appendConsole (cap enforcement), clearConsole, setConsoleHistory. Mock the API client module.\n  - Purpose: Verify state management logic in isolation without rendering React components\n  - _Leverage: `packages/frontend/src/stores/serverStore.ts` (store definition, actions, state shape), `packages/frontend/src/api/client.ts` (API methods called by store actions)_\n  - _Requirements: REQ-7_\n  - _Prompt: Implement the task for spec testing-suite, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer specializing in Zustand testing | Task: (1) Read `packages/frontend/src/stores/serverStore.ts` thoroughly — understand the full state interface (ServerStore), all actions, how fetchServers calls the API, how appendConsole works and how console lines are capped, how updateServerStatus merges status into the servers array. (2) Read `packages/frontend/src/api/client.ts` to understand the getServers function signature that fetchServers calls. (3) Create `packages/frontend/src/stores/serverStore.test.ts`. Mock the API client: `vi.mock('@/api/client', () => ({ api: { getServers: vi.fn() } }))`. Import the mock: `import { api } from '@/api/client'`. Import the store: `import { useServerStore } from './serverStore'`. In `beforeEach`, reset the store to initial state: `useServerStore.setState({ servers: [], consoleLines: {}, wsConnected: false })`. **Tests**: (a) Initial state has empty servers array and empty consoleLines. (b) fetchServers — mock api.getServers to resolve with a server array, call `useServerStore.getState().fetchServers()`, assert `useServerStore.getState().servers` equals the mock data. (c) updateServerStatus — first set servers state to contain a server, then call updateServerStatus with the server's id and `{ status: 'running', playerCount: 3 }`, assert the server in state has updated status and playerCount, and other fields are preserved. (d) appendConsole — call appendConsole with a serverId and a console line object, assert it appears in `consoleLines[serverId]`. Then append many lines (more than the cap, find the cap in the source code — likely 2000) and verify the array length is capped. (e) clearConsole — set console lines for a serverId, call clearConsole(serverId), assert the array is empty or the key is removed. (f) setConsoleHistory — set console history for a serverId with an array, assert consoleLines[serverId] matches. | Restrictions: Do NOT modify store source code. Do NOT render React components — test the store directly via `useServerStore.getState()` and `useServerStore.setState()`. Reset store state in beforeEach to prevent test interdependence. Use `vi.mocked()` for type-safe mock assertions. | Success: All tests pass, store actions are verified in isolation. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 8. Create frontend component tests (StatusBadge, ServerCard)\n  - Files: `packages/frontend/src/components/StatusBadge.test.tsx` (new), `packages/frontend/src/components/ServerCard.test.tsx` (new)\n  - Write component tests using Testing Library for the two most testable presentational components.\n  - Purpose: Verify UI rendering, correct text/status display, and component contract\n  - _Leverage: `packages/frontend/src/components/StatusBadge.tsx` (StatusBadge component, statusConfig), `packages/frontend/src/components/ServerCard.tsx` (ServerCard component, ServerCardProps), `packages/frontend/src/test-utils/render.ts` (renderWithRouter), `packages/frontend/src/test-utils/factories.ts` (buildServer)_\n  - _Requirements: REQ-6_\n  - _Prompt: Implement the task for spec testing-suite, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer specializing in component testing | Task: (1) Read `packages/frontend/src/components/StatusBadge.tsx` — understand the props interface (status: ServerStatus, className?: string), the statusConfig map, and what text is rendered for each status. (2) Read `packages/frontend/src/components/ServerCard.tsx` — understand the props interface (server: ServerWithStatus), what information is displayed (name, type, version, port, player count, uptime, memory), and that it renders as a link element. (3) Read test utilities: `packages/frontend/src/test-utils/render.ts` and `packages/frontend/src/test-utils/factories.ts`. **(A) StatusBadge tests** — Create `packages/frontend/src/components/StatusBadge.test.tsx`. Import `render` and `screen` from '@testing-library/react'. Import `StatusBadge` from './StatusBadge'. Tests: (a) renders \"Running\" text for status='running', (b) renders \"Stopped\" text for status='stopped', (c) renders \"Starting\" text for status='starting', (d) renders \"Crashed\" text for status='crashed', (e) renders \"Stopping\" text for status='stopping', (f) renders \"Provisioning\" text for status='provisioning'. Use `screen.getByText()` to assert text content. **(B) ServerCard tests** — Create `packages/frontend/src/components/ServerCard.test.tsx`. Import `screen` from '@testing-library/react'. Import `renderWithRouter` from '../test-utils/render'. Import `buildServer` from '../test-utils/factories'. Import `ServerCard` from './ServerCard'. Tests: (a) renders server name — `buildServer({ name: 'My Test Server' })`, render with renderWithRouter passing ServerCard with the server prop, assert `screen.getByText('My Test Server')` exists. (b) renders server type and version — assert text contains the type (capitalized) and mcVersion. (c) renders player count — `buildServer({ playerCount: 5 })`, assert text contains '5 players'. (d) renders as a link to server detail — assert the rendered link has an href containing `/servers/${server.id}`. (e) renders port number — assert the port is displayed. Use `renderWithRouter` for ServerCard since it renders a Link component which requires router context. | Restrictions: Do NOT modify component source files. Use Testing Library queries (getByText, getByRole, etc.) — do NOT query by class names or test IDs. Use `renderWithRouter` for any component that uses React Router. | Success: All component tests pass, components render correctly for all status variants. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 9. Add per-package test scripts and final verification\n  - Files: `package.json` (verify), `shared/package.json` (verify), `packages/backend/package.json` (verify), `packages/frontend/package.json` (verify)\n  - Verify all test scripts exist and work correctly. Run full test suite from root. Run coverage report. Fix any remaining issues.\n  - Purpose: End-to-end verification that everything works together\n  - _Leverage: Root `package.json` scripts, per-package `package.json` scripts_\n  - _Requirements: REQ-1, REQ-2, REQ-10_\n  - _Prompt: Implement the task for spec testing-suite, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Senior Developer | Task: (1) Verify `package.json` root has scripts: \"test\", \"test:watch\", \"test:coverage\". (2) Verify `shared/package.json` has \"test\" script. (3) Verify `packages/backend/package.json` has \"test\" script. (4) Verify `packages/frontend/package.json` has \"test\" script. (5) Run `npm test` from project root — ALL tests across all 3 packages must pass. Count total tests. (6) Run `npm run test:coverage` — verify coverage report is generated. (7) Run `npm run build` — verify build still passes (test files should NOT interfere with tsc compilation). (8) If any tests fail, investigate and fix. Common issues: missing mocks, import path issues (.js extensions), env var timing. (9) If build fails, ensure test files are excluded from tsconfig's include patterns — test files should only be picked up by Vitest, not tsc. Add test file globs to tsconfig exclude if needed. | Restrictions: Do NOT make functional changes to application code — this is verification and fixing test infrastructure only. If tests fail due to a test bug, fix the test. If tests fail due to a missing mock, add the mock. Do NOT change application source code to make tests pass. | Success: `npm test` passes all tests across all packages, `npm run test:coverage` generates report, `npm run build` passes. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n",
  "fileStats": {
    "size": 29240,
    "lines": 74,
    "lastModified": "2026-02-15T00:58:49.680Z"
  },
  "comments": []
}
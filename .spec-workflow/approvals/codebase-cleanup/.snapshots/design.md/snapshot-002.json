{
  "id": "snapshot_1771193377715_bflgwsu9j",
  "approvalId": "approval_1771193293812_einmojrna",
  "approvalTitle": "Codebase Cleanup Design",
  "version": 2,
  "timestamp": "2026-02-15T22:09:37.715Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis spec addresses 7 categories of code quality issues found during a comprehensive codebase audit. All changes are internal refactors — no new features, no API contract changes, no database migrations. The goal is to reduce maintenance cost and improve developer experience before the next wave of feature specs (friends-chat, shared-servers, voice-communication, mod-sync).\n\nThe work spans all four packages (backend, frontend, shared, electron) but is predominantly backend-focused. Each change is independently verifiable and introduces no new runtime dependencies.\n\n## Steering Document Alignment\n\nPer `tech.md`: The project uses TypeScript strict mode, Zod for validation, Pino for logging, and custom error classes (`AppError`, `NotFoundError`, etc.) in `utils/errors.ts`. This design extends those existing patterns rather than introducing new ones.\n\nPer `structure.md`: New utilities go in `packages/backend/src/utils/` (validation helper). Shared type changes happen in `shared/src/index.ts`. No new files are created in frontend except modifications to `api/client.ts`.\n\nPer `product.md`: This cleanup supports the \"minimal external dependencies\" and \"single codebase\" principles — it removes duplication and tightens type safety without adding packages.\n\n## Code Reuse Analysis\n\n### Existing Code to Leverage\n\n- **`packages/backend/src/utils/errors.ts`**: Already has `AppError` (base), `NotFoundError` (404), `ValidationError` (400), `ConflictError` (409), `UnauthorizedError` (401), `ForbiddenError` (403). REQ-2 will use these directly — no new error classes needed.\n- **`packages/backend/src/app.ts:82-123`**: Express error middleware already handles `AppError` subclasses and returns structured JSON `{ error, code }`. No changes needed here.\n- **`packages/backend/src/routes/validation.ts`**: Existing Zod schemas. The new validation utility will live alongside these.\n- **`packages/frontend/src/api/client.ts`**: Contains both `request()` and `authFetch()`. REQ-3 merges them.\n- **`shared/src/index.ts`**: All shared types. REQ-4 modifies existing types in place.\n\n### Integration Points\n\n- **Express error middleware** (`app.ts:82-123`): Catches `AppError` subclasses and returns appropriate HTTP status. Services that currently throw raw `Error` fall through to the generic 500 handler. After REQ-2, they'll be caught by the `AppError` branch instead.\n- **Frontend `ApiError`** (`api/client.ts:41-50`): The frontend's `ApiError` class extracts `status`, `message`, and `code` from response JSON. After REQ-2, it will receive more accurate status codes from the backend.\n\n### Shared Types Already Available\n\n- `ServerType`, `ServerStatus`, `ModLoader`, `LoaderType`, `VersionType` — modified by REQ-4\n- `MojangVersionManifest`, `MojangVersionEntry` — kept as canonical types by REQ-4\n- `VersionManifest`, `MinecraftVersion` — removed/replaced by REQ-4\n- `AppSettings` — referenced by REQ-6 settings.ts fix\n\n## Architecture\n\nNo architectural changes. All modifications are within existing files. The data flow remains:\n\n```\nRoutes (HTTP) --> Services (business logic) --> Models (SQLite)\n                        |\n                        +---> ServerManager --> ServerProcess (child_process.spawn)\n                        +---> File I/O (server.properties, JARs)\n\nWebSocket Server ---> Same services, different transport\n```\n\n### Design Principles Applied\n\n- **Single File Responsibility**: The new validation utility is one file (`utils/validation.ts`) with one function. It doesn't absorb other concerns.\n- **Transport Separation**: Error class migration (REQ-2) happens in services, not routes. Routes already delegate to services — they just get better errors back now.\n- **Minimal Surface Area**: No new exports from shared beyond what's needed. Type aliases replace removed types to minimize import-site changes.\n\n## Components and Interfaces\n\n### Component 1: Validation Utility (`packages/backend/src/utils/validation.ts`)\n\n- **Purpose**: Single function to validate input against a Zod schema and throw `ValidationError` on failure.\n- **Interfaces**:\n  ```typescript\n  import { z } from \"zod\";\n  import { ValidationError } from \"./errors.js\";\n\n  /**\n   * Validate input against a Zod schema.\n   * Returns the parsed (typed) data on success.\n   * Throws ValidationError with formatted message on failure.\n   */\n  export function validate<T>(schema: z.ZodSchema<T>, data: unknown): T {\n    const result = schema.safeParse(data);\n    if (!result.success) {\n      const message = result.error.issues\n        .map((i) => `${i.path.join(\".\")}: ${i.message}`)\n        .join(\"; \");\n      throw new ValidationError(message);\n    }\n    return result.data;\n  }\n  ```\n- **Dependencies**: `zod`, `./errors.js`\n- **Reuses**: Existing `ValidationError` class which already sets status 400 and code `VALIDATION_ERROR`\n\n### Component 2: Consolidated API Client (`packages/frontend/src/api/client.ts`)\n\n- **Purpose**: Single fetch wrapper with auth headers, token refresh, and error handling.\n- **Interfaces**:\n  ```typescript\n  /**\n   * Unified fetch wrapper. Attaches auth token, refreshes on 401, throws ApiError.\n   * @param path - API path (e.g., \"/api/servers\")\n   * @param options - Standard RequestInit\n   * @param skipRefresh - Set true for the refresh endpoint itself (prevents loops)\n   */\n  async function request<T>(\n    path: string,\n    options?: RequestInit,\n    skipRefresh?: boolean,\n  ): Promise<T>\n  ```\n- **Dependencies**: `@/utils/desktop` (for `getBackendBaseUrlSync`)\n- **Reuses**: Existing `ApiError` class (unchanged), existing `localStorage` token storage\n- **Change**: The current `request()` (no refresh) and `authFetch()` (with refresh) merge into a single `request()` that always handles refresh. A `skipRefresh` parameter prevents infinite loops on `/api/auth/refresh`. The `authFetch` named export is removed; `users.ts`, `invitations.ts`, and `auth.ts` are updated to use `api.*` methods or `request()` directly.\n\n### Component 3: Shared Type Cleanup (`shared/src/index.ts`)\n\n- **Purpose**: Eliminate duplicate version manifest types and clarify the `ModLoader`/`LoaderType` relationship.\n- **Changes**:\n\n  **Version manifest types:**\n  ```typescript\n  // KEEP as canonical (lines 764-780):\n  export interface MojangVersionManifest { ... }\n  export interface MojangVersionEntry { ... }\n\n  // REPLACE MinecraftVersion (currently line 841-848) with:\n  /** Launcher-side version entry (subset of MojangVersionEntry, no complianceLevel) */\n  export type MinecraftVersion = Omit<MojangVersionEntry, \"complianceLevel\">;\n\n  // REPLACE VersionManifest (currently line 850-856) with:\n  /** Launcher-side version manifest */\n  export interface VersionManifest {\n    latest: { release: string; snapshot: string };\n    versions: MinecraftVersion[];\n  }\n  ```\n\n  **Loader types:**\n  ```typescript\n  // KEEP ModLoader as-is (line 479):\n  export type ModLoader = \"forge\" | \"fabric\" | \"neoforge\";\n\n  // CHANGE LoaderType (line 784) from standalone to derived:\n  /** Launcher supports all server mod loaders plus Quilt (client-side only) */\n  export type LoaderType = ModLoader | \"quilt\";\n  ```\n\n- **Dependencies**: None\n- **Impact**: All import sites continue to work — `MinecraftVersion` and `VersionManifest` still exist as exported names.\n\n### Component 4: Settings Type Fix (`packages/backend/src/services/settings.ts`)\n\n- **Purpose**: Remove `as unknown as AppSettings` double-cast.\n- **Change**: Build the result object as `AppSettings` directly by constructing it field by field with proper types instead of building a `Record<string, string | number | boolean>` and casting.\n  ```typescript\n  export function getAllSettings(): AppSettings {\n    const db = getDb();\n    const rows = db.prepare(\"SELECT key, value FROM settings\").all() as Array<{\n      key: string;\n      value: string;\n    }>;\n    const stored: Record<string, string> = {};\n    for (const row of rows) {\n      stored[row.key] = row.value;\n    }\n\n    return {\n      javaPath: stored.javaPath ?? DEFAULTS.javaPath,\n      dataDir: stored.dataDir ?? DEFAULTS.dataDir,\n      defaultJvmArgs: stored.defaultJvmArgs ?? DEFAULTS.defaultJvmArgs,\n      maxConsoleLines: stored.maxConsoleLines\n        ? parseInt(stored.maxConsoleLines, 10) || DEFAULTS.maxConsoleLines\n        : DEFAULTS.maxConsoleLines,\n      curseforgeApiKey: stored.curseforgeApiKey ?? DEFAULTS.curseforgeApiKey,\n      showOverridePreview: stored.showOverridePreview\n        ? stored.showOverridePreview === \"true\"\n        : DEFAULTS.showOverridePreview,\n    };\n  }\n  ```\n- **Reuses**: Existing `DEFAULTS` constant, existing `SETTING_KEYS`\n\n### Component 5: WebSocket Message Validation (`packages/backend/src/ws/handlers.ts`)\n\n- **Purpose**: Replace `as unknown as WsClientMessage` casts with proper field access and validation.\n- **Change**: Instead of casting the entire `msg` object, read individual fields with type checks:\n  ```typescript\n  switch (msg.type) {\n    case \"subscribe\": {\n      const serverId = typeof msg.serverId === \"string\" ? msg.serverId : \"\";\n      handleSubscribe(ws, serverId);\n      break;\n    }\n    case \"unsubscribe\": {\n      const serverId = typeof msg.serverId === \"string\" ? msg.serverId : \"\";\n      handleUnsubscribe(ws, serverId);\n      break;\n    }\n    case \"command\": {\n      const serverId = typeof msg.serverId === \"string\" ? msg.serverId : \"\";\n      const command = typeof msg.command === \"string\" ? msg.command : \"\";\n      handleCommand(ws, serverId, command);\n      break;\n    }\n    // ...\n  }\n  ```\n- **Reuses**: Existing `handleSubscribe`, `handleUnsubscribe`, `handleCommand` functions (unchanged). Existing `sendMessage` helper. The handler functions already validate for empty `serverId`/`command`.\n\n### Component 6: Electron Port Fix (`packages/electron/src/main.ts`)\n\n- **Purpose**: Propagate `BACKEND_PORT` to `process.env` so `launcher.ts` reads the correct value.\n- **Change**: One line addition after `startBackend()`:\n  ```typescript\n  async function main(): Promise<void> {\n    setElectronEnv();\n    await app.whenReady();\n    registerIpcHandlers();\n\n    if (!isDev) {\n      await startBackend();\n    }\n\n    // Propagate for launcher.ts and other modules that read BACKEND_PORT\n    process.env.BACKEND_PORT = String(BACKEND_PORT);\n\n    // ... rest unchanged\n  }\n  ```\n\n## Data Models\n\nNo new data models. No database migrations. No schema changes.\n\n## API Endpoints\n\nNo new API endpoints. Existing endpoints preserve their request/response contracts. The only behavioral change: service-layer errors that currently return HTTP 500 will return more specific status codes (400, 404, 409, 502) after REQ-2.\n\n## WebSocket Events\n\nNo new WebSocket events. The WebSocket message handler (`ws/handlers.ts`) is refactored internally but the client-visible protocol is unchanged.\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Service throws for missing resource (e.g., \"No Forge versions found for MC 1.21\")**\n   - **Before**: `throw new Error(msg)` → caught by generic handler → HTTP 500\n   - **After**: `throw new NotFoundError(\"Forge versions\", mcVersion)` → caught by `AppError` handler → HTTP 404 `{ error: \"...\", code: \"NOT_FOUND\" }`\n   - **User Impact**: Frontend receives 404 instead of 500 — can show a meaningful \"not found\" message instead of \"Internal server error\"\n\n2. **Provider fails to reach external API (e.g., Paper API returns 503)**\n   - **Before**: `throw new Error(\"Failed to fetch Paper versions: 503\")` → HTTP 500\n   - **After**: `throw new AppError(\"Failed to fetch Paper versions: 503 Service Unavailable\", 502, \"UPSTREAM_ERROR\")` → HTTP 502\n   - **User Impact**: Frontend can distinguish between \"our server broke\" (500) and \"external service is down\" (502)\n\n3. **Provider receives corrupt/unexpected response**\n   - **Before**: `throw new Error(\"SHA256 mismatch\")` → HTTP 500\n   - **After**: `throw new AppError(\"SHA256 mismatch: expected X, got Y\", 502, \"INTEGRITY_ERROR\")` → HTTP 502\n   - **User Impact**: Same as above — clearer error attribution\n\n4. **Cancellation throws (download/prepare aborted)**\n   - **Before and After**: `throw new Error(\"Cancelled\")` — unchanged. These are caught internally by the download/prepare job logic and never propagate to HTTP.\n\n## Verification Strategy\n\n### Build Verification\n\n- `npm run build` must pass with zero errors after each task\n- `npm test` must pass (existing 136 tests must remain green)\n\n### Manual Testing Checklist\n\n1. **Validation utility**: Start a server, send a `POST /api/servers` with an invalid body → verify the response is still `400` with the same error format as before\n2. **Error migration**: Trigger a version fetch for a nonsupported type → verify the response is `400` (not `500`)\n3. **API client**: Log in, wait for access token to expire, perform an API action → verify auto-refresh still works\n4. **Shared types**: `npm run build` succeeds (TypeScript will catch any import/usage mismatches)\n5. **Settings cast**: Load app settings page → verify settings load correctly\n6. **WebSocket**: Open console, subscribe to a server, send a command → verify all work as before\n7. **Electron port**: (if testing Electron) Set `PORT=3005`, launch Electron app, verify game launching attempts connect to port 3005\n\n### Parity / Migration Checks\n\n| Existing Behavior | New Implementation | Verify |\n|---|---|---|\n| Validation returns `400` with `{ error: \"path: msg; path2: msg2\", code: \"VALIDATION_ERROR\" }` | Same format via `validate()` utility | Compare response bodies before/after |\n| Service errors return `500` | Service errors return appropriate 4xx/5xx | Check specific error scenarios return correct codes |\n| `authFetch()` refreshes token on 401 | `request()` refreshes token on 401 | Log in, wait for token expiry, make API call |\n| `MinecraftVersion` / `VersionManifest` types compile | Same names still compile | `npm run build` succeeds |\n\n## Implementation Order\n\n1. **Shared type cleanup** (REQ-4) — No dependencies. Changes type definitions that downstream tasks reference. Must go first so all packages build cleanly.\n2. **Validation utility** (REQ-1) — New file, no dependencies on other tasks. Foundation for REQ-5.\n3. **Route param/query validation** (REQ-5) — Depends on (2) for the `validate()` utility.\n4. **Service error migration** (REQ-2) — Independent of (2)/(3) but logically follows. Largest task by volume.\n5. **Settings and WebSocket type fixes** (REQ-6) — Small, focused fixes. Independent of other tasks.\n6. **Frontend API client consolidation** (REQ-3) — Frontend-only. Independent of backend tasks.\n7. **Electron port fix** (REQ-7) — One line. Independent of everything else.\n\nEach step can be verified independently via `npm run build` + `npm test` before proceeding.\n\n## Migration / Backward Compatibility\n\nAll changes are internal refactors. The external API surface (HTTP endpoints, WebSocket messages, response shapes) is preserved exactly, with one intentional improvement: service errors now return appropriate HTTP status codes instead of always 500.\n\nNo database migration is needed. No new npm dependencies are added. The `MinecraftVersion` and `VersionManifest` type names continue to exist as exported aliases, so frontend import sites require zero changes for the type rename.\n",
  "fileStats": {
    "size": 15320,
    "lines": 301,
    "lastModified": "2026-02-15T22:08:09.587Z"
  },
  "comments": []
}
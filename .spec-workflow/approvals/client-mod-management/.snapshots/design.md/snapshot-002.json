{
  "id": "snapshot_1770854146260_qyedrqd36",
  "approvalId": "approval_1770854072878_4ik8k43xe",
  "approvalTitle": "EPIC-4 Client Mod Management - Design",
  "version": 2,
  "timestamp": "2026-02-11T23:55:46.260Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document -- Client Mod Management\n\n## Overview\n\nGeneralize the existing server mod management system to support client game instances. The core change is a `ModTarget` abstraction that lets `ModService`, `ModpackService`, and the frontend components work with both servers and instances through a unified interface. This avoids duplicating the Modrinth client, dependency resolver, modpack parser, and UI components.\n\n## Steering Document Alignment\n\nNo steering docs exist. This design follows project conventions and builds directly on Epic 2's existing patterns.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage (Heavy Reuse)\n- **`packages/backend/src/services/mod-manager.ts`**: Core mod service. Refactored from `serverId` params to `ModTarget` params. All business logic (dependency resolution, hash verification, update checking) stays the same.\n- **`packages/backend/src/services/modpack-manager.ts`**: Modpack import/export. Refactored to `ModTarget`. Override application logic differs for client (uses `overrides/` not `server-overrides/`).\n- **`packages/backend/src/services/modpack-parser.ts`**: `.mrpack` parsing. No changes needed -- already target-agnostic.\n- **`packages/backend/src/routes/mods.ts`**: Server mod routes. Pattern replicated for instance mod routes.\n- **`packages/frontend/src/pages/Mods.tsx`**: Mod search UI. Generalized with `targetType` prop.\n- **`packages/frontend/src/components/ModList.tsx`**: Installed mod list. Generalized with `targetType` prop.\n- **`packages/frontend/src/api/client.ts`**: API client. Instance mod methods added following same patterns.\n\n### Integration Points\n- **`installed_mods` table**: Extended with `instance_id` column (nullable, mutually exclusive with `server_id` via CHECK constraint)\n- **Modrinth search routes**: Add `side` query parameter for client-side filtering\n- **Mod loader service**: Extended with client-specific Fabric installation (profile JSON + Maven libraries vs server launcher JAR)\n- **Instance detail page**: New Mods tab using generalized mod components\n\n## Architecture\n\n### ModTarget Abstraction\n\nThe key architectural change is introducing `ModTarget` -- a common interface that abstracts the difference between servers and instances from the mod system's perspective:\n\n```\n                    ModTarget\n                   ┌──────────────────┐\n                   │ type: server|inst │\n                   │ id: string       │\n                   │ modsDir: string   │\n                   │ mcVersion: string │\n                   │ loader: ModLoader │\n                   │ loaderVersion: str│\n                   └────────┬─────────┘\n                            │\n              ┌─────────────┼─────────────┐\n              │                           │\n     serverToModTarget()         instanceToModTarget()\n              │                           │\n     ┌────────┴────────┐       ┌──────────┴──────────┐\n     │ Server          │       │ LauncherInstance     │\n     │ (existing)      │       │ (from Epic 3)       │\n     └─────────────────┘       └─────────────────────┘\n```\n\n### Service Refactor Pattern\n\n```\nBefore (Epic 2):\n  ModService.installMod(serverId, request)\n    → modModel.getByServerId(serverId)\n    → path.join(server.path, 'mods')\n    → server.version, server.loader\n\nAfter (Epic 4):\n  ModService.installMod(target: ModTarget, request)\n    → target.type === 'server' ? modModel.getByServerId(target.id) : modModel.getByInstanceId(target.id)\n    → target.modsDir\n    → target.mcVersion, target.loader\n```\n\n### Client Loader Installation Flow\n\n```\nFabric Server (Epic 2):              Fabric Client (Epic 4):\n──────────────────────                ──────────────────────\n1. Fetch loader versions              1. Fetch loader versions (same API)\n2. Download server launcher JAR        2. Download profile JSON\n3. Save as fabric-server-launch.jar    3. Save to instances/versions/{id}/\n4. Update server jarPath               4. Download Maven libraries\n                                       5. Update instance loader fields\n```\n\n### Modular Design Principles\n- **Single Interface Change**: `serverId: string` → `target: ModTarget` is the only parameter change across all mod service methods.\n- **Route Separation**: Instance mod routes live in `instance-mods.ts`, completely separate from server mod routes.\n- **Component Generalization**: Frontend components accept `targetType` and `targetId` props, construct the appropriate API base URL internally.\n- **No Cross-Contamination**: Server mod functionality is 100% unchanged after the refactor.\n\n## Components and Interfaces\n\n### Component 1: ModTarget Type (`shared/src/index.ts`)\n- **Purpose**: Common interface abstracting server/instance for mod operations\n- **Interface**: `{ type: 'server'|'instance', id: string, modsDir: string, mcVersion: string, loader: ModLoader|null, loaderVersion: string|null }`\n- **Dependencies**: None\n- **Reuses**: Existing `ModLoader` type\n\n### Component 2: ModService Refactor (`packages/backend/src/services/mod-manager.ts`)\n- **Purpose**: Generalize all mod operations to work with ModTarget\n- **Interface changes**: All methods change `serverId: string` → `target: ModTarget`\n- **Dependencies**: ModModel (extended), ModrinthClient (unchanged)\n- **Reuses**: All existing business logic -- dependency resolution, hash verification, update checking\n\n### Component 3: ModModel Extension (`packages/backend/src/models/mod.ts` equivalent)\n- **Purpose**: Add instance-aware queries alongside existing server queries\n- **New methods**: `getByInstanceId(id)`, `deleteByInstanceId(id)`, `getByTarget(type, id)`\n- **Dependencies**: better-sqlite3\n- **Reuses**: Existing prepared statement patterns\n\n### Component 4: Client Loader Installation (`packages/backend/src/services/mod-loader-service.ts` extension)\n- **Purpose**: Install Fabric client profile (different from server Fabric installation)\n- **New methods**: `installClientLoader(instanceId, loader, loaderVersion?)`, `getClientLoaderVersions()`, `removeClientLoader(instanceId)`\n- **Dependencies**: Fabric Meta API, instance model, library download\n- **Reuses**: Existing `getLoaderVersions()` method (same Fabric API)\n\n### Component 5: Instance Mod Routes (`packages/backend/src/routes/instance-mods.ts`)\n- **Purpose**: REST endpoints for instance mod operations\n- **Endpoints**: Same pattern as server mod routes but under `/api/launcher/instances/:id/mods/*`\n- **Dependencies**: ModService (with ModTarget), instance model\n- **Reuses**: Route handler pattern from existing `mods.ts`\n\n### Component 6: Generalized Frontend Components\n- **Purpose**: Mod manager UI that works for both servers and instances\n- **Interface change**: Components accept `targetType: 'server'|'instance'` and `targetId: string` instead of `serverId`\n- **Dependencies**: API client (extended)\n- **Reuses**: All existing mod UI components -- just parameterized\n\n## Data Models\n\n### installed_mods table (migration -- extend existing)\n```sql\n-- Recreate with instance_id column and CHECK constraint\nCREATE TABLE installed_mods_new (\n  id            TEXT PRIMARY KEY,\n  server_id     TEXT REFERENCES servers(id) ON DELETE CASCADE,\n  instance_id   TEXT REFERENCES launcher_instances(id) ON DELETE CASCADE,\n  file_name     TEXT NOT NULL,\n  file_hash     TEXT NOT NULL,\n  file_size     INTEGER NOT NULL,\n  modrinth_id   TEXT,\n  modrinth_version_id TEXT,\n  name          TEXT NOT NULL,\n  slug          TEXT,\n  version       TEXT,\n  loader        TEXT,\n  mc_versions   TEXT,\n  side          TEXT DEFAULT 'both',\n  icon_url      TEXT,\n  enabled       INTEGER NOT NULL DEFAULT 1,\n  installed_at  TEXT NOT NULL DEFAULT (datetime('now')),\n  updated_at    TEXT NOT NULL DEFAULT (datetime('now')),\n  CHECK ((server_id IS NOT NULL AND instance_id IS NULL) OR\n         (server_id IS NULL AND instance_id IS NOT NULL)),\n  UNIQUE(server_id, file_name),\n  UNIQUE(instance_id, file_name)\n);\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Client loader installation fails mid-download**\n   - **Handling**: Libraries are downloaded individually with retry. Partial state is cleaned up. Instance record is not updated until all downloads succeed.\n   - **User Impact**: \"Failed to install Fabric. Some libraries could not be downloaded. [Retry]\"\n\n2. **Server-only mod installed on instance**\n   - **Handling**: Modrinth search filters by `client_side`, but manual installs (by version ID) check and warn. Installation proceeds with a warning.\n   - **User Impact**: Warning toast: \"This mod is server-side only and may not work in your game client.\"\n\n3. **ModTarget conversion fails (instance not found)**\n   - **Handling**: Route handler returns 404 before calling ModService.\n   - **User Impact**: Standard \"Instance not found\" error.\n\n4. **Database migration fails (table recreation)**\n   - **Handling**: Migration uses transaction. Old table data is preserved if migration fails.\n   - **User Impact**: App fails to start. User sees migration error in logs.\n\n## File Structure\n\n### New Files\n```\npackages/backend/src/routes/instance-mods.ts      # Instance mod CRUD routes\npackages/backend/migrations/008_client_mods.sql    # Add instance_id to installed_mods\n```\n\n### Modified Files\n```\nshared/src/index.ts                                # ModTarget type, InstalledMod.instanceId\npackages/backend/src/services/mod-manager.ts       # Refactor to ModTarget\npackages/backend/src/services/modpack-manager.ts   # Refactor to ModTarget\npackages/backend/src/models/mod.ts (or equivalent) # Add instance queries\npackages/backend/src/services/mod-loader-service.ts (or equivalent) # Add client loader methods\npackages/backend/src/routes/mods.ts (or equivalent)# Add side filter to Modrinth search\npackages/backend/src/app.ts                        # Mount instance-mods routes\npackages/frontend/src/components/ModList.tsx        # Generalize with targetType prop\npackages/frontend/src/pages/Mods.tsx               # Generalize with targetType prop\npackages/frontend/src/api/client.ts                # Add instance mod API methods\n```\n\n## Testing Strategy\n\n### Unit Testing\n- No automated tests exist. Manual verification.\n- Key verification: install a mod on a server, verify it still works after refactor. Install same mod on instance, verify it works.\n\n### Integration Testing\n- **Backward compatibility**: All existing server mod operations work identically after refactor\n- **Client mod install**: Install Sodium on a Fabric instance -> Fabric API auto-installs -> both appear in list\n- **Client mod search**: Search from instance shows client-compatible mods, server-only mods hidden\n- **Client loader**: Install Fabric on vanilla instance -> profile JSON + libraries downloaded -> instance launches with Fabric\n- **Modpack import**: Import .mrpack to instance -> overrides applied to instance dir (not server-overrides)\n- **Cross-target**: Same mod installed on server and instance independently, no interference\n\n### End-to-End Testing\n- Create server with Fabric + Sodium -> Create instance with Fabric + Sodium -> Both work independently\n- Export server modpack -> Import to instance -> Mods match\n- Disable mod on instance -> Launch game -> Mod not loaded -> Re-enable -> Mod loaded\n",
  "fileStats": {
    "size": 11664,
    "lines": 218,
    "lastModified": "2026-02-11T23:54:20.292Z"
  },
  "comments": []
}
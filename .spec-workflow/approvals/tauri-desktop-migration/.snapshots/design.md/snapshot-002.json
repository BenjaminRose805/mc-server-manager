{
  "id": "snapshot_1770833054360_a0c0r5m3t",
  "approvalId": "approval_1770832856569_o2v3lnuy3",
  "approvalTitle": "EPIC-1 Tauri Desktop Migration - Design",
  "version": 2,
  "timestamp": "2026-02-11T18:04:14.360Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document -- Tauri Desktop App Migration\n\n## Overview\n\nReplace the current Electron desktop shell (`packages/electron/`) with a Tauri 2.0 desktop application (`packages/desktop/`). The Express backend becomes a sidecar binary (packaged via `@yao-pkg/pkg`) instead of being loaded in-process via dynamic import as Electron does today. The React frontend continues loading in a WebView. This migration yields a ~10x smaller installer, a stronger security sandbox, and a Rust core that will host future performance-critical features (game launching, file I/O).\n\n**Note:** The existing Electron implementation already solves the same user-facing problems (desktop window, tray icon, backend lifecycle). This spec is an architectural migration from Electron to Tauri, not a greenfield feature.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\nNo steering docs exist. This design follows established project conventions:\n- TypeScript strict mode for all new TS code\n- Rust (stable edition 2021) for the Tauri core\n- ES modules throughout\n- Existing backend/frontend packages remain unchanged in their core logic\n\n### Project Structure (structure.md)\nNew `packages/desktop/` workspace follows the same monorepo pattern as `packages/electron/`, `packages/backend/`, and `packages/frontend/`. The workspace is self-contained with its own `package.json`, build scripts, and Tauri-specific configuration.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`packages/backend/` (entire package)**: Runs as-is inside the sidecar binary. Only `config.ts` needs a small patch for Tauri-specific env vars (`TAURI_DATA_DIR`, `TAURI_RESOURCE_DIR`) alongside the existing `MC_DATA_DIR` support.\n- **`packages/frontend/` (entire package)**: Loads unchanged in the WebView. Only `api/ws.ts` needs Tauri environment detection to use direct URLs instead of `window.location`-based URLs.\n- **`packages/electron/src/main.ts` patterns**: The `setElectronEnv()`, `waitForServer()`, `createWindow()`, and `createTray()` patterns will be reimplemented in Rust. The logic is identical; the language changes.\n- **Backend graceful shutdown**: The existing SIGTERM handler in `packages/backend/src/index.ts` handles stopping all MC servers. The Tauri layer just needs to send the kill signal -- same as Electron's `before-quit` handler.\n\n### Integration Points\n- **Backend config.ts**: Add `TAURI_DATA_DIR` as another env var option (alongside existing `DATA_DIR` and `MC_DATA_DIR`)\n- **Frontend ws.ts**: Add Tauri environment detection to `getUrl()` method so it returns `ws://localhost:3001/ws` when running in Tauri's WebView\n- **Frontend main.tsx**: Add optional `waitForBackend()` call gated on Tauri detection\n- **Root package.json**: Add `dev:desktop` and `build:desktop` scripts (alongside existing `dev:electron` and `build:electron`)\n\n## Architecture\n\nThe architecture replaces Electron's Node.js main process with Tauri's Rust core. The backend shifts from an in-process dynamic import to an external sidecar binary.\n\n### Current Architecture (Electron)\n```\n┌─────────────────────────────────────┐\n│  Electron Main Process (Node.js)    │\n│  ├── dynamic import(@backend)       │  ← Backend runs IN the Electron process\n│  ├── BrowserWindow (Chromium)       │\n│  ├── Tray icon                      │\n│  └── Graceful shutdown              │\n│       ┌─────────────────────┐       │\n│       │ Renderer (React SPA)│       │\n│       │ loads from backend  │       │\n│       │ or Vite dev server  │       │\n│       └─────────────────────┘       │\n└─────────────────────────────────────┘\n```\n\n### Target Architecture (Tauri)\n```\n┌──────────────────────────────────────────────┐\n│  Tauri App                                   │\n│  ┌────────────────────────────────────────┐  │\n│  │ WebView (React SPA)                    │  │\n│  │  • Loads from Vite dev server (dev)    │  │\n│  │  • Loads from bundled dist/ (prod)     │  │\n│  │  • HTTP/WS to localhost:3001           │  │\n│  └─────────────┬──────────────────────────┘  │\n│                │                             │\n│  ┌─────────────▼──────────────────────────┐  │\n│  │ Rust Core                              │  │\n│  │  • Spawns/manages backend sidecar      │  │\n│  │  • Window management, tray icon        │  │\n│  │  • (Future: game launching, file I/O)  │  │\n│  └─────────────┬──────────────────────────┘  │\n│                │ child_process               │\n│  ┌─────────────▼──────────────────────────┐  │\n│  │ Backend Sidecar (standalone binary)    │  │\n│  │  • Express HTTP + WS on :3001          │  │\n│  │  • SQLite, Java process management     │  │\n│  │  • Identical code to current backend   │  │\n│  └────────────────────────────────────────┘  │\n└──────────────────────────────────────────────┘\n```\n\n### Key Architectural Differences from Electron\n\n| Aspect | Electron (current) | Tauri (target) |\n|--------|-------------------|----------------|\n| Backend hosting | In-process dynamic import | External sidecar binary |\n| Backend packaging | Ships as JS files in `extraResources` | Compiled to standalone binary via `@yao-pkg/pkg` |\n| Native module (`better-sqlite3`) | Electron-rebuilt `.node` addon | Shipped alongside sidecar as separate file |\n| Window engine | Chromium (bundled, ~150MB) | OS WebView (0MB overhead) |\n| Core language | JavaScript (Node.js) | Rust |\n| Security model | `contextIsolation` + preload script | Capabilities-based permissions |\n| IPC | Electron IPC bridge | Not used in this phase (HTTP/WS only) |\n| App size | ~150-200MB installer | ~10-20MB + sidecar (~50-80MB) |\n\n### Modular Design Principles\n- **Single File Responsibility**: `lib.rs` handles Tauri setup + sidecar management. Tray logic is extracted if it grows beyond ~50 lines.\n- **Component Isolation**: Frontend Tauri utilities (`isTauri()`, `waitForBackend()`) are isolated in `utils/` and don't affect non-Tauri code paths.\n- **Service Layer Separation**: The Rust core only manages process lifecycle. All business logic stays in the Express backend.\n- **Utility Modularity**: Backend path resolution (`config.ts`) uses a chain of env var checks -- each desktop shell adds its own env var without disturbing others.\n\n## Components and Interfaces\n\n### Component 1: Rust Core (`packages/desktop/src-tauri/src/lib.rs`)\n- **Purpose**: Tauri application setup, sidecar lifecycle management, system tray, window management\n- **Interfaces**:\n  - `spawn_backend(app: &AppHandle) -> Result<()>` -- Spawns the sidecar with appropriate env vars\n  - `AppState { backend_child: Mutex<Option<CommandChild>> }` -- Managed state for sidecar handle\n  - `on_window_event` -- Close-to-tray behavior\n  - `on_menu_event` -- Tray menu actions (Show, Quit)\n- **Dependencies**: `tauri`, `tauri-plugin-shell`, `tauri-plugin-process`\n- **Reuses**: Same lifecycle pattern as `packages/electron/src/main.ts` (`startBackend` -> `waitForServer` -> `createWindow` -> `createTray`)\n\n### Component 2: Backend Packaging Script (`packages/desktop/scripts/package-backend.ts`)\n- **Purpose**: Compile the Express backend into a standalone binary using `@yao-pkg/pkg`\n- **Interfaces**: CLI script, no API. Run via `npm run package-backend -w desktop`\n- **Dependencies**: `@yao-pkg/pkg`, `child_process`, `fs`\n- **Reuses**: Existing backend build output (`packages/backend/dist/`)\n\n### Component 3: Tauri Environment Detection (`packages/frontend/src/utils/tauri.ts`)\n- **Purpose**: Detect if running inside Tauri WebView, provide environment-appropriate URLs\n- **Interfaces**:\n  - `isTauri(): boolean` -- Checks for `__TAURI_INTERNALS__` on window\n- **Dependencies**: None\n- **Reuses**: Pattern similar to how `packages/electron/src/main.ts` checks `app.isPackaged`\n\n### Component 4: Backend Readiness Poller (`packages/frontend/src/utils/wait-for-backend.ts`)\n- **Purpose**: Poll the backend health endpoint before rendering the app (Tauri mode only)\n- **Interfaces**:\n  - `waitForBackend(url?: string, maxAttempts?: number, intervalMs?: number): Promise<void>`\n- **Dependencies**: `fetch`\n- **Reuses**: Same logic as `waitForServer()` in `packages/electron/src/main.ts`, but runs in the frontend instead of the main process\n\n### Component 5: Backend Config Enhancement (`packages/backend/src/config.ts`)\n- **Purpose**: Add Tauri-specific environment variable support for data directory resolution\n- **Interfaces**: Existing `config` object, no API change\n- **Dependencies**: None new\n- **Reuses**: Extends existing `resolveDataDir()` function which already checks `DATA_DIR` and `MC_DATA_DIR`\n\n## Data Models\n\nNo new data models. The migration is purely an application shell change. The SQLite database schema, server model, and settings model are unchanged.\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Backend sidecar fails to start**\n   - **Handling**: Rust core logs the error from sidecar stdout/stderr. Frontend's `waitForBackend()` times out after 15 seconds.\n   - **User Impact**: Loading screen shows for 15s, then an error message: \"Backend failed to start within timeout.\"\n\n2. **Backend sidecar crashes during operation**\n   - **Handling**: Rust core receives `CommandEvent::Terminated` and logs exit code/signal. Frontend's existing WebSocket auto-reconnect detects disconnection.\n   - **User Impact**: Existing connection-lost UI appears (from WebSocket disconnect handlers in `serverStore.ts`). No automatic restart in this phase.\n\n3. **Port 3001 already in use**\n   - **Handling**: Backend's `listen()` call fails with EADDRINUSE. Error surfaces in sidecar stderr, logged by Rust core.\n   - **User Impact**: `waitForBackend()` times out. User sees startup failure message. Future enhancement: configurable port.\n\n4. **`better-sqlite3` native module not found**\n   - **Handling**: Backend crashes immediately on startup with a module load error. Logged by Rust core.\n   - **User Impact**: Same as scenario 1 (startup timeout).\n\n5. **WebView CSP blocks backend connection**\n   - **Handling**: Fetch/WebSocket calls fail. Frontend error handling shows toast errors.\n   - **User Impact**: App loads but shows connection errors. Fix requires updating CSP in `tauri.conf.json`.\n\n## File Structure\n\n### New Files\n```\npackages/desktop/\n├── package.json                           # Workspace package with Tauri deps\n├── scripts/\n│   └── package-backend.ts                 # pkg binary packaging script\n└── src-tauri/\n    ├── tauri.conf.json                    # Tauri configuration (window, CSP, sidecar)\n    ├── Cargo.toml                         # Rust dependencies\n    ├── capabilities/\n    │   └── default.json                   # Security permissions (shell, process)\n    ├── icons/                             # Platform icons (generated)\n    │   ├── 32x32.png\n    │   ├── 128x128.png\n    │   ├── 128x128@2x.png\n    │   ├── icon.icns\n    │   ├── icon.ico\n    │   └── icon.png\n    ├── binaries/                          # Packaged backend binary (build artifact)\n    └── src/\n        ├── main.rs                        # Entry point (#[cfg] delegates to lib)\n        └── lib.rs                         # Sidecar mgmt, tray, window events\n\npackages/frontend/src/utils/\n├── tauri.ts                               # isTauri() detection\n└── wait-for-backend.ts                    # Health check poller\n```\n\n### Modified Files\n```\npackage.json                               # Add desktop workspace, dev:desktop, build:desktop\npackages/backend/src/config.ts             # Add TAURI_DATA_DIR env var check\npackages/frontend/src/api/ws.ts            # Tauri-aware URL in getUrl()\npackages/frontend/src/main.tsx             # waitForBackend() before render in Tauri mode\npackages/frontend/index.html               # Loading screen placeholder in #root\n```\n\n### Files NOT Modified\n```\npackages/electron/                         # Left intact -- can coexist during migration\npackages/backend/src/                      # No changes except config.ts\npackages/frontend/src/api/client.ts        # Already uses relative URLs (works with proxy & direct)\nshared/                                    # No changes\n```\n\n## Testing Strategy\n\n### Unit Testing\n- No automated test framework exists in the project yet. Manual testing is the current approach.\n- The `waitForBackend()` utility is simple enough to verify via manual browser testing.\n- The `isTauri()` detection can be verified by checking behavior in browser vs. Tauri WebView.\n\n### Integration Testing\n- **Dev workflow**: Verify `npm run dev:desktop` starts Tauri window with frontend loading from Vite\n- **Backend sidecar**: Verify backend auto-starts, API responds, WebSocket connects from within Tauri\n- **External backend mode**: Verify `TAURI_DEV_BACKEND_EXTERNAL=1` skips sidecar spawn\n- **Coexistence**: Verify `npm run dev` (browser) and `npm run dev:electron` still work unchanged\n\n### End-to-End Testing\n- **Full lifecycle**: Launch app -> create MC server -> start server -> verify console output -> stop server -> quit app (via tray) -> verify all processes terminated\n- **Close-to-tray**: Close window -> verify tray icon present -> verify MC server still running -> restore window -> verify console still streaming\n- **Production build**: `npm run build:desktop` produces working installer -> install -> launch -> verify all features\n- **Cross-platform**: Build and test on Windows, macOS, and Linux (via CI matrix)\n- **Backend crash**: Kill sidecar process externally -> verify frontend shows disconnect -> verify no orphan Java processes\n",
  "fileStats": {
    "size": 14750,
    "lines": 233,
    "lastModified": "2026-02-11T18:00:52.032Z"
  },
  "comments": []
}
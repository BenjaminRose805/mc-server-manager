{
  "id": "snapshot_1770853314438_prcws33t2",
  "approvalId": "approval_1770853314434_9chidpy8y",
  "approvalTitle": "EPIC-3 Minecraft Client Launcher - Tasks",
  "version": 1,
  "timestamp": "2026-02-11T23:41:54.438Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document -- Minecraft Client Launcher\n\n- [ ] 1. Add launcher shared types and database migrations\n  - Files: `shared/src/index.ts` (modify), `packages/backend/migrations/006_launcher_instances.sql` (new), `packages/backend/migrations/007_launcher_accounts.sql` (new)\n  - Add all launcher types to shared: `LauncherInstance`, `CreateInstanceRequest`, `UpdateInstanceRequest`, `LauncherAccount`, `MinecraftVersion`, `VersionManifest`, `JavaInstallation`, `MSAuthDeviceCode`, `MSAuthStatus`, `LaunchGameRequest`, `GameProcess`\n  - Create migration for `launcher_instances` table with all columns from design (id, name, mc_version, version_type, loader, loader_version, java_version, java_path, ram_min, ram_max, resolution, jvm_args, game_args, icon, last_played, total_playtime, timestamps)\n  - Create migration for `launcher_accounts` table (id, uuid, username, account_type, last_used, created_at)\n  - Purpose: Foundation types and database schema for all launcher functionality\n  - _Leverage: `shared/src/index.ts` for existing type patterns, `packages/backend/migrations/003_mods.sql` for migration pattern, `plans/EPIC-3-client-launcher.md` for exact type definitions and SQL_\n  - _Requirements: REQ-2, REQ-3_\n  - _Prompt: Implement the task for spec minecraft-client-launcher, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: TypeScript Developer with expertise in shared type definitions and SQLite schema design | Task: (1) Read `shared/src/index.ts` and add all launcher types from `.spec-workflow/specs/minecraft-client-launcher/design.md` Data Models section and `plans/EPIC-3-client-launcher.md` Shared Types section. Types to add: `LauncherInstance`, `CreateInstanceRequest`, `UpdateInstanceRequest`, `LauncherAccount`, `MinecraftVersion`, `VersionManifest`, `JavaInstallation`, `MSAuthDeviceCode`, `MSAuthStatus`, `LaunchGameRequest`, `GameProcess`. (2) Check existing migrations in `packages/backend/migrations/` to determine the next migration number. Create `006_launcher_instances.sql` with the `launcher_instances` table schema from the design doc. Create `007_launcher_accounts.sql` with the `launcher_accounts` table. Include indexes. | Restrictions: Do NOT modify any existing types. Do NOT modify existing migration files. Follow the exact column names and types from the design doc. Use TEXT PRIMARY KEY with nanoid pattern matching existing tables. | Success: All types compile without errors, migrations are valid SQL, migration numbers don't conflict with existing files. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 2. Create instance model and service\n  - Files: `packages/backend/src/models/instance.ts` (new), `packages/backend/src/services/instance-service.ts` (new)\n  - Implement `InstanceModel` with prepared statements: `getAll()`, `getById()`, `create()`, `update()`, `delete()`, with snake_case to camelCase mapping\n  - Implement `InstanceService` with: `listInstances()`, `getInstanceById()`, `createInstance()`, `updateInstance()`, `deleteInstance()`\n  - Instance creation: infer Java version from MC version, create isolated directory structure (saves, mods, resourcepacks, shaderpacks)\n  - Instance deletion: remove directory recursively + DB record\n  - Purpose: Backend CRUD for game instances with directory management\n  - _Leverage: `packages/backend/src/models/server.ts` for model pattern, `packages/backend/src/services/server-manager.ts` for service patterns, `plans/EPIC-3-client-launcher.md` Phase 3D_\n  - _Requirements: REQ-2_\n  - _Prompt: Implement the task for spec minecraft-client-launcher, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in SQLite models and service layer architecture | Task: (1) Create `packages/backend/src/models/instance.ts` following the pattern in `packages/backend/src/models/server.ts`. Use prepared statements. Map snake_case DB columns to camelCase TypeScript. Methods: `getAll()` (ORDER BY last_played DESC), `getById(id)`, `create(data)` (generate nanoid), `update(id, updates)`, `delete(id)`. Handle JSON serialization for `jvm_args` and `game_args` columns. (2) Create `packages/backend/src/services/instance-service.ts` with `InstanceService` class. Methods: `listInstances()`, `getInstanceById(id)`, `createInstance(request)`, `updateInstance(id, updates)`, `deleteInstance(id)`. On create: infer Java version from MC version (1.16 and below to 8, 1.17 to 16, 1.18-1.20.4 to 17, 1.20.5+ to 21), create directory at `{dataDir}/launcher/instances/{id}/` with subdirs (saves, mods, resourcepacks, shaderpacks). On delete: rm -rf instance directory + DB delete. Reference `plans/EPIC-3-client-launcher.md` Phase 3D and `.spec-workflow/specs/minecraft-client-launcher/design.md`. | Restrictions: Use `.js` extensions in imports. Do NOT add route handling (that's a separate task). Do NOT import from `@tauri-apps/api`. Follow existing singleton export pattern. | Success: Model compiles, service compiles, directory creation works, Java version inference is correct for all MC version ranges. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 3. Create version service for client versions\n  - Files: `packages/backend/src/services/version-service.ts` (new)\n  - Implement `VersionService` with: `getManifest()` (1hr cache), `getVersions(type?)`, `downloadVersionJson(versionId)` (SHA1 verify), `downloadGameJar(versionId)` (SHA1 verify)\n  - Downloads go to `{dataDir}/launcher/versions/{versionId}/`\n  - Skip already-downloaded files (hash-based dedup)\n  - Purpose: Manage Mojang version manifest and client JAR downloads\n  - _Leverage: `packages/backend/src/services/versions.ts` for existing version manifest fetching pattern, `plans/EPIC-3-client-launcher.md` Phase 3B_\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec minecraft-client-launcher, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in HTTP clients and file download verification | Task: Create `packages/backend/src/services/version-service.ts`. Read existing `packages/backend/src/services/versions.ts` for the caching pattern. Implement `VersionService` class with: (1) `getManifest()` - fetch from `https://launchermeta.mojang.com/mc/game/version_manifest_v2.json` with 1hr memory cache, (2) `getVersions(type?)` - filter by release/snapshot/etc, (3) `downloadVersionJson(versionId)` - download version JSON to `{dataDir}/launcher/versions/{id}/{id}.json`, verify SHA1 hash, skip if exists, (4) `downloadGameJar(versionId)` - download client JAR from version JSON's `downloads.client.url`, verify SHA1, skip if exists. Constructor takes `dataDir` string, creates `launcher/versions/` dir. Use `crypto.createHash('sha1')` for verification. Reference `plans/EPIC-3-client-launcher.md` Phase 3B. | Restrictions: Use `.js` extensions in imports. Do NOT conflate with the existing `versions.ts` (that's for server JARs). Do NOT add routes. Keep as standalone service file. | Success: Service compiles, version manifest fetches and caches, version JSON downloads with hash verification, game JAR downloads with hash verification, already-downloaded files are skipped. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 4. Create asset and library download services\n  - Files: `packages/backend/src/services/asset-service.ts` (new), `packages/backend/src/services/library-service.ts` (new)\n  - Asset service: `downloadAssetIndex()`, `downloadAssets(onProgress?)` with parallel fetching (concurrency 10), hash-based storage in `assets/objects/{hash[:2]}/{hash}`\n  - Library service: `downloadLibraries(onProgress?)` with platform rule filtering (`rules[].action/os`), `extractNatives()` using adm-zip, classpath construction\n  - Purpose: Download all game files required to launch Minecraft\n  - _Leverage: `packages/backend/src/services/download.ts` for download patterns, `plans/EPIC-3-client-launcher.md` Phases 3B.2 and 3B.3_\n  - _Requirements: REQ-3_\n  - _Prompt: Implement the task for spec minecraft-client-launcher, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in concurrent file downloads and platform-specific builds | Task: (1) Create `packages/backend/src/services/asset-service.ts`. Constructor takes `dataDir`. Methods: `downloadAssetIndex(versionJson)` - download index to `assets/indexes/{id}.json` with SHA1 verify, `downloadAssets(versionJson, onProgress?)` - download all asset objects to `assets/objects/{hash[:2]}/{hash}`, parallel with concurrency limit of 10, skip existing, report progress via callback. (2) Create `packages/backend/src/services/library-service.ts`. Constructor takes `dataDir`. Methods: `downloadLibraries(versionJson, onProgress?)` - filter libraries by platform rules (`rules[].action` allow/disallow, `rules[].os.name`), download to `libraries/{artifact.path}`, verify SHA1, return classpath array. `extractNatives(versionJson, nativesDir)` - find native libraries for current platform, extract JARs using `adm-zip`. Platform mapping: win32→windows, darwin→osx, linux→linux. Add `adm-zip` as a backend dependency if not present. Reference `plans/EPIC-3-client-launcher.md` Phases 3B.2 and 3B.3 for exact implementation. | Restrictions: Use `.js` extensions in imports. Do NOT download server-side libraries. Handle missing/optional download URLs gracefully (warn, don't crash). SHA1 verify all downloads. | Success: Asset service downloads and verifies assets with parallel fetching, library service filters by platform rules correctly, native extraction works, classpath array is correctly constructed. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 5. Create launcher REST routes\n  - Files: `packages/backend/src/routes/launcher.ts` (new), `packages/backend/src/app.ts` (modify)\n  - Instance CRUD: GET/POST `/api/launcher/instances`, GET/PATCH/DELETE `/api/launcher/instances/:id`\n  - Version listing: GET `/api/launcher/versions?type=release`\n  - Download preparation: POST `/api/launcher/prepare/:id` (downloads version JSON, JAR, libraries, assets; returns classpath + metadata)\n  - Account CRUD: GET/POST/DELETE `/api/launcher/accounts`\n  - Zod validation for all request bodies\n  - Mount routes in app.ts\n  - Purpose: HTTP API for launcher operations\n  - _Leverage: `packages/backend/src/routes/servers.ts` for route patterns, `plans/EPIC-3-client-launcher.md` Phase 3D.3_\n  - _Requirements: REQ-2, REQ-3_\n  - _Prompt: Implement the task for spec minecraft-client-launcher, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Backend Node.js Developer with expertise in Express routing and Zod validation | Task: (1) Create `packages/backend/src/routes/launcher.ts` with routes: `GET /instances` (list all), `POST /instances` (create with Zod validation: name, mcVersion, versionType?, loader?, loaderVersion?, ramMin?, ramMax?), `GET /instances/:id`, `PATCH /instances/:id` (update with Zod), `DELETE /instances/:id`, `GET /versions` (with ?type= filter), `POST /prepare/:id` (trigger version/library/asset downloads, return classpath + mainClass + assetIndex), `GET /accounts` (list), `POST /accounts` (create from auth result), `DELETE /accounts/:id`. Use Zod schemas matching the shared types. (2) Modify `packages/backend/src/app.ts` - mount launcher routes at `/api/launcher`. Read existing `packages/backend/src/routes/servers.ts` for the pattern. Reference `plans/EPIC-3-client-launcher.md` Phase 3D.3 and `.spec-workflow/specs/minecraft-client-launcher/design.md`. | Restrictions: Use `.js` extensions in imports. Follow existing async route handler pattern with try/catch/next. Do NOT implement auth logic in routes (that's Rust-side). Use NotFoundError from utils/errors.ts for 404s. | Success: All routes compile, Zod schemas match shared types, routes are mounted in app.ts, prepare endpoint orchestrates downloads and returns launch metadata. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 6. Implement Rust auth module (Microsoft OAuth2 + Xbox + MC)\n  - Files: `packages/desktop/src-tauri/src/auth.rs` (new), `packages/desktop/src-tauri/src/lib.rs` (modify), `packages/desktop/src-tauri/Cargo.toml` (modify)\n  - Implement full MS device code flow: `ms_auth_start()`, `ms_auth_poll()` with Xbox Live -> XSTS -> MC Services chain\n  - Implement `ms_auth_refresh()` for token refresh\n  - Implement `get_mc_access_token()` and `remove_account()` for keychain management\n  - Add Cargo deps: `tauri-plugin-keychain`, `reqwest` (json feature), `chrono`\n  - Register commands in lib.rs invoke_handler\n  - Purpose: Secure authentication with tokens stored in OS keychain\n  - _Leverage: `plans/EPIC-3-client-launcher.md` Phase 3A for exact Rust implementation_\n  - _Requirements: REQ-1_\n  - _Prompt: Implement the task for spec minecraft-client-launcher, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Rust Developer with expertise in OAuth2 flows and Tauri plugin system | Task: Create `packages/desktop/src-tauri/src/auth.rs` implementing the full Microsoft authentication chain. Reference `plans/EPIC-3-client-launcher.md` Phase 3A for the complete Rust code. Implement: (1) Structs: `DeviceCodeResponse`, `TokenResponse`, `XboxLiveAuthResponse`, `MinecraftAuthResponse`, `MinecraftProfile`, `AuthState`. (2) Commands: `ms_auth_start()` - POST to MS devicecode endpoint, return device code + URL. `ms_auth_poll()` - poll token endpoint, on success chain through Xbox Live auth, XSTS auth, MC login, profile fetch, store tokens in keychain. `ms_auth_refresh(account_uuid)` - refresh expired tokens. `get_mc_access_token(account_uuid)` - retrieve from keychain. `remove_account(account_uuid)` - delete tokens from keychain. (3) Update `Cargo.toml`: add `tauri-plugin-keychain = \"2\"`, `reqwest = { version = \"0.12\", features = [\"json\"] }`, `chrono = \"0.4\"`. (4) Update `lib.rs`: add `mod auth;`, register commands in invoke_handler, manage AuthState, add keychain plugin. Use `MS_CLIENT_ID` as a const (placeholder for Azure app ID). | Restrictions: Do NOT hardcode real credentials. Use placeholder MS_CLIENT_ID with a comment. Do NOT store tokens in SQLite or files -- keychain ONLY. Do NOT implement game launching (separate task). Keep auth.rs focused on authentication only. | Success: All Rust files compile (syntax-correct), auth commands are registered, keychain plugin is configured, device code flow and full auth chain are implemented. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 7. Implement Rust Java manager module\n  - Files: `packages/desktop/src-tauri/src/java.rs` (new), `packages/desktop/src-tauri/src/lib.rs` (modify)\n  - Implement `get_java_installations()`: scan JAVA_HOME, PATH, platform-specific dirs, parse `java -version` output\n  - Implement `download_java(version)`: fetch from Adoptium API, extract archive, store in `launcher/runtime/java-{version}/`\n  - Register commands in lib.rs\n  - Purpose: Java detection and auto-download for game launching\n  - _Leverage: `packages/backend/src/services/java.ts` for detection logic, `plans/EPIC-3-client-launcher.md` Phase 3C_\n  - _Requirements: REQ-4_\n  - _Prompt: Implement the task for spec minecraft-client-launcher, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Rust Developer with expertise in system process management and cross-platform file operations | Task: Create `packages/desktop/src-tauri/src/java.rs`. Reference `plans/EPIC-3-client-launcher.md` Phase 3C for the implementation. Also read `packages/backend/src/services/java.ts` for the existing detection logic to replicate. Implement: (1) `get_java_installations()` - scan common paths per platform (Windows: `C:\\Program Files\\Java`, `C:\\Program Files\\Eclipse Adoptium`; macOS: `/Library/Java/JavaVirtualMachines`; Linux: `/usr/lib/jvm`), also check JAVA_HOME, run `java -version` to parse version/vendor, deduplicate by path. (2) `download_java(app, version)` - fetch from Adoptium API (`https://api.adoptium.net/v3/binary/latest/{ver}/ga/{os}/{arch}/jdk/hotspot/normal/eclipse`), extract to `{appDataDir}/launcher/runtime/java-{ver}/`, return `JavaInstallation`. Map OS: win32→windows, macos→mac, linux→linux. Map arch: x86_64→x64, aarch64→aarch64. (3) Update `lib.rs`: add `mod java;`, register commands. | Restrictions: Do NOT implement game launching. Handle missing java gracefully (skip, don't crash). Platform-specific code must use `#[cfg(target_os = \"...\")]`. | Success: Java detection works on current platform, Adoptium download URL construction is correct, commands are registered. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 8. Implement Rust game launcher module\n  - Files: `packages/desktop/src-tauri/src/launcher.rs` (new), `packages/desktop/src-tauri/src/lib.rs` (modify)\n  - Implement `launch_game(instance_id, account_id)`: fetch instance from backend, get MC token from keychain, resolve Java path, call backend prepare endpoint, extract natives, build JVM args (Xms, Xmx, natives path, classpath), build game args (username, uuid, token, gameDir, assetsDir, assetIndex, version), spawn java process, track in `LauncherState`\n  - Implement `get_running_games()` and `kill_game(instance_id)`\n  - Monitor process exit in background, update playtime via backend API\n  - Purpose: Full game launching with correct command construction\n  - _Leverage: `plans/EPIC-3-client-launcher.md` Phase 3E for Rust implementation, `packages/backend/src/services/process.ts` for process management patterns_\n  - _Requirements: REQ-5_\n  - _Prompt: Implement the task for spec minecraft-client-launcher, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: Rust Developer with expertise in child process management and Minecraft launch mechanics | Task: Create `packages/desktop/src-tauri/src/launcher.rs`. Reference `plans/EPIC-3-client-launcher.md` Phase 3E for the implementation. Implement: (1) `LauncherState` with `running_games: Mutex<Vec<GameProcess>>`. (2) `launch_game(app, state, instance_id, account_id)` - full launch sequence: verify MC token via `auth::get_mc_access_token`, fetch instance from backend `GET /api/launcher/instances/:id`, call `POST /api/launcher/prepare/:id` to get classpath/mainClass/etc, resolve Java path (from instance config or auto-detect via java module), extract natives to temp dir, build JVM args (`-Xms{min}G -Xmx{max}G -Djava.library.path={natives} -cp {classpath}`), build game args (auth_player_name, auth_uuid, auth_access_token, game_directory, assets_root, assets_index_name, version_name, resolution), spawn `Command::new(java).args(jvm_args).arg(mainClass).args(game_args).current_dir(instanceDir)`, track process. (3) Background task to monitor exit and PATCH playtime. (4) `get_running_games()` and `kill_game()`. (5) Update `lib.rs`: add `mod launcher;`, register commands, manage LauncherState. | Restrictions: Do NOT re-implement auth or Java detection (use the other modules). Process monitoring should be non-blocking (tokio::spawn). Do NOT block the main thread. | Success: Launch command is correctly constructed per Mojang spec, process spawns and is tracked, exit monitoring updates playtime, all commands registered. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 9. Create launcher frontend page and instance management UI\n  - Files: `packages/frontend/src/pages/Launcher.tsx` (new), `packages/frontend/src/components/launcher/InstanceGrid.tsx` (new), `packages/frontend/src/components/launcher/InstanceCard.tsx` (new), `packages/frontend/src/components/launcher/CreateInstanceWizard.tsx` (new), `packages/frontend/src/App.tsx` (modify)\n  - Launcher page: grid of instance cards, \"Create Instance\" button, account selector\n  - Instance card: icon, name, MC version, loader badge, last played, Play button\n  - Create wizard: 4 steps (version selection -> mod loader -> configuration -> confirm)\n  - Add `/launcher` route to App.tsx, add Launcher link to Layout sidebar\n  - Purpose: Main launcher UI for managing and launching game instances\n  - _Leverage: `packages/frontend/src/pages/CreateServer.tsx` for wizard pattern, `packages/frontend/src/components/ServerCard.tsx` for card pattern, `plans/EPIC-3-client-launcher.md` Phase 3E+ (frontend section)_\n  - _Requirements: REQ-2, REQ-6_\n  - _Prompt: Implement the task for spec minecraft-client-launcher, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in UI component design and Tailwind CSS | Task: (1) Create `packages/frontend/src/pages/Launcher.tsx` (default export) - fetches instances from `/api/launcher/instances`, displays `InstanceGrid`, has \"Create Instance\" button. (2) Create `packages/frontend/src/components/launcher/InstanceGrid.tsx` - grid layout of `InstanceCard` components with empty state. (3) Create `packages/frontend/src/components/launcher/InstanceCard.tsx` - card showing: instance name, MC version, loader badge (if applicable), last played (relative time), total playtime, prominent Play button. (4) Create `packages/frontend/src/components/launcher/CreateInstanceWizard.tsx` - multi-step wizard: Step 1 (version selector with type filter), Step 2 (optional mod loader: Fabric/Forge/NeoForge/Quilt or none), Step 3 (name, RAM min/max sliders), Step 4 (review & create). On submit POST to `/api/launcher/instances`. (5) Add `/launcher` route in App.tsx. Add \"Launcher\" link in Layout sidebar. Read existing `CreateServer.tsx` and `ServerCard.tsx` for patterns. Use Tailwind, lucide-react icons, sonner toasts. | Restrictions: Do NOT implement auth UI (separate task). Do NOT implement Tauri IPC calls (separate task). Use the existing `api` client pattern with `fetch` for REST calls. Follow existing page/component conventions. | Success: Launcher page renders instance grid, Create wizard works end-to-end, route is accessible, sidebar link works, all components compile without TypeScript errors. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 10. Create account manager and authentication UI\n  - Files: `packages/frontend/src/components/launcher/AccountManager.tsx` (new), `packages/frontend/src/components/launcher/LaunchButton.tsx` (new), `packages/frontend/src/api/client.ts` (modify)\n  - Account manager: list accounts, add account (triggers device code flow via Tauri IPC), remove account, select active account\n  - Device code display: show code prominently, button to open verification URL, polling indicator\n  - Launch button: integrates with Tauri IPC `launch_game`, shows download progress, handles errors\n  - Add launcher API methods to client.ts\n  - Purpose: Authentication UI and game launch integration\n  - _Leverage: `packages/frontend/src/api/client.ts` for API pattern, `plans/EPIC-3-client-launcher.md` for auth UI requirements_\n  - _Requirements: REQ-1, REQ-5, REQ-6_\n  - _Prompt: Implement the task for spec minecraft-client-launcher, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in Tauri IPC integration and authentication flows | Task: (1) Create `packages/frontend/src/components/launcher/AccountManager.tsx` - lists accounts from `/api/launcher/accounts`, \"Add Account\" button triggers `invoke('ms_auth_start')` (Tauri IPC), displays device code + verification URL with \"Open in Browser\" button, polls `invoke('ms_auth_poll')` every 5s, on success saves account via POST `/api/launcher/accounts`. Remove account: `invoke('remove_account')` + DELETE API. Account selector dropdown for active account. (2) Create `packages/frontend/src/components/launcher/LaunchButton.tsx` - prominent Play button that: checks for selected account (prompt if none), calls `invoke('launch_game', { instanceId, accountId })`, shows loading/progress state, handles errors with toast. Disable if game already running. (3) Add launcher API methods to `packages/frontend/src/api/client.ts`: `getLauncherInstances()`, `createLauncherInstance(data)`, `updateLauncherInstance(id, data)`, `deleteLauncherInstance(id)`, `getLauncherVersions(type?)`, `prepareLaunch(instanceId)`, `getLauncherAccounts()`, `createLauncherAccount(data)`, `deleteLauncherAccount(id)`. Use `@tauri-apps/api/core` invoke for IPC calls (conditionally imported when `isTauri()` is true). | Restrictions: Gate ALL Tauri IPC behind `isTauri()` check -- components must not crash in browser mode. Use dynamic imports for `@tauri-apps/api` to avoid build errors in browser mode. Follow existing API client patterns. | Success: Account manager shows device code flow, accounts can be added/removed, LaunchButton invokes game launch via Tauri IPC, API client methods added, no crashes in browser mode. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n\n- [ ] 11. Add download progress UI\n  - Files: `packages/frontend/src/components/launcher/DownloadProgress.tsx` (new)\n  - Overlay/modal showing: total files, downloaded files, current file name, progress bar, download speed estimate\n  - Connects to backend WebSocket or polling for progress updates during game preparation\n  - Shown between \"Play\" click and game process spawn\n  - Purpose: Visual feedback during potentially long file download phase\n  - _Leverage: `packages/frontend/src/components/Console.tsx` for real-time data display patterns, `plans/EPIC-3-client-launcher.md`_\n  - _Requirements: REQ-3, REQ-6_\n  - _Prompt: Implement the task for spec minecraft-client-launcher, first run spec-workflow-guide to get the workflow guide then implement the task: | Role: React Frontend Developer with expertise in progress indicators and real-time UI updates | Task: Create `packages/frontend/src/components/launcher/DownloadProgress.tsx` - an overlay/modal component shown during game file downloads. Props: `visible: boolean`, `progress: { current: number, total: number, currentFile?: string, phase: 'version' | 'libraries' | 'assets' }`, `onCancel?: () => void`. Display: phase label, progress bar (current/total), percentage, current file being downloaded, estimated time remaining. Use Tailwind for styling with semi-transparent overlay background. Animate progress bar. Show different messages per phase: \"Downloading version...\", \"Downloading libraries (X/Y)...\", \"Downloading assets (X/Y)...\". Read existing frontend components for styling patterns. | Restrictions: Keep component stateless (receives progress via props). Do NOT implement the actual download logic (that's in the backend services). Simple and clean UI. | Success: Component renders correctly with all progress states, animation works, overlay is dismissible via cancel, responsive design. Mark task as [-] in-progress before starting, log implementation with log-implementation tool after completion, then mark [x] complete._\n",
  "fileStats": {
    "size": 27818,
    "lines": 119,
    "lastModified": "2026-02-11T23:41:49.046Z"
  },
  "comments": []
}
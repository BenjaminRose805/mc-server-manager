{
  "id": "snapshot_1771126226315_jw7h92ahk",
  "approvalId": "approval_1771126184415_3qn06gr33",
  "approvalTitle": "Design: Launcher Download Progress",
  "version": 2,
  "timestamp": "2026-02-15T03:30:26.315Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis feature converts the game instance preparation flow from a single blocking HTTP request into an async job-based system that mirrors the existing server JAR download architecture. The `POST /api/launcher/prepare/:id` endpoint currently downloads the version JSON, client JAR, ~50 libraries, and ~2000 assets synchronously before returning — with no progress feedback. The new design introduces a `PrepareJob` stored in memory (same as `DownloadJob`), a polling endpoint, cancellation via `AbortController`, and one-per-instance guards. The frontend's existing `DownloadProgress` component receives real data instead of hardcoded zeroes.\n\nThe scope also includes removing dead code: the unused `DownloadProgressInfo` type in shared, and the hardcoded indeterminate props in `InstanceDetail.tsx`.\n\n## Steering Document Alignment\n\nPer `product.md`: This supports the \"real-time by default\" principle — long-running operations must give users visibility. Per `tech.md`: The async job pattern with in-memory storage and polling already exists for server downloads; this reuses that pattern rather than inventing a new one. Per `structure.md`: New backend code goes in `services/` and `routes/`, following the `Routes → Services → File I/O` layering. No new database tables needed (jobs are ephemeral, same as `DownloadJob`).\n\n## Code Reuse Analysis\n\n### Existing Code to Leverage\n\n- **`packages/backend/src/services/download.ts`**: The in-memory job store pattern (`Map<jobId, Job>`), one-per-entity guard (`Map<entityId, jobId>`), `AbortController` map, TTL cleanup, and fire-and-forget async pattern. This is the template for the new prepare service.\n- **`packages/backend/src/services/version-service.ts`**: `downloadVersionJson()` and `downloadGameJar()` — already work correctly, just need an `AbortSignal` threaded through their `fetch()` calls.\n- **`packages/backend/src/services/asset-service.ts`**: `downloadAssets(versionJson, onProgress?)` — already accepts an `onProgress` callback, just never wired up.\n- **`packages/backend/src/services/library-service.ts`**: `downloadLibraries(versionJson, onProgress?)` — same, already has the callback.\n- **`packages/backend/src/routes/downloads.ts`**: Route structure (POST to start, GET to poll, DELETE to cancel) — will mirror this exactly for prepare jobs.\n- **`packages/frontend/src/pages/CreateServer.tsx` (lines 1110-1208)**: The `setInterval`-based polling loop with `downloadJobIdRef`, `pollRef`, cleanup on unmount, and cancel handler. This is the exact frontend pattern to replicate in `InstanceDetail.tsx`.\n- **`packages/frontend/src/components/launcher/DownloadProgress.tsx`**: Already has the UI for phase labels, progress bar, cancel button, and indeterminate state. Just needs real props.\n- **`packages/frontend/src/api/client.ts`**: `startDownload()` and `getDownloadStatus()` methods show the pattern for adding `startPrepare()` and `getPrepareStatus()`.\n\n### Integration Points\n\n- **`packages/backend/src/routes/launcher.ts`**: The existing `POST /prepare/:id` handler (lines 126-156) will be replaced with the async job kickoff.\n- **`packages/backend/src/app.ts`**: Route mounting — new prepare routes will be added to the existing launcher router (no new router needed).\n- **`packages/frontend/src/pages/InstanceDetail.tsx`**: The `handleLaunch` function (line 500) will change from `await api.prepareLaunch(id)` to the start-then-poll pattern.\n- **`packages/electron/src/launcher.ts`**: The `launchGame()` function calls `POST /api/launcher/prepare/:id` directly. With the new async flow, Electron will call the frontend's HTTP API (which polls), or the Electron launcher will need to poll the prepare job itself. Since the frontend already handles preparation before calling `window.electronAPI.launchGame()`, the Electron side just receives the `PrepareResponse` data and spawns the game — **no Electron changes needed**.\n\n### Shared Types Already Available\n\n- `DownloadJob`, `DownloadJobStatus` — conceptual reference but these are server-specific. We'll create a parallel `PrepareJob` / `PrepareJobStatus` type.\n- `PrepareResponse` — already exists, will be embedded in the completed job.\n- `DownloadProgressInfo` — exists but is dead code. Will be removed.\n- `LauncherInstance` — used to look up instance details.\n\n## Architecture\n\n```\nFrontend (InstanceDetail.tsx)                    Backend (launcher routes)\n─────────────────────────────────────           ──────────────────────────────\n                                                \n1. User clicks \"Play\"                           \n   POST /api/launcher/prepare/:id ───────────►  Create PrepareJob (in-memory)\n   ◄──── 202 { id, status: \"pending\" }          Fire async runPrepare()\n                                                   ├── VersionService.downloadVersionJson()\n2. Poll loop (500ms interval)                      ├── VersionService.downloadGameJar()\n   GET /api/launcher/prepare/jobs/:jobId ────►     ├── LibraryService.downloadLibraries(onProgress)\n   ◄──── { status, phase, current, total }         └── AssetService.downloadAssets(onProgress)\n                                                        (updates job object in-place)\n3. Job completes                                \n   GET returns { status: \"completed\",           \n     result: PrepareResponse }                  \n   → Dismiss overlay                            \n   → Call electronAPI.launchGame()              \n                                                \n4. (Optional) User cancels                      \n   DELETE /api/launcher/prepare/jobs/:jobId ──►  AbortController.abort()\n   → Job marked failed, user can retry          \n```\n\n### Design Principles Applied\n\n- **Single File Responsibility**: `prepare-service.ts` handles job lifecycle; route handler is thin; frontend polling logic stays in `InstanceDetail.tsx`.\n- **Transport Separation**: All download orchestration lives in the service. Routes only validate and delegate. No business logic in route handlers.\n- **Pattern Reuse Over Invention**: Every pattern (job map, abort map, guard map, polling, TTL cleanup) is copied from the existing server download system, not reinvented.\n\n## Components and Interfaces\n\n### Component 1: Shared Types (`shared/src/index.ts`)\n\n- **Purpose**: Define the `PrepareJob` type that both backend and frontend use.\n- **Interfaces**:\n  ```typescript\n  export type PreparePhase =\n    | \"pending\"\n    | \"version\"        // downloading version JSON + client JAR\n    | \"libraries\"      // downloading library JARs\n    | \"assets\"         // downloading asset objects\n    | \"completed\"\n    | \"failed\";\n\n  export interface PrepareJob {\n    id: string;\n    instanceId: string;\n    mcVersion: string;\n    phase: PreparePhase;\n    /** 0-100 overall progress across all phases */\n    progress: number;\n    /** Current item count within the active phase (e.g., 45 of 200 libraries) */\n    phaseCurrent: number;\n    /** Total item count within the active phase */\n    phaseTotal: number;\n    /** The prepare result, populated on completion */\n    result: PrepareResponse | null;\n    error?: string;\n    createdAt: number;\n  }\n  ```\n- **Changes**: Also remove `DownloadProgressInfo` interface (dead code).\n- **Dependencies**: `PrepareResponse` (already exists in shared)\n- **Reuses**: Modeled after `DownloadJob` but with phase-based tracking instead of byte-based.\n\n### Component 2: Prepare Service (`packages/backend/src/services/prepare-service.ts`)\n\n- **Purpose**: Manages prepare job lifecycle — creation, execution, progress tracking, cancellation, cleanup.\n- **Interfaces**:\n  ```typescript\n  /** Get a prepare job by ID */\n  export function getPrepareJob(jobId: string): PrepareJob | undefined;\n\n  /** Start an async prepare job for an instance. Returns the job immediately. */\n  export function startPrepare(instanceId: string, mcVersion: string): PrepareJob;\n\n  /** Cancel an in-progress prepare job. Returns true if cancelled. */\n  export function cancelPrepare(jobId: string): boolean;\n\n  /** Clean up completed/failed jobs older than TTL. */\n  export function cleanupOldPrepareJobs(): void;\n  ```\n- **Internal state** (mirrors `download.ts`):\n  ```typescript\n  const jobs = new Map<string, PrepareJob>();\n  const activeInstancePrepares = new Map<string, string>(); // instanceId -> jobId\n  const abortControllers = new Map<string, AbortController>(); // jobId -> controller\n  const JOB_TTL_MS = 60 * 60 * 1000; // 1 hour\n  ```\n- **`runPrepare()` internal function** orchestrates the phases:\n  1. Set phase to `\"version\"`, call `versionService.downloadVersionJson()` and `versionService.downloadGameJar()`.\n  2. Set phase to `\"libraries\"`, call `libraryService.downloadLibraries(versionJson, onProgress)` where `onProgress` updates `job.phaseCurrent`/`job.phaseTotal` and recalculates `job.progress`.\n  3. Set phase to `\"assets\"`, call `assetService.downloadAssets(versionJson, onProgress)` with same pattern.\n  4. Build the `PrepareResponse` object, set `job.result`, set phase to `\"completed\"`.\n  - On error: set phase to `\"failed\"`, record `job.error`.\n  - On abort: set phase to `\"failed\"`, set `job.error = \"Cancelled\"`.\n- **Progress calculation**: Overall progress is weighted: version phase = 5%, libraries = 25%, assets = 70% (assets are the bulk). Within each phase, linear by item count.\n- **Dependencies**: `VersionService`, `AssetService`, `LibraryService` (existing instances from the launcher router), `nanoid`, `logger`.\n- **Reuses**: Exact same job map / abort / guard / TTL pattern from `download.ts`.\n\n### Component 3: AbortSignal Threading in Download Services\n\n- **Purpose**: Allow `fetch()` calls in `VersionService`, `AssetService`, and `LibraryService` to be cancelled.\n- **Changes**:\n  - `VersionService.downloadVersionJson(versionId, signal?)` — pass `signal` to `fetch()` calls.\n  - `VersionService.downloadGameJar(versionId, signal?)` — pass `signal` to `fetch()`.\n  - `AssetService.downloadAssets(versionJson, onProgress?, signal?)` — pass `signal` to `fetch()` in `downloadAsset()`.\n  - `LibraryService.downloadLibraries(versionJson, onProgress?, signal?)` — pass `signal` to `fetch()` in `downloadArtifact()`.\n- **All parameters are optional** — existing callers (if any besides the prepare route) continue to work without changes.\n- **Dependencies**: None new. Just adding an optional `AbortSignal` parameter.\n\n### Component 4: Launcher Route Updates (`packages/backend/src/routes/launcher.ts`)\n\n- **Purpose**: Replace the blocking `POST /prepare/:id` with async job endpoints.\n- **Changes to existing routes**:\n  - `POST /prepare/:id` → Now returns `202 { PrepareJob }` instead of blocking until completion.\n- **New route**:\n  - `GET /prepare/jobs/:jobId` → Returns `PrepareJob` (poll for progress).\n  - `DELETE /prepare/jobs/:jobId` → Cancels a prepare job.\n- **Interfaces**:\n  ```typescript\n  // POST /api/launcher/prepare/:id — Start async prepare\n  // Response: 202 PrepareJob\n\n  // GET /api/launcher/prepare/jobs/:jobId — Poll progress\n  // Response: 200 PrepareJob\n\n  // DELETE /api/launcher/prepare/jobs/:jobId — Cancel\n  // Response: 200 { message: string, jobId: string }\n  ```\n- **Dependencies**: `prepare-service.ts`, `instance-service.ts` (existing), error classes.\n- **Reuses**: Exact same route structure as `routes/downloads.ts`.\n\n### Component 5: Frontend API Client (`packages/frontend/src/api/client.ts`)\n\n- **Purpose**: Add methods for the new prepare job endpoints.\n- **Changes**:\n  ```typescript\n  // Modify existing:\n  prepareLaunch(instanceId: string): Promise<PrepareJob> {\n    // Now returns a PrepareJob instead of PrepareResponse\n    return request<PrepareJob>(`/api/launcher/prepare/${instanceId}`, { method: 'POST' });\n  }\n\n  // Add new:\n  getPrepareStatus(jobId: string): Promise<PrepareJob> {\n    return request<PrepareJob>(`/api/launcher/prepare/jobs/${jobId}`);\n  }\n\n  cancelPrepare(jobId: string): Promise<void> {\n    return request(`/api/launcher/prepare/jobs/${jobId}`, { method: 'DELETE' });\n  }\n  ```\n- **Dependencies**: Existing `request` helper.\n- **Reuses**: Same pattern as `startDownload()` / `getDownloadStatus()` / `cancelDownload()`.\n\n### Component 6: InstanceDetail Polling Logic (`packages/frontend/src/pages/InstanceDetail.tsx`)\n\n- **Purpose**: Replace the `await api.prepareLaunch(id)` call with start + poll + cancel flow.\n- **Changes to `handleLaunch()`**:\n  1. Call `api.prepareLaunch(id)` → receives `PrepareJob` with `id`.\n  2. Store `jobId` in a ref.\n  3. Start `setInterval` polling (500ms) on `api.getPrepareStatus(jobId)`.\n  4. Update `DownloadProgress` props from the polled job data.\n  5. On `phase === \"completed\"`: clear interval, extract `job.result` (the `PrepareResponse`), proceed to launch.\n  6. On `phase === \"failed\"`: clear interval, show error toast.\n- **Cancel handler**: Call `api.cancelPrepare(jobId)`, clear interval, reset state.\n- **Reuses**: Exact same pattern as `CreateServer.tsx` lines 1110-1208.\n\n### Component 7: DownloadProgress Wiring (`packages/frontend/src/components/launcher/DownloadProgress.tsx`)\n\n- **Purpose**: The component already works. Just needs the right props from `InstanceDetail.tsx`.\n- **Changes**: None to the component itself. The `InstanceDetail.tsx` will now pass real values:\n  ```typescript\n  <DownloadProgress\n    visible={preparing}\n    progress={{\n      phase: mapPreparePhaseToDisplayPhase(job.phase),\n      current: job.phaseCurrent,\n      total: job.phaseTotal,\n    }}\n    onCancel={handleCancel}\n  />\n  ```\n- **Phase mapping**: `PreparePhase` → `DownloadProgress` phase: `\"version\"` → `\"version\"`, `\"libraries\"` → `\"libraries\"`, `\"assets\"` → `\"assets\"`. The pending/completed/failed states don't need mapping since the overlay is hidden for those.\n\n### Component 8: Dead Code Removal\n\n- **`shared/src/index.ts`**: Remove the `DownloadProgressInfo` interface (lines ~890-895). Verify no remaining references.\n- **`packages/frontend/src/pages/InstanceDetail.tsx`**: Remove the hardcoded `{ phase: \"version\", current: 0, total: 0 }` prop (replaced by real data in Component 6).\n\n## Data Models\n\nNo new database tables. Prepare jobs are ephemeral in-memory objects (same as `DownloadJob`). They don't survive backend restarts — this is acceptable because cached files persist on disk and a retry is fast.\n\n## API Endpoints\n\n| Method | Path | Auth | Request Body | Response | Purpose |\n|--------|------|------|--------------|----------|---------|\n| POST | `/api/launcher/prepare/:id` | inherit | - | `202 PrepareJob` | Start async prepare (changed from blocking) |\n| GET | `/api/launcher/prepare/jobs/:jobId` | inherit | - | `200 PrepareJob` | Poll prepare progress (new) |\n| DELETE | `/api/launcher/prepare/jobs/:jobId` | inherit | - | `200 { message, jobId }` | Cancel prepare (new) |\n\n## WebSocket Events\n\nNo new WebSocket events. Progress is delivered via HTTP polling (matching the existing server download pattern). WebSocket could be added later as an optimization but is out of scope — polling at 500ms is adequate for a progress bar.\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Instance not found**\n   - **Error Class**: `NotFoundError`\n   - **Handling**: `POST /prepare/:id` returns 404 if instance ID doesn't exist.\n   - **User Impact**: Toast \"Instance not found\".\n\n2. **Duplicate prepare (job already active)**\n   - **Error Class**: `ConflictError`\n   - **Handling**: `POST /prepare/:id` returns 409 if a prepare job is already active for this instance.\n   - **User Impact**: Toast \"A download is already in progress for this instance\".\n\n3. **Prepare job not found (polling)**\n   - **Error Class**: `NotFoundError`\n   - **Handling**: `GET /prepare/jobs/:jobId` returns 404. Frontend stops polling.\n   - **User Impact**: Toast \"Prepare job not found\" (edge case — job TTL expired or backend restarted).\n\n4. **Download failure (network error, hash mismatch)**\n   - **Error Class**: None (caught internally by `runPrepare`)\n   - **Handling**: Job status set to `\"failed\"` with error message. Frontend detects on next poll.\n   - **User Impact**: Progress overlay dismissed, toast with error message.\n\n5. **Cancellation**\n   - **Error Class**: None\n   - **Handling**: `AbortController.abort()` propagates to all `fetch()` calls. Job marked `\"failed\"` with `\"Cancelled\"`.\n   - **User Impact**: Overlay dismissed, user can retry immediately.\n\n6. **Cancel request on non-active job**\n   - **Error Class**: `AppError` (409)\n   - **Handling**: `DELETE /prepare/jobs/:jobId` returns 409 if job is already completed/failed.\n   - **User Impact**: No-op (frontend shouldn't show cancel button for completed jobs).\n\n## Verification Strategy\n\n### Build Verification\n\n- `npm run build` must pass with zero errors after implementation.\n- `npm run build -w shared` must pass (type changes).\n- No TypeScript errors in changed files (verify via `lsp_diagnostics`).\n\n### Manual Testing Checklist\n\n1. **First launch of new version** (no cached files): Click Play → progress overlay appears with \"Downloading version\", then \"Downloading libraries (X/Y)\", then \"Downloading assets (X/Y)\" → game launches (Electron) or \"requires desktop app\" message (browser). Progress bar should advance steadily.\n2. **Second launch of same version** (all cached): Click Play → progress overlay appears briefly (seconds), all phases complete quickly → game launches.\n3. **Cancel mid-download**: Click Play → wait for assets phase → click Cancel → overlay dismisses, toast shows \"Cancelled\" → click Play again → new job starts, progress resumes from where cached files left off.\n4. **Double-click Play**: Click Play twice rapidly → first click starts job, second click gets 409 conflict toast.\n5. **Backend restart during prepare**: Start a prepare → restart backend → frontend polling gets 404 → toast error → user retries successfully.\n\n### Parity / Migration Checks\n\n| Existing Behavior | New Implementation | Verify |\n|---|---|---|\n| `POST /prepare/:id` blocks until done, returns `PrepareResponse` | `POST /prepare/:id` returns `PrepareJob` immediately; `PrepareResponse` is in `job.result` on completion | Frontend extracts `job.result` after polling shows `completed` |\n| `DownloadProgress` shows indeterminate spinner | `DownloadProgress` shows real phase/count/percentage | Visual inspection during first-launch download |\n| No cancel button wired | Cancel button calls `DELETE /prepare/jobs/:jobId` | Click cancel, verify job stops and overlay dismisses |\n| No concurrency guard | `ConflictError` on duplicate prepare | Double-click Play, verify 409 toast |\n\n## Implementation Order\n\n1. **Shared types** — Add `PreparePhase` and `PrepareJob` to `shared/src/index.ts`. Remove `DownloadProgressInfo`. No dependencies.\n2. **AbortSignal threading** — Add optional `signal` parameter to `VersionService`, `AssetService`, `LibraryService` fetch calls. No dependencies beyond (1) for types.\n3. **Prepare service** — Create `prepare-service.ts` with job lifecycle, progress wiring, cancellation. Depends on (1) for types and (2) for signal support.\n4. **Route updates** — Modify `POST /prepare/:id` and add `GET/DELETE /prepare/jobs/:jobId`. Depends on (3).\n5. **Frontend API + polling** — Update `client.ts` methods, rewrite `InstanceDetail.tsx` `handleLaunch` with polling loop, wire real props to `DownloadProgress`. Depends on (1) for types and (4) for API.\n6. **Dead code cleanup + verification** — Remove `DownloadProgressInfo`, remove hardcoded props, verify build passes. Depends on all previous steps.\n\nEach step can be verified independently (`npm run build -w <package>` + `lsp_diagnostics`) before proceeding.\n\n## Migration / Backward Compatibility\n\nThe `POST /api/launcher/prepare/:id` endpoint changes its response contract from `PrepareResponse` (synchronous) to `PrepareJob` (async, 202). This is a **breaking change** to this endpoint.\n\n**Impact assessment:**\n- The only consumer of this endpoint is `packages/electron/src/launcher.ts` (`fetchJson<PrepareResponse>(...)`), called via `packages/frontend/src/pages/InstanceDetail.tsx` which calls `api.prepareLaunch(id)`.\n- The Electron launcher's `launchGame()` function calls `POST /api/launcher/prepare/:id` directly. However, looking at the actual flow: the frontend calls `api.prepareLaunch(id)` first, THEN calls `window.electronAPI.launchGame(id, accountId)`. The Electron `launchGame()` also calls prepare internally.\n- **Solution**: The Electron `launchGame()` function needs to be updated. Since the frontend now handles preparation (start job → poll → get result), the Electron launcher should accept the `PrepareResponse` data instead of calling prepare itself. This avoids the Electron side needing its own polling logic. The `launchGame()` IPC signature changes to accept the prepare result directly.\n- This is an internal API — no external consumers.\n",
  "fileStats": {
    "size": 21120,
    "lines": 328,
    "lastModified": "2026-02-15T03:29:37.915Z"
  },
  "comments": []
}